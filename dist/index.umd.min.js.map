{"version":3,"file":"index.umd.min.js","sources":["../node_modules/@meeshkanml/json-schema-ref-parser/lib/parsers/json.js","../node_modules/js-yaml/lib/js-yaml/common.js","../node_modules/js-yaml/lib/js-yaml/exception.js","../node_modules/js-yaml/lib/js-yaml/mark.js","../node_modules/js-yaml/lib/js-yaml/type.js","../node_modules/js-yaml/lib/js-yaml/schema.js","../node_modules/js-yaml/lib/js-yaml/schema/failsafe.js","../node_modules/js-yaml/lib/js-yaml/type/str.js","../node_modules/js-yaml/lib/js-yaml/type/seq.js","../node_modules/js-yaml/lib/js-yaml/type/map.js","../node_modules/js-yaml/lib/js-yaml/type/null.js","../node_modules/js-yaml/lib/js-yaml/type/bool.js","../node_modules/js-yaml/lib/js-yaml/type/int.js","../node_modules/js-yaml/lib/js-yaml/type/float.js","../node_modules/js-yaml/lib/js-yaml/schema/json.js","../node_modules/js-yaml/lib/js-yaml/schema/core.js","../node_modules/js-yaml/lib/js-yaml/type/timestamp.js","../node_modules/js-yaml/lib/js-yaml/type/merge.js","../node_modules/js-yaml/lib/js-yaml/type/binary.js","../node_modules/js-yaml/lib/js-yaml/type/omap.js","../node_modules/js-yaml/lib/js-yaml/type/pairs.js","../node_modules/js-yaml/lib/js-yaml/type/set.js","../node_modules/js-yaml/lib/js-yaml/schema/default_safe.js","../node_modules/js-yaml/lib/js-yaml/type/js/undefined.js","../node_modules/js-yaml/lib/js-yaml/type/js/regexp.js","../node_modules/js-yaml/lib/js-yaml/type/js/function.js","../node_modules/js-yaml/lib/js-yaml/schema/default_full.js","../node_modules/js-yaml/lib/js-yaml/loader.js","../node_modules/js-yaml/lib/js-yaml/dumper.js","../node_modules/js-yaml/lib/js-yaml.js","../node_modules/ono/esm/to-json.js","../node_modules/ono/esm/isomorphic.node.js","../node_modules/ono/esm/stack.js","../node_modules/ono/esm/extend-error.js","../node_modules/ono/esm/ono.js","../node_modules/ono/esm/index.js","../node_modules/@meeshkanml/json-schema-ref-parser/lib/util/yaml.js","../node_modules/@meeshkanml/json-schema-ref-parser/lib/parsers/yaml.js","../node_modules/@meeshkanml/json-schema-ref-parser/lib/parsers/text.js","../node_modules/@meeshkanml/json-schema-ref-parser/lib/parsers/binary.js","../node_modules/@meeshkanml/json-schema-ref-parser/lib/util/url.js","../node_modules/@meeshkanml/json-schema-ref-parser/lib/resolvers/file.js","../node_modules/@meeshkanml/json-schema-ref-parser/lib/resolvers/http.js","../node_modules/@meeshkanml/json-schema-ref-parser/lib/options.js","../node_modules/@meeshkanml/json-schema-ref-parser/lib/pointer.js","../node_modules/@meeshkanml/json-schema-ref-parser/lib/ref.js","../node_modules/@meeshkanml/json-schema-ref-parser/lib/refs.js","../node_modules/@meeshkanml/json-schema-ref-parser/lib/util/plugins.js","../node_modules/@meeshkanml/json-schema-ref-parser/lib/parse.js","../node_modules/@meeshkanml/json-schema-ref-parser/lib/normalize-args.js","../node_modules/@meeshkanml/json-schema-ref-parser/lib/resolve-external.js","../node_modules/@meeshkanml/json-schema-ref-parser/lib/bundle.js","../node_modules/@meeshkanml/json-schema-ref-parser/lib/dereference.js","../node_modules/call-me-maybe/index.js","../node_modules/@meeshkanml/json-schema-ref-parser/lib/index.js","../src/class/Registry.js","../src/class/OptionRegistry.js","../src/api/option.js","../src/core/constants.js","../node_modules/ret/lib/types.js","../node_modules/ret/lib/sets.js","../node_modules/ret/lib/util.js","../node_modules/ret/lib/positions.js","../node_modules/ret/lib/index.js","../node_modules/drange/lib/index.js","../node_modules/randexp/lib/randexp.js","../src/core/random.js","../src/core/utils.js","../src/class/Container.js","../src/api/format.js","../src/core/error.js","../src/core/infer.js","../src/types/boolean.js","../src/generators/boolean.js","../src/types/null.js","../src/generators/null.js","../src/types/number.js","../src/generators/words.js","../src/types/object.js","../src/generators/thunk.js","../src/generators/dateTime.js","../src/generators/coreFormat.js","../src/types/string.js","../src/generators/date.js","../src/generators/time.js","../src/generators/ipv4.js","../src/types/index.js","../src/types/array.js","../src/types/integer.js","../src/core/traverse.js","../src/core/run.js","../src/index.js"],"sourcesContent":["\"use strict\";\n\nmodule.exports = {\n  /**\n   * The order that this parser will run, in relation to other parsers.\n   *\n   * @type {number}\n   */\n  order: 100,\n\n  /**\n   * Whether to allow \"empty\" files. This includes zero-byte files, as well as empty JSON objects.\n   *\n   * @type {boolean}\n   */\n  allowEmpty: true,\n\n  /**\n   * Determines whether this parser can parse a given file reference.\n   * Parsers that match will be tried, in order, until one successfully parses the file.\n   * Parsers that don't match will be skipped, UNLESS none of the parsers match, in which case\n   * every parser will be tried.\n   *\n   * @type {RegExp|string[]|function}\n   */\n  canParse: \".json\",\n\n  /**\n   * Parses the given file as JSON\n   *\n   * @param {object} file           - An object containing information about the referenced file\n   * @param {string} file.url       - The full URL of the referenced file\n   * @param {string} file.extension - The lowercased file extension (e.g. \".txt\", \".html\", etc.)\n   * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver\n   * @returns {Promise}\n   */\n  parse (file) {\n    return new Promise(((resolve, reject) => {\n      let data = file.data;\n      if (Buffer.isBuffer(data)) {\n        data = data.toString();\n      }\n\n      if (typeof data === \"string\") {\n        if (data.trim().length === 0) {\n          resolve(undefined);  // This mirrors the YAML behavior\n        }\n        else {\n          resolve(JSON.parse(data));\n        }\n      }\n      else {\n        // data is already a JavaScript value (object, array, number, null, NaN, etc.)\n        resolve(data);\n      }\n    }));\n  }\n};\n","'use strict';\n\n\nfunction isNothing(subject) {\n  return (typeof subject === 'undefined') || (subject === null);\n}\n\n\nfunction isObject(subject) {\n  return (typeof subject === 'object') && (subject !== null);\n}\n\n\nfunction toArray(sequence) {\n  if (Array.isArray(sequence)) return sequence;\n  else if (isNothing(sequence)) return [];\n\n  return [ sequence ];\n}\n\n\nfunction extend(target, source) {\n  var index, length, key, sourceKeys;\n\n  if (source) {\n    sourceKeys = Object.keys(source);\n\n    for (index = 0, length = sourceKeys.length; index < length; index += 1) {\n      key = sourceKeys[index];\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\n\nfunction repeat(string, count) {\n  var result = '', cycle;\n\n  for (cycle = 0; cycle < count; cycle += 1) {\n    result += string;\n  }\n\n  return result;\n}\n\n\nfunction isNegativeZero(number) {\n  return (number === 0) && (Number.NEGATIVE_INFINITY === 1 / number);\n}\n\n\nmodule.exports.isNothing      = isNothing;\nmodule.exports.isObject       = isObject;\nmodule.exports.toArray        = toArray;\nmodule.exports.repeat         = repeat;\nmodule.exports.isNegativeZero = isNegativeZero;\nmodule.exports.extend         = extend;\n","// YAML error class. http://stackoverflow.com/questions/8458984\n//\n'use strict';\n\nfunction YAMLException(reason, mark) {\n  // Super constructor\n  Error.call(this);\n\n  this.name = 'YAMLException';\n  this.reason = reason;\n  this.mark = mark;\n  this.message = (this.reason || '(unknown reason)') + (this.mark ? ' ' + this.mark.toString() : '');\n\n  // Include stack trace in error object\n  if (Error.captureStackTrace) {\n    // Chrome and NodeJS\n    Error.captureStackTrace(this, this.constructor);\n  } else {\n    // FF, IE 10+ and Safari 6+. Fallback for others\n    this.stack = (new Error()).stack || '';\n  }\n}\n\n\n// Inherit from Error\nYAMLException.prototype = Object.create(Error.prototype);\nYAMLException.prototype.constructor = YAMLException;\n\n\nYAMLException.prototype.toString = function toString(compact) {\n  var result = this.name + ': ';\n\n  result += this.reason || '(unknown reason)';\n\n  if (!compact && this.mark) {\n    result += ' ' + this.mark.toString();\n  }\n\n  return result;\n};\n\n\nmodule.exports = YAMLException;\n","'use strict';\n\n\nvar common = require('./common');\n\n\nfunction Mark(name, buffer, position, line, column) {\n  this.name     = name;\n  this.buffer   = buffer;\n  this.position = position;\n  this.line     = line;\n  this.column   = column;\n}\n\n\nMark.prototype.getSnippet = function getSnippet(indent, maxLength) {\n  var head, start, tail, end, snippet;\n\n  if (!this.buffer) return null;\n\n  indent = indent || 4;\n  maxLength = maxLength || 75;\n\n  head = '';\n  start = this.position;\n\n  while (start > 0 && '\\x00\\r\\n\\x85\\u2028\\u2029'.indexOf(this.buffer.charAt(start - 1)) === -1) {\n    start -= 1;\n    if (this.position - start > (maxLength / 2 - 1)) {\n      head = ' ... ';\n      start += 5;\n      break;\n    }\n  }\n\n  tail = '';\n  end = this.position;\n\n  while (end < this.buffer.length && '\\x00\\r\\n\\x85\\u2028\\u2029'.indexOf(this.buffer.charAt(end)) === -1) {\n    end += 1;\n    if (end - this.position > (maxLength / 2 - 1)) {\n      tail = ' ... ';\n      end -= 5;\n      break;\n    }\n  }\n\n  snippet = this.buffer.slice(start, end);\n\n  return common.repeat(' ', indent) + head + snippet + tail + '\\n' +\n         common.repeat(' ', indent + this.position - start + head.length) + '^';\n};\n\n\nMark.prototype.toString = function toString(compact) {\n  var snippet, where = '';\n\n  if (this.name) {\n    where += 'in \"' + this.name + '\" ';\n  }\n\n  where += 'at line ' + (this.line + 1) + ', column ' + (this.column + 1);\n\n  if (!compact) {\n    snippet = this.getSnippet();\n\n    if (snippet) {\n      where += ':\\n' + snippet;\n    }\n  }\n\n  return where;\n};\n\n\nmodule.exports = Mark;\n","'use strict';\n\nvar YAMLException = require('./exception');\n\nvar TYPE_CONSTRUCTOR_OPTIONS = [\n  'kind',\n  'resolve',\n  'construct',\n  'instanceOf',\n  'predicate',\n  'represent',\n  'defaultStyle',\n  'styleAliases'\n];\n\nvar YAML_NODE_KINDS = [\n  'scalar',\n  'sequence',\n  'mapping'\n];\n\nfunction compileStyleAliases(map) {\n  var result = {};\n\n  if (map !== null) {\n    Object.keys(map).forEach(function (style) {\n      map[style].forEach(function (alias) {\n        result[String(alias)] = style;\n      });\n    });\n  }\n\n  return result;\n}\n\nfunction Type(tag, options) {\n  options = options || {};\n\n  Object.keys(options).forEach(function (name) {\n    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {\n      throw new YAMLException('Unknown option \"' + name + '\" is met in definition of \"' + tag + '\" YAML type.');\n    }\n  });\n\n  // TODO: Add tag format check.\n  this.tag          = tag;\n  this.kind         = options['kind']         || null;\n  this.resolve      = options['resolve']      || function () { return true; };\n  this.construct    = options['construct']    || function (data) { return data; };\n  this.instanceOf   = options['instanceOf']   || null;\n  this.predicate    = options['predicate']    || null;\n  this.represent    = options['represent']    || null;\n  this.defaultStyle = options['defaultStyle'] || null;\n  this.styleAliases = compileStyleAliases(options['styleAliases'] || null);\n\n  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {\n    throw new YAMLException('Unknown kind \"' + this.kind + '\" is specified for \"' + tag + '\" YAML type.');\n  }\n}\n\nmodule.exports = Type;\n","'use strict';\n\n/*eslint-disable max-len*/\n\nvar common        = require('./common');\nvar YAMLException = require('./exception');\nvar Type          = require('./type');\n\n\nfunction compileList(schema, name, result) {\n  var exclude = [];\n\n  schema.include.forEach(function (includedSchema) {\n    result = compileList(includedSchema, name, result);\n  });\n\n  schema[name].forEach(function (currentType) {\n    result.forEach(function (previousType, previousIndex) {\n      if (previousType.tag === currentType.tag && previousType.kind === currentType.kind) {\n        exclude.push(previousIndex);\n      }\n    });\n\n    result.push(currentType);\n  });\n\n  return result.filter(function (type, index) {\n    return exclude.indexOf(index) === -1;\n  });\n}\n\n\nfunction compileMap(/* lists... */) {\n  var result = {\n        scalar: {},\n        sequence: {},\n        mapping: {},\n        fallback: {}\n      }, index, length;\n\n  function collectType(type) {\n    result[type.kind][type.tag] = result['fallback'][type.tag] = type;\n  }\n\n  for (index = 0, length = arguments.length; index < length; index += 1) {\n    arguments[index].forEach(collectType);\n  }\n  return result;\n}\n\n\nfunction Schema(definition) {\n  this.include  = definition.include  || [];\n  this.implicit = definition.implicit || [];\n  this.explicit = definition.explicit || [];\n\n  this.implicit.forEach(function (type) {\n    if (type.loadKind && type.loadKind !== 'scalar') {\n      throw new YAMLException('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');\n    }\n  });\n\n  this.compiledImplicit = compileList(this, 'implicit', []);\n  this.compiledExplicit = compileList(this, 'explicit', []);\n  this.compiledTypeMap  = compileMap(this.compiledImplicit, this.compiledExplicit);\n}\n\n\nSchema.DEFAULT = null;\n\n\nSchema.create = function createSchema() {\n  var schemas, types;\n\n  switch (arguments.length) {\n    case 1:\n      schemas = Schema.DEFAULT;\n      types = arguments[0];\n      break;\n\n    case 2:\n      schemas = arguments[0];\n      types = arguments[1];\n      break;\n\n    default:\n      throw new YAMLException('Wrong number of arguments for Schema.create function');\n  }\n\n  schemas = common.toArray(schemas);\n  types = common.toArray(types);\n\n  if (!schemas.every(function (schema) { return schema instanceof Schema; })) {\n    throw new YAMLException('Specified list of super schemas (or a single Schema object) contains a non-Schema object.');\n  }\n\n  if (!types.every(function (type) { return type instanceof Type; })) {\n    throw new YAMLException('Specified list of YAML types (or a single Type object) contains a non-Type object.');\n  }\n\n  return new Schema({\n    include: schemas,\n    explicit: types\n  });\n};\n\n\nmodule.exports = Schema;\n","// Standard YAML's Failsafe schema.\n// http://www.yaml.org/spec/1.2/spec.html#id2802346\n\n\n'use strict';\n\n\nvar Schema = require('../schema');\n\n\nmodule.exports = new Schema({\n  explicit: [\n    require('../type/str'),\n    require('../type/seq'),\n    require('../type/map')\n  ]\n});\n","'use strict';\n\nvar Type = require('../type');\n\nmodule.exports = new Type('tag:yaml.org,2002:str', {\n  kind: 'scalar',\n  construct: function (data) { return data !== null ? data : ''; }\n});\n","'use strict';\n\nvar Type = require('../type');\n\nmodule.exports = new Type('tag:yaml.org,2002:seq', {\n  kind: 'sequence',\n  construct: function (data) { return data !== null ? data : []; }\n});\n","'use strict';\n\nvar Type = require('../type');\n\nmodule.exports = new Type('tag:yaml.org,2002:map', {\n  kind: 'mapping',\n  construct: function (data) { return data !== null ? data : {}; }\n});\n","'use strict';\n\nvar Type = require('../type');\n\nfunction resolveYamlNull(data) {\n  if (data === null) return true;\n\n  var max = data.length;\n\n  return (max === 1 && data === '~') ||\n         (max === 4 && (data === 'null' || data === 'Null' || data === 'NULL'));\n}\n\nfunction constructYamlNull() {\n  return null;\n}\n\nfunction isNull(object) {\n  return object === null;\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:null', {\n  kind: 'scalar',\n  resolve: resolveYamlNull,\n  construct: constructYamlNull,\n  predicate: isNull,\n  represent: {\n    canonical: function () { return '~';    },\n    lowercase: function () { return 'null'; },\n    uppercase: function () { return 'NULL'; },\n    camelcase: function () { return 'Null'; }\n  },\n  defaultStyle: 'lowercase'\n});\n","'use strict';\n\nvar Type = require('../type');\n\nfunction resolveYamlBoolean(data) {\n  if (data === null) return false;\n\n  var max = data.length;\n\n  return (max === 4 && (data === 'true' || data === 'True' || data === 'TRUE')) ||\n         (max === 5 && (data === 'false' || data === 'False' || data === 'FALSE'));\n}\n\nfunction constructYamlBoolean(data) {\n  return data === 'true' ||\n         data === 'True' ||\n         data === 'TRUE';\n}\n\nfunction isBoolean(object) {\n  return Object.prototype.toString.call(object) === '[object Boolean]';\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:bool', {\n  kind: 'scalar',\n  resolve: resolveYamlBoolean,\n  construct: constructYamlBoolean,\n  predicate: isBoolean,\n  represent: {\n    lowercase: function (object) { return object ? 'true' : 'false'; },\n    uppercase: function (object) { return object ? 'TRUE' : 'FALSE'; },\n    camelcase: function (object) { return object ? 'True' : 'False'; }\n  },\n  defaultStyle: 'lowercase'\n});\n","'use strict';\n\nvar common = require('../common');\nvar Type   = require('../type');\n\nfunction isHexCode(c) {\n  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) ||\n         ((0x41/* A */ <= c) && (c <= 0x46/* F */)) ||\n         ((0x61/* a */ <= c) && (c <= 0x66/* f */));\n}\n\nfunction isOctCode(c) {\n  return ((0x30/* 0 */ <= c) && (c <= 0x37/* 7 */));\n}\n\nfunction isDecCode(c) {\n  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */));\n}\n\nfunction resolveYamlInteger(data) {\n  if (data === null) return false;\n\n  var max = data.length,\n      index = 0,\n      hasDigits = false,\n      ch;\n\n  if (!max) return false;\n\n  ch = data[index];\n\n  // sign\n  if (ch === '-' || ch === '+') {\n    ch = data[++index];\n  }\n\n  if (ch === '0') {\n    // 0\n    if (index + 1 === max) return true;\n    ch = data[++index];\n\n    // base 2, base 8, base 16\n\n    if (ch === 'b') {\n      // base 2\n      index++;\n\n      for (; index < max; index++) {\n        ch = data[index];\n        if (ch === '_') continue;\n        if (ch !== '0' && ch !== '1') return false;\n        hasDigits = true;\n      }\n      return hasDigits && ch !== '_';\n    }\n\n\n    if (ch === 'x') {\n      // base 16\n      index++;\n\n      for (; index < max; index++) {\n        ch = data[index];\n        if (ch === '_') continue;\n        if (!isHexCode(data.charCodeAt(index))) return false;\n        hasDigits = true;\n      }\n      return hasDigits && ch !== '_';\n    }\n\n    // base 8\n    for (; index < max; index++) {\n      ch = data[index];\n      if (ch === '_') continue;\n      if (!isOctCode(data.charCodeAt(index))) return false;\n      hasDigits = true;\n    }\n    return hasDigits && ch !== '_';\n  }\n\n  // base 10 (except 0) or base 60\n\n  // value should not start with `_`;\n  if (ch === '_') return false;\n\n  for (; index < max; index++) {\n    ch = data[index];\n    if (ch === '_') continue;\n    if (ch === ':') break;\n    if (!isDecCode(data.charCodeAt(index))) {\n      return false;\n    }\n    hasDigits = true;\n  }\n\n  // Should have digits and should not end with `_`\n  if (!hasDigits || ch === '_') return false;\n\n  // if !base60 - done;\n  if (ch !== ':') return true;\n\n  // base60 almost not used, no needs to optimize\n  return /^(:[0-5]?[0-9])+$/.test(data.slice(index));\n}\n\nfunction constructYamlInteger(data) {\n  var value = data, sign = 1, ch, base, digits = [];\n\n  if (value.indexOf('_') !== -1) {\n    value = value.replace(/_/g, '');\n  }\n\n  ch = value[0];\n\n  if (ch === '-' || ch === '+') {\n    if (ch === '-') sign = -1;\n    value = value.slice(1);\n    ch = value[0];\n  }\n\n  if (value === '0') return 0;\n\n  if (ch === '0') {\n    if (value[1] === 'b') return sign * parseInt(value.slice(2), 2);\n    if (value[1] === 'x') return sign * parseInt(value, 16);\n    return sign * parseInt(value, 8);\n  }\n\n  if (value.indexOf(':') !== -1) {\n    value.split(':').forEach(function (v) {\n      digits.unshift(parseInt(v, 10));\n    });\n\n    value = 0;\n    base = 1;\n\n    digits.forEach(function (d) {\n      value += (d * base);\n      base *= 60;\n    });\n\n    return sign * value;\n\n  }\n\n  return sign * parseInt(value, 10);\n}\n\nfunction isInteger(object) {\n  return (Object.prototype.toString.call(object)) === '[object Number]' &&\n         (object % 1 === 0 && !common.isNegativeZero(object));\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:int', {\n  kind: 'scalar',\n  resolve: resolveYamlInteger,\n  construct: constructYamlInteger,\n  predicate: isInteger,\n  represent: {\n    binary:      function (obj) { return obj >= 0 ? '0b' + obj.toString(2) : '-0b' + obj.toString(2).slice(1); },\n    octal:       function (obj) { return obj >= 0 ? '0'  + obj.toString(8) : '-0'  + obj.toString(8).slice(1); },\n    decimal:     function (obj) { return obj.toString(10); },\n    /* eslint-disable max-len */\n    hexadecimal: function (obj) { return obj >= 0 ? '0x' + obj.toString(16).toUpperCase() :  '-0x' + obj.toString(16).toUpperCase().slice(1); }\n  },\n  defaultStyle: 'decimal',\n  styleAliases: {\n    binary:      [ 2,  'bin' ],\n    octal:       [ 8,  'oct' ],\n    decimal:     [ 10, 'dec' ],\n    hexadecimal: [ 16, 'hex' ]\n  }\n});\n","'use strict';\n\nvar common = require('../common');\nvar Type   = require('../type');\n\nvar YAML_FLOAT_PATTERN = new RegExp(\n  // 2.5e4, 2.5 and integers\n  '^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?' +\n  // .2e4, .2\n  // special case, seems not from spec\n  '|\\\\.[0-9_]+(?:[eE][-+]?[0-9]+)?' +\n  // 20:59\n  '|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\\\.[0-9_]*' +\n  // .inf\n  '|[-+]?\\\\.(?:inf|Inf|INF)' +\n  // .nan\n  '|\\\\.(?:nan|NaN|NAN))$');\n\nfunction resolveYamlFloat(data) {\n  if (data === null) return false;\n\n  if (!YAML_FLOAT_PATTERN.test(data) ||\n      // Quick hack to not allow integers end with `_`\n      // Probably should update regexp & check speed\n      data[data.length - 1] === '_') {\n    return false;\n  }\n\n  return true;\n}\n\nfunction constructYamlFloat(data) {\n  var value, sign, base, digits;\n\n  value  = data.replace(/_/g, '').toLowerCase();\n  sign   = value[0] === '-' ? -1 : 1;\n  digits = [];\n\n  if ('+-'.indexOf(value[0]) >= 0) {\n    value = value.slice(1);\n  }\n\n  if (value === '.inf') {\n    return (sign === 1) ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;\n\n  } else if (value === '.nan') {\n    return NaN;\n\n  } else if (value.indexOf(':') >= 0) {\n    value.split(':').forEach(function (v) {\n      digits.unshift(parseFloat(v, 10));\n    });\n\n    value = 0.0;\n    base = 1;\n\n    digits.forEach(function (d) {\n      value += d * base;\n      base *= 60;\n    });\n\n    return sign * value;\n\n  }\n  return sign * parseFloat(value, 10);\n}\n\n\nvar SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;\n\nfunction representYamlFloat(object, style) {\n  var res;\n\n  if (isNaN(object)) {\n    switch (style) {\n      case 'lowercase': return '.nan';\n      case 'uppercase': return '.NAN';\n      case 'camelcase': return '.NaN';\n    }\n  } else if (Number.POSITIVE_INFINITY === object) {\n    switch (style) {\n      case 'lowercase': return '.inf';\n      case 'uppercase': return '.INF';\n      case 'camelcase': return '.Inf';\n    }\n  } else if (Number.NEGATIVE_INFINITY === object) {\n    switch (style) {\n      case 'lowercase': return '-.inf';\n      case 'uppercase': return '-.INF';\n      case 'camelcase': return '-.Inf';\n    }\n  } else if (common.isNegativeZero(object)) {\n    return '-0.0';\n  }\n\n  res = object.toString(10);\n\n  // JS stringifier can build scientific format without dots: 5e-100,\n  // while YAML requres dot: 5.e-100. Fix it with simple hack\n\n  return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace('e', '.e') : res;\n}\n\nfunction isFloat(object) {\n  return (Object.prototype.toString.call(object) === '[object Number]') &&\n         (object % 1 !== 0 || common.isNegativeZero(object));\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:float', {\n  kind: 'scalar',\n  resolve: resolveYamlFloat,\n  construct: constructYamlFloat,\n  predicate: isFloat,\n  represent: representYamlFloat,\n  defaultStyle: 'lowercase'\n});\n","// Standard YAML's JSON schema.\n// http://www.yaml.org/spec/1.2/spec.html#id2803231\n//\n// NOTE: JS-YAML does not support schema-specific tag resolution restrictions.\n// So, this schema is not such strict as defined in the YAML specification.\n// It allows numbers in binary notaion, use `Null` and `NULL` as `null`, etc.\n\n\n'use strict';\n\n\nvar Schema = require('../schema');\n\n\nmodule.exports = new Schema({\n  include: [\n    require('./failsafe')\n  ],\n  implicit: [\n    require('../type/null'),\n    require('../type/bool'),\n    require('../type/int'),\n    require('../type/float')\n  ]\n});\n","// Standard YAML's Core schema.\n// http://www.yaml.org/spec/1.2/spec.html#id2804923\n//\n// NOTE: JS-YAML does not support schema-specific tag resolution restrictions.\n// So, Core schema has no distinctions from JSON schema is JS-YAML.\n\n\n'use strict';\n\n\nvar Schema = require('../schema');\n\n\nmodule.exports = new Schema({\n  include: [\n    require('./json')\n  ]\n});\n","'use strict';\n\nvar Type = require('../type');\n\nvar YAML_DATE_REGEXP = new RegExp(\n  '^([0-9][0-9][0-9][0-9])'          + // [1] year\n  '-([0-9][0-9])'                    + // [2] month\n  '-([0-9][0-9])$');                   // [3] day\n\nvar YAML_TIMESTAMP_REGEXP = new RegExp(\n  '^([0-9][0-9][0-9][0-9])'          + // [1] year\n  '-([0-9][0-9]?)'                   + // [2] month\n  '-([0-9][0-9]?)'                   + // [3] day\n  '(?:[Tt]|[ \\\\t]+)'                 + // ...\n  '([0-9][0-9]?)'                    + // [4] hour\n  ':([0-9][0-9])'                    + // [5] minute\n  ':([0-9][0-9])'                    + // [6] second\n  '(?:\\\\.([0-9]*))?'                 + // [7] fraction\n  '(?:[ \\\\t]*(Z|([-+])([0-9][0-9]?)' + // [8] tz [9] tz_sign [10] tz_hour\n  '(?::([0-9][0-9]))?))?$');           // [11] tz_minute\n\nfunction resolveYamlTimestamp(data) {\n  if (data === null) return false;\n  if (YAML_DATE_REGEXP.exec(data) !== null) return true;\n  if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;\n  return false;\n}\n\nfunction constructYamlTimestamp(data) {\n  var match, year, month, day, hour, minute, second, fraction = 0,\n      delta = null, tz_hour, tz_minute, date;\n\n  match = YAML_DATE_REGEXP.exec(data);\n  if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);\n\n  if (match === null) throw new Error('Date resolve error');\n\n  // match: [1] year [2] month [3] day\n\n  year = +(match[1]);\n  month = +(match[2]) - 1; // JS month starts with 0\n  day = +(match[3]);\n\n  if (!match[4]) { // no hour\n    return new Date(Date.UTC(year, month, day));\n  }\n\n  // match: [4] hour [5] minute [6] second [7] fraction\n\n  hour = +(match[4]);\n  minute = +(match[5]);\n  second = +(match[6]);\n\n  if (match[7]) {\n    fraction = match[7].slice(0, 3);\n    while (fraction.length < 3) { // milli-seconds\n      fraction += '0';\n    }\n    fraction = +fraction;\n  }\n\n  // match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute\n\n  if (match[9]) {\n    tz_hour = +(match[10]);\n    tz_minute = +(match[11] || 0);\n    delta = (tz_hour * 60 + tz_minute) * 60000; // delta in mili-seconds\n    if (match[9] === '-') delta = -delta;\n  }\n\n  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));\n\n  if (delta) date.setTime(date.getTime() - delta);\n\n  return date;\n}\n\nfunction representYamlTimestamp(object /*, style*/) {\n  return object.toISOString();\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:timestamp', {\n  kind: 'scalar',\n  resolve: resolveYamlTimestamp,\n  construct: constructYamlTimestamp,\n  instanceOf: Date,\n  represent: representYamlTimestamp\n});\n","'use strict';\n\nvar Type = require('../type');\n\nfunction resolveYamlMerge(data) {\n  return data === '<<' || data === null;\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:merge', {\n  kind: 'scalar',\n  resolve: resolveYamlMerge\n});\n","'use strict';\n\n/*eslint-disable no-bitwise*/\n\nvar NodeBuffer;\n\ntry {\n  // A trick for browserified version, to not include `Buffer` shim\n  var _require = require;\n  NodeBuffer = _require('buffer').Buffer;\n} catch (__) {}\n\nvar Type       = require('../type');\n\n\n// [ 64, 65, 66 ] -> [ padding, CR, LF ]\nvar BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\\n\\r';\n\n\nfunction resolveYamlBinary(data) {\n  if (data === null) return false;\n\n  var code, idx, bitlen = 0, max = data.length, map = BASE64_MAP;\n\n  // Convert one by one.\n  for (idx = 0; idx < max; idx++) {\n    code = map.indexOf(data.charAt(idx));\n\n    // Skip CR/LF\n    if (code > 64) continue;\n\n    // Fail on illegal characters\n    if (code < 0) return false;\n\n    bitlen += 6;\n  }\n\n  // If there are any bits left, source was corrupted\n  return (bitlen % 8) === 0;\n}\n\nfunction constructYamlBinary(data) {\n  var idx, tailbits,\n      input = data.replace(/[\\r\\n=]/g, ''), // remove CR/LF & padding to simplify scan\n      max = input.length,\n      map = BASE64_MAP,\n      bits = 0,\n      result = [];\n\n  // Collect by 6*4 bits (3 bytes)\n\n  for (idx = 0; idx < max; idx++) {\n    if ((idx % 4 === 0) && idx) {\n      result.push((bits >> 16) & 0xFF);\n      result.push((bits >> 8) & 0xFF);\n      result.push(bits & 0xFF);\n    }\n\n    bits = (bits << 6) | map.indexOf(input.charAt(idx));\n  }\n\n  // Dump tail\n\n  tailbits = (max % 4) * 6;\n\n  if (tailbits === 0) {\n    result.push((bits >> 16) & 0xFF);\n    result.push((bits >> 8) & 0xFF);\n    result.push(bits & 0xFF);\n  } else if (tailbits === 18) {\n    result.push((bits >> 10) & 0xFF);\n    result.push((bits >> 2) & 0xFF);\n  } else if (tailbits === 12) {\n    result.push((bits >> 4) & 0xFF);\n  }\n\n  // Wrap into Buffer for NodeJS and leave Array for browser\n  if (NodeBuffer) {\n    // Support node 6.+ Buffer API when available\n    return NodeBuffer.from ? NodeBuffer.from(result) : new NodeBuffer(result);\n  }\n\n  return result;\n}\n\nfunction representYamlBinary(object /*, style*/) {\n  var result = '', bits = 0, idx, tail,\n      max = object.length,\n      map = BASE64_MAP;\n\n  // Convert every three bytes to 4 ASCII characters.\n\n  for (idx = 0; idx < max; idx++) {\n    if ((idx % 3 === 0) && idx) {\n      result += map[(bits >> 18) & 0x3F];\n      result += map[(bits >> 12) & 0x3F];\n      result += map[(bits >> 6) & 0x3F];\n      result += map[bits & 0x3F];\n    }\n\n    bits = (bits << 8) + object[idx];\n  }\n\n  // Dump tail\n\n  tail = max % 3;\n\n  if (tail === 0) {\n    result += map[(bits >> 18) & 0x3F];\n    result += map[(bits >> 12) & 0x3F];\n    result += map[(bits >> 6) & 0x3F];\n    result += map[bits & 0x3F];\n  } else if (tail === 2) {\n    result += map[(bits >> 10) & 0x3F];\n    result += map[(bits >> 4) & 0x3F];\n    result += map[(bits << 2) & 0x3F];\n    result += map[64];\n  } else if (tail === 1) {\n    result += map[(bits >> 2) & 0x3F];\n    result += map[(bits << 4) & 0x3F];\n    result += map[64];\n    result += map[64];\n  }\n\n  return result;\n}\n\nfunction isBinary(object) {\n  return NodeBuffer && NodeBuffer.isBuffer(object);\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:binary', {\n  kind: 'scalar',\n  resolve: resolveYamlBinary,\n  construct: constructYamlBinary,\n  predicate: isBinary,\n  represent: representYamlBinary\n});\n","'use strict';\n\nvar Type = require('../type');\n\nvar _hasOwnProperty = Object.prototype.hasOwnProperty;\nvar _toString       = Object.prototype.toString;\n\nfunction resolveYamlOmap(data) {\n  if (data === null) return true;\n\n  var objectKeys = [], index, length, pair, pairKey, pairHasKey,\n      object = data;\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    pair = object[index];\n    pairHasKey = false;\n\n    if (_toString.call(pair) !== '[object Object]') return false;\n\n    for (pairKey in pair) {\n      if (_hasOwnProperty.call(pair, pairKey)) {\n        if (!pairHasKey) pairHasKey = true;\n        else return false;\n      }\n    }\n\n    if (!pairHasKey) return false;\n\n    if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);\n    else return false;\n  }\n\n  return true;\n}\n\nfunction constructYamlOmap(data) {\n  return data !== null ? data : [];\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:omap', {\n  kind: 'sequence',\n  resolve: resolveYamlOmap,\n  construct: constructYamlOmap\n});\n","'use strict';\n\nvar Type = require('../type');\n\nvar _toString = Object.prototype.toString;\n\nfunction resolveYamlPairs(data) {\n  if (data === null) return true;\n\n  var index, length, pair, keys, result,\n      object = data;\n\n  result = new Array(object.length);\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    pair = object[index];\n\n    if (_toString.call(pair) !== '[object Object]') return false;\n\n    keys = Object.keys(pair);\n\n    if (keys.length !== 1) return false;\n\n    result[index] = [ keys[0], pair[keys[0]] ];\n  }\n\n  return true;\n}\n\nfunction constructYamlPairs(data) {\n  if (data === null) return [];\n\n  var index, length, pair, keys, result,\n      object = data;\n\n  result = new Array(object.length);\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    pair = object[index];\n\n    keys = Object.keys(pair);\n\n    result[index] = [ keys[0], pair[keys[0]] ];\n  }\n\n  return result;\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:pairs', {\n  kind: 'sequence',\n  resolve: resolveYamlPairs,\n  construct: constructYamlPairs\n});\n","'use strict';\n\nvar Type = require('../type');\n\nvar _hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction resolveYamlSet(data) {\n  if (data === null) return true;\n\n  var key, object = data;\n\n  for (key in object) {\n    if (_hasOwnProperty.call(object, key)) {\n      if (object[key] !== null) return false;\n    }\n  }\n\n  return true;\n}\n\nfunction constructYamlSet(data) {\n  return data !== null ? data : {};\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:set', {\n  kind: 'mapping',\n  resolve: resolveYamlSet,\n  construct: constructYamlSet\n});\n","// JS-YAML's default schema for `safeLoad` function.\n// It is not described in the YAML specification.\n//\n// This schema is based on standard YAML's Core schema and includes most of\n// extra types described at YAML tag repository. (http://yaml.org/type/)\n\n\n'use strict';\n\n\nvar Schema = require('../schema');\n\n\nmodule.exports = new Schema({\n  include: [\n    require('./core')\n  ],\n  implicit: [\n    require('../type/timestamp'),\n    require('../type/merge')\n  ],\n  explicit: [\n    require('../type/binary'),\n    require('../type/omap'),\n    require('../type/pairs'),\n    require('../type/set')\n  ]\n});\n","'use strict';\n\nvar Type = require('../../type');\n\nfunction resolveJavascriptUndefined() {\n  return true;\n}\n\nfunction constructJavascriptUndefined() {\n  /*eslint-disable no-undefined*/\n  return undefined;\n}\n\nfunction representJavascriptUndefined() {\n  return '';\n}\n\nfunction isUndefined(object) {\n  return typeof object === 'undefined';\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:js/undefined', {\n  kind: 'scalar',\n  resolve: resolveJavascriptUndefined,\n  construct: constructJavascriptUndefined,\n  predicate: isUndefined,\n  represent: representJavascriptUndefined\n});\n","'use strict';\n\nvar Type = require('../../type');\n\nfunction resolveJavascriptRegExp(data) {\n  if (data === null) return false;\n  if (data.length === 0) return false;\n\n  var regexp = data,\n      tail   = /\\/([gim]*)$/.exec(data),\n      modifiers = '';\n\n  // if regexp starts with '/' it can have modifiers and must be properly closed\n  // `/foo/gim` - modifiers tail can be maximum 3 chars\n  if (regexp[0] === '/') {\n    if (tail) modifiers = tail[1];\n\n    if (modifiers.length > 3) return false;\n    // if expression starts with /, is should be properly terminated\n    if (regexp[regexp.length - modifiers.length - 1] !== '/') return false;\n  }\n\n  return true;\n}\n\nfunction constructJavascriptRegExp(data) {\n  var regexp = data,\n      tail   = /\\/([gim]*)$/.exec(data),\n      modifiers = '';\n\n  // `/foo/gim` - tail can be maximum 4 chars\n  if (regexp[0] === '/') {\n    if (tail) modifiers = tail[1];\n    regexp = regexp.slice(1, regexp.length - modifiers.length - 1);\n  }\n\n  return new RegExp(regexp, modifiers);\n}\n\nfunction representJavascriptRegExp(object /*, style*/) {\n  var result = '/' + object.source + '/';\n\n  if (object.global) result += 'g';\n  if (object.multiline) result += 'm';\n  if (object.ignoreCase) result += 'i';\n\n  return result;\n}\n\nfunction isRegExp(object) {\n  return Object.prototype.toString.call(object) === '[object RegExp]';\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:js/regexp', {\n  kind: 'scalar',\n  resolve: resolveJavascriptRegExp,\n  construct: constructJavascriptRegExp,\n  predicate: isRegExp,\n  represent: representJavascriptRegExp\n});\n","'use strict';\n\nvar esprima;\n\n// Browserified version does not have esprima\n//\n// 1. For node.js just require module as deps\n// 2. For browser try to require mudule via external AMD system.\n//    If not found - try to fallback to window.esprima. If not\n//    found too - then fail to parse.\n//\ntry {\n  // workaround to exclude package from browserify list.\n  var _require = require;\n  esprima = _require('esprima');\n} catch (_) {\n  /*global window */\n  if (typeof window !== 'undefined') esprima = window.esprima;\n}\n\nvar Type = require('../../type');\n\nfunction resolveJavascriptFunction(data) {\n  if (data === null) return false;\n\n  try {\n    var source = '(' + data + ')',\n        ast    = esprima.parse(source, { range: true });\n\n    if (ast.type                    !== 'Program'             ||\n        ast.body.length             !== 1                     ||\n        ast.body[0].type            !== 'ExpressionStatement' ||\n        (ast.body[0].expression.type !== 'ArrowFunctionExpression' &&\n          ast.body[0].expression.type !== 'FunctionExpression')) {\n      return false;\n    }\n\n    return true;\n  } catch (err) {\n    return false;\n  }\n}\n\nfunction constructJavascriptFunction(data) {\n  /*jslint evil:true*/\n\n  var source = '(' + data + ')',\n      ast    = esprima.parse(source, { range: true }),\n      params = [],\n      body;\n\n  if (ast.type                    !== 'Program'             ||\n      ast.body.length             !== 1                     ||\n      ast.body[0].type            !== 'ExpressionStatement' ||\n      (ast.body[0].expression.type !== 'ArrowFunctionExpression' &&\n        ast.body[0].expression.type !== 'FunctionExpression')) {\n    throw new Error('Failed to resolve function');\n  }\n\n  ast.body[0].expression.params.forEach(function (param) {\n    params.push(param.name);\n  });\n\n  body = ast.body[0].expression.body.range;\n\n  // Esprima's ranges include the first '{' and the last '}' characters on\n  // function expressions. So cut them out.\n  if (ast.body[0].expression.body.type === 'BlockStatement') {\n    /*eslint-disable no-new-func*/\n    return new Function(params, source.slice(body[0] + 1, body[1] - 1));\n  }\n  // ES6 arrow functions can omit the BlockStatement. In that case, just return\n  // the body.\n  /*eslint-disable no-new-func*/\n  return new Function(params, 'return ' + source.slice(body[0], body[1]));\n}\n\nfunction representJavascriptFunction(object /*, style*/) {\n  return object.toString();\n}\n\nfunction isFunction(object) {\n  return Object.prototype.toString.call(object) === '[object Function]';\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:js/function', {\n  kind: 'scalar',\n  resolve: resolveJavascriptFunction,\n  construct: constructJavascriptFunction,\n  predicate: isFunction,\n  represent: representJavascriptFunction\n});\n","// JS-YAML's default schema for `load` function.\n// It is not described in the YAML specification.\n//\n// This schema is based on JS-YAML's default safe schema and includes\n// JavaScript-specific types: !!js/undefined, !!js/regexp and !!js/function.\n//\n// Also this schema is used as default base schema at `Schema.create` function.\n\n\n'use strict';\n\n\nvar Schema = require('../schema');\n\n\nmodule.exports = Schema.DEFAULT = new Schema({\n  include: [\n    require('./default_safe')\n  ],\n  explicit: [\n    require('../type/js/undefined'),\n    require('../type/js/regexp'),\n    require('../type/js/function')\n  ]\n});\n","'use strict';\n\n/*eslint-disable max-len,no-use-before-define*/\n\nvar common              = require('./common');\nvar YAMLException       = require('./exception');\nvar Mark                = require('./mark');\nvar DEFAULT_SAFE_SCHEMA = require('./schema/default_safe');\nvar DEFAULT_FULL_SCHEMA = require('./schema/default_full');\n\n\nvar _hasOwnProperty = Object.prototype.hasOwnProperty;\n\n\nvar CONTEXT_FLOW_IN   = 1;\nvar CONTEXT_FLOW_OUT  = 2;\nvar CONTEXT_BLOCK_IN  = 3;\nvar CONTEXT_BLOCK_OUT = 4;\n\n\nvar CHOMPING_CLIP  = 1;\nvar CHOMPING_STRIP = 2;\nvar CHOMPING_KEEP  = 3;\n\n\nvar PATTERN_NON_PRINTABLE         = /[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F-\\x84\\x86-\\x9F\\uFFFE\\uFFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]/;\nvar PATTERN_NON_ASCII_LINE_BREAKS = /[\\x85\\u2028\\u2029]/;\nvar PATTERN_FLOW_INDICATORS       = /[,\\[\\]\\{\\}]/;\nvar PATTERN_TAG_HANDLE            = /^(?:!|!!|![a-z\\-]+!)$/i;\nvar PATTERN_TAG_URI               = /^(?:!|[^,\\[\\]\\{\\}])(?:%[0-9a-f]{2}|[0-9a-z\\-#;\\/\\?:@&=\\+\\$,_\\.!~\\*'\\(\\)\\[\\]])*$/i;\n\n\nfunction _class(obj) { return Object.prototype.toString.call(obj); }\n\nfunction is_EOL(c) {\n  return (c === 0x0A/* LF */) || (c === 0x0D/* CR */);\n}\n\nfunction is_WHITE_SPACE(c) {\n  return (c === 0x09/* Tab */) || (c === 0x20/* Space */);\n}\n\nfunction is_WS_OR_EOL(c) {\n  return (c === 0x09/* Tab */) ||\n         (c === 0x20/* Space */) ||\n         (c === 0x0A/* LF */) ||\n         (c === 0x0D/* CR */);\n}\n\nfunction is_FLOW_INDICATOR(c) {\n  return c === 0x2C/* , */ ||\n         c === 0x5B/* [ */ ||\n         c === 0x5D/* ] */ ||\n         c === 0x7B/* { */ ||\n         c === 0x7D/* } */;\n}\n\nfunction fromHexCode(c) {\n  var lc;\n\n  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {\n    return c - 0x30;\n  }\n\n  /*eslint-disable no-bitwise*/\n  lc = c | 0x20;\n\n  if ((0x61/* a */ <= lc) && (lc <= 0x66/* f */)) {\n    return lc - 0x61 + 10;\n  }\n\n  return -1;\n}\n\nfunction escapedHexLen(c) {\n  if (c === 0x78/* x */) { return 2; }\n  if (c === 0x75/* u */) { return 4; }\n  if (c === 0x55/* U */) { return 8; }\n  return 0;\n}\n\nfunction fromDecimalCode(c) {\n  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {\n    return c - 0x30;\n  }\n\n  return -1;\n}\n\nfunction simpleEscapeSequence(c) {\n  /* eslint-disable indent */\n  return (c === 0x30/* 0 */) ? '\\x00' :\n        (c === 0x61/* a */) ? '\\x07' :\n        (c === 0x62/* b */) ? '\\x08' :\n        (c === 0x74/* t */) ? '\\x09' :\n        (c === 0x09/* Tab */) ? '\\x09' :\n        (c === 0x6E/* n */) ? '\\x0A' :\n        (c === 0x76/* v */) ? '\\x0B' :\n        (c === 0x66/* f */) ? '\\x0C' :\n        (c === 0x72/* r */) ? '\\x0D' :\n        (c === 0x65/* e */) ? '\\x1B' :\n        (c === 0x20/* Space */) ? ' ' :\n        (c === 0x22/* \" */) ? '\\x22' :\n        (c === 0x2F/* / */) ? '/' :\n        (c === 0x5C/* \\ */) ? '\\x5C' :\n        (c === 0x4E/* N */) ? '\\x85' :\n        (c === 0x5F/* _ */) ? '\\xA0' :\n        (c === 0x4C/* L */) ? '\\u2028' :\n        (c === 0x50/* P */) ? '\\u2029' : '';\n}\n\nfunction charFromCodepoint(c) {\n  if (c <= 0xFFFF) {\n    return String.fromCharCode(c);\n  }\n  // Encode UTF-16 surrogate pair\n  // https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF\n  return String.fromCharCode(\n    ((c - 0x010000) >> 10) + 0xD800,\n    ((c - 0x010000) & 0x03FF) + 0xDC00\n  );\n}\n\nvar simpleEscapeCheck = new Array(256); // integer, for fast access\nvar simpleEscapeMap = new Array(256);\nfor (var i = 0; i < 256; i++) {\n  simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;\n  simpleEscapeMap[i] = simpleEscapeSequence(i);\n}\n\n\nfunction State(input, options) {\n  this.input = input;\n\n  this.filename  = options['filename']  || null;\n  this.schema    = options['schema']    || DEFAULT_FULL_SCHEMA;\n  this.onWarning = options['onWarning'] || null;\n  this.legacy    = options['legacy']    || false;\n  this.json      = options['json']      || false;\n  this.listener  = options['listener']  || null;\n\n  this.implicitTypes = this.schema.compiledImplicit;\n  this.typeMap       = this.schema.compiledTypeMap;\n\n  this.length     = input.length;\n  this.position   = 0;\n  this.line       = 0;\n  this.lineStart  = 0;\n  this.lineIndent = 0;\n\n  this.documents = [];\n\n  /*\n  this.version;\n  this.checkLineBreaks;\n  this.tagMap;\n  this.anchorMap;\n  this.tag;\n  this.anchor;\n  this.kind;\n  this.result;*/\n\n}\n\n\nfunction generateError(state, message) {\n  return new YAMLException(\n    message,\n    new Mark(state.filename, state.input, state.position, state.line, (state.position - state.lineStart)));\n}\n\nfunction throwError(state, message) {\n  throw generateError(state, message);\n}\n\nfunction throwWarning(state, message) {\n  if (state.onWarning) {\n    state.onWarning.call(null, generateError(state, message));\n  }\n}\n\n\nvar directiveHandlers = {\n\n  YAML: function handleYamlDirective(state, name, args) {\n\n    var match, major, minor;\n\n    if (state.version !== null) {\n      throwError(state, 'duplication of %YAML directive');\n    }\n\n    if (args.length !== 1) {\n      throwError(state, 'YAML directive accepts exactly one argument');\n    }\n\n    match = /^([0-9]+)\\.([0-9]+)$/.exec(args[0]);\n\n    if (match === null) {\n      throwError(state, 'ill-formed argument of the YAML directive');\n    }\n\n    major = parseInt(match[1], 10);\n    minor = parseInt(match[2], 10);\n\n    if (major !== 1) {\n      throwError(state, 'unacceptable YAML version of the document');\n    }\n\n    state.version = args[0];\n    state.checkLineBreaks = (minor < 2);\n\n    if (minor !== 1 && minor !== 2) {\n      throwWarning(state, 'unsupported YAML version of the document');\n    }\n  },\n\n  TAG: function handleTagDirective(state, name, args) {\n\n    var handle, prefix;\n\n    if (args.length !== 2) {\n      throwError(state, 'TAG directive accepts exactly two arguments');\n    }\n\n    handle = args[0];\n    prefix = args[1];\n\n    if (!PATTERN_TAG_HANDLE.test(handle)) {\n      throwError(state, 'ill-formed tag handle (first argument) of the TAG directive');\n    }\n\n    if (_hasOwnProperty.call(state.tagMap, handle)) {\n      throwError(state, 'there is a previously declared suffix for \"' + handle + '\" tag handle');\n    }\n\n    if (!PATTERN_TAG_URI.test(prefix)) {\n      throwError(state, 'ill-formed tag prefix (second argument) of the TAG directive');\n    }\n\n    state.tagMap[handle] = prefix;\n  }\n};\n\n\nfunction captureSegment(state, start, end, checkJson) {\n  var _position, _length, _character, _result;\n\n  if (start < end) {\n    _result = state.input.slice(start, end);\n\n    if (checkJson) {\n      for (_position = 0, _length = _result.length; _position < _length; _position += 1) {\n        _character = _result.charCodeAt(_position);\n        if (!(_character === 0x09 ||\n              (0x20 <= _character && _character <= 0x10FFFF))) {\n          throwError(state, 'expected valid JSON character');\n        }\n      }\n    } else if (PATTERN_NON_PRINTABLE.test(_result)) {\n      throwError(state, 'the stream contains non-printable characters');\n    }\n\n    state.result += _result;\n  }\n}\n\nfunction mergeMappings(state, destination, source, overridableKeys) {\n  var sourceKeys, key, index, quantity;\n\n  if (!common.isObject(source)) {\n    throwError(state, 'cannot merge mappings; the provided source object is unacceptable');\n  }\n\n  sourceKeys = Object.keys(source);\n\n  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {\n    key = sourceKeys[index];\n\n    if (!_hasOwnProperty.call(destination, key)) {\n      destination[key] = source[key];\n      overridableKeys[key] = true;\n    }\n  }\n}\n\nfunction storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startPos) {\n  var index, quantity;\n\n  // The output is a plain object here, so keys can only be strings.\n  // We need to convert keyNode to a string, but doing so can hang the process\n  // (deeply nested arrays that explode exponentially using aliases).\n  if (Array.isArray(keyNode)) {\n    keyNode = Array.prototype.slice.call(keyNode);\n\n    for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {\n      if (Array.isArray(keyNode[index])) {\n        throwError(state, 'nested arrays are not supported inside keys');\n      }\n\n      if (typeof keyNode === 'object' && _class(keyNode[index]) === '[object Object]') {\n        keyNode[index] = '[object Object]';\n      }\n    }\n  }\n\n  // Avoid code execution in load() via toString property\n  // (still use its own toString for arrays, timestamps,\n  // and whatever user schema extensions happen to have @@toStringTag)\n  if (typeof keyNode === 'object' && _class(keyNode) === '[object Object]') {\n    keyNode = '[object Object]';\n  }\n\n\n  keyNode = String(keyNode);\n\n  if (_result === null) {\n    _result = {};\n  }\n\n  if (keyTag === 'tag:yaml.org,2002:merge') {\n    if (Array.isArray(valueNode)) {\n      for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {\n        mergeMappings(state, _result, valueNode[index], overridableKeys);\n      }\n    } else {\n      mergeMappings(state, _result, valueNode, overridableKeys);\n    }\n  } else {\n    if (!state.json &&\n        !_hasOwnProperty.call(overridableKeys, keyNode) &&\n        _hasOwnProperty.call(_result, keyNode)) {\n      state.line = startLine || state.line;\n      state.position = startPos || state.position;\n      throwError(state, 'duplicated mapping key');\n    }\n    _result[keyNode] = valueNode;\n    delete overridableKeys[keyNode];\n  }\n\n  return _result;\n}\n\nfunction readLineBreak(state) {\n  var ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch === 0x0A/* LF */) {\n    state.position++;\n  } else if (ch === 0x0D/* CR */) {\n    state.position++;\n    if (state.input.charCodeAt(state.position) === 0x0A/* LF */) {\n      state.position++;\n    }\n  } else {\n    throwError(state, 'a line break is expected');\n  }\n\n  state.line += 1;\n  state.lineStart = state.position;\n}\n\nfunction skipSeparationSpace(state, allowComments, checkIndent) {\n  var lineBreaks = 0,\n      ch = state.input.charCodeAt(state.position);\n\n  while (ch !== 0) {\n    while (is_WHITE_SPACE(ch)) {\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    if (allowComments && ch === 0x23/* # */) {\n      do {\n        ch = state.input.charCodeAt(++state.position);\n      } while (ch !== 0x0A/* LF */ && ch !== 0x0D/* CR */ && ch !== 0);\n    }\n\n    if (is_EOL(ch)) {\n      readLineBreak(state);\n\n      ch = state.input.charCodeAt(state.position);\n      lineBreaks++;\n      state.lineIndent = 0;\n\n      while (ch === 0x20/* Space */) {\n        state.lineIndent++;\n        ch = state.input.charCodeAt(++state.position);\n      }\n    } else {\n      break;\n    }\n  }\n\n  if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {\n    throwWarning(state, 'deficient indentation');\n  }\n\n  return lineBreaks;\n}\n\nfunction testDocumentSeparator(state) {\n  var _position = state.position,\n      ch;\n\n  ch = state.input.charCodeAt(_position);\n\n  // Condition state.position === state.lineStart is tested\n  // in parent on each call, for efficiency. No needs to test here again.\n  if ((ch === 0x2D/* - */ || ch === 0x2E/* . */) &&\n      ch === state.input.charCodeAt(_position + 1) &&\n      ch === state.input.charCodeAt(_position + 2)) {\n\n    _position += 3;\n\n    ch = state.input.charCodeAt(_position);\n\n    if (ch === 0 || is_WS_OR_EOL(ch)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction writeFoldedLines(state, count) {\n  if (count === 1) {\n    state.result += ' ';\n  } else if (count > 1) {\n    state.result += common.repeat('\\n', count - 1);\n  }\n}\n\n\nfunction readPlainScalar(state, nodeIndent, withinFlowCollection) {\n  var preceding,\n      following,\n      captureStart,\n      captureEnd,\n      hasPendingContent,\n      _line,\n      _lineStart,\n      _lineIndent,\n      _kind = state.kind,\n      _result = state.result,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (is_WS_OR_EOL(ch)      ||\n      is_FLOW_INDICATOR(ch) ||\n      ch === 0x23/* # */    ||\n      ch === 0x26/* & */    ||\n      ch === 0x2A/* * */    ||\n      ch === 0x21/* ! */    ||\n      ch === 0x7C/* | */    ||\n      ch === 0x3E/* > */    ||\n      ch === 0x27/* ' */    ||\n      ch === 0x22/* \" */    ||\n      ch === 0x25/* % */    ||\n      ch === 0x40/* @ */    ||\n      ch === 0x60/* ` */) {\n    return false;\n  }\n\n  if (ch === 0x3F/* ? */ || ch === 0x2D/* - */) {\n    following = state.input.charCodeAt(state.position + 1);\n\n    if (is_WS_OR_EOL(following) ||\n        withinFlowCollection && is_FLOW_INDICATOR(following)) {\n      return false;\n    }\n  }\n\n  state.kind = 'scalar';\n  state.result = '';\n  captureStart = captureEnd = state.position;\n  hasPendingContent = false;\n\n  while (ch !== 0) {\n    if (ch === 0x3A/* : */) {\n      following = state.input.charCodeAt(state.position + 1);\n\n      if (is_WS_OR_EOL(following) ||\n          withinFlowCollection && is_FLOW_INDICATOR(following)) {\n        break;\n      }\n\n    } else if (ch === 0x23/* # */) {\n      preceding = state.input.charCodeAt(state.position - 1);\n\n      if (is_WS_OR_EOL(preceding)) {\n        break;\n      }\n\n    } else if ((state.position === state.lineStart && testDocumentSeparator(state)) ||\n               withinFlowCollection && is_FLOW_INDICATOR(ch)) {\n      break;\n\n    } else if (is_EOL(ch)) {\n      _line = state.line;\n      _lineStart = state.lineStart;\n      _lineIndent = state.lineIndent;\n      skipSeparationSpace(state, false, -1);\n\n      if (state.lineIndent >= nodeIndent) {\n        hasPendingContent = true;\n        ch = state.input.charCodeAt(state.position);\n        continue;\n      } else {\n        state.position = captureEnd;\n        state.line = _line;\n        state.lineStart = _lineStart;\n        state.lineIndent = _lineIndent;\n        break;\n      }\n    }\n\n    if (hasPendingContent) {\n      captureSegment(state, captureStart, captureEnd, false);\n      writeFoldedLines(state, state.line - _line);\n      captureStart = captureEnd = state.position;\n      hasPendingContent = false;\n    }\n\n    if (!is_WHITE_SPACE(ch)) {\n      captureEnd = state.position + 1;\n    }\n\n    ch = state.input.charCodeAt(++state.position);\n  }\n\n  captureSegment(state, captureStart, captureEnd, false);\n\n  if (state.result) {\n    return true;\n  }\n\n  state.kind = _kind;\n  state.result = _result;\n  return false;\n}\n\nfunction readSingleQuotedScalar(state, nodeIndent) {\n  var ch,\n      captureStart, captureEnd;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch !== 0x27/* ' */) {\n    return false;\n  }\n\n  state.kind = 'scalar';\n  state.result = '';\n  state.position++;\n  captureStart = captureEnd = state.position;\n\n  while ((ch = state.input.charCodeAt(state.position)) !== 0) {\n    if (ch === 0x27/* ' */) {\n      captureSegment(state, captureStart, state.position, true);\n      ch = state.input.charCodeAt(++state.position);\n\n      if (ch === 0x27/* ' */) {\n        captureStart = state.position;\n        state.position++;\n        captureEnd = state.position;\n      } else {\n        return true;\n      }\n\n    } else if (is_EOL(ch)) {\n      captureSegment(state, captureStart, captureEnd, true);\n      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));\n      captureStart = captureEnd = state.position;\n\n    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {\n      throwError(state, 'unexpected end of the document within a single quoted scalar');\n\n    } else {\n      state.position++;\n      captureEnd = state.position;\n    }\n  }\n\n  throwError(state, 'unexpected end of the stream within a single quoted scalar');\n}\n\nfunction readDoubleQuotedScalar(state, nodeIndent) {\n  var captureStart,\n      captureEnd,\n      hexLength,\n      hexResult,\n      tmp,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch !== 0x22/* \" */) {\n    return false;\n  }\n\n  state.kind = 'scalar';\n  state.result = '';\n  state.position++;\n  captureStart = captureEnd = state.position;\n\n  while ((ch = state.input.charCodeAt(state.position)) !== 0) {\n    if (ch === 0x22/* \" */) {\n      captureSegment(state, captureStart, state.position, true);\n      state.position++;\n      return true;\n\n    } else if (ch === 0x5C/* \\ */) {\n      captureSegment(state, captureStart, state.position, true);\n      ch = state.input.charCodeAt(++state.position);\n\n      if (is_EOL(ch)) {\n        skipSeparationSpace(state, false, nodeIndent);\n\n        // TODO: rework to inline fn with no type cast?\n      } else if (ch < 256 && simpleEscapeCheck[ch]) {\n        state.result += simpleEscapeMap[ch];\n        state.position++;\n\n      } else if ((tmp = escapedHexLen(ch)) > 0) {\n        hexLength = tmp;\n        hexResult = 0;\n\n        for (; hexLength > 0; hexLength--) {\n          ch = state.input.charCodeAt(++state.position);\n\n          if ((tmp = fromHexCode(ch)) >= 0) {\n            hexResult = (hexResult << 4) + tmp;\n\n          } else {\n            throwError(state, 'expected hexadecimal character');\n          }\n        }\n\n        state.result += charFromCodepoint(hexResult);\n\n        state.position++;\n\n      } else {\n        throwError(state, 'unknown escape sequence');\n      }\n\n      captureStart = captureEnd = state.position;\n\n    } else if (is_EOL(ch)) {\n      captureSegment(state, captureStart, captureEnd, true);\n      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));\n      captureStart = captureEnd = state.position;\n\n    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {\n      throwError(state, 'unexpected end of the document within a double quoted scalar');\n\n    } else {\n      state.position++;\n      captureEnd = state.position;\n    }\n  }\n\n  throwError(state, 'unexpected end of the stream within a double quoted scalar');\n}\n\nfunction readFlowCollection(state, nodeIndent) {\n  var readNext = true,\n      _line,\n      _tag     = state.tag,\n      _result,\n      _anchor  = state.anchor,\n      following,\n      terminator,\n      isPair,\n      isExplicitPair,\n      isMapping,\n      overridableKeys = {},\n      keyNode,\n      keyTag,\n      valueNode,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch === 0x5B/* [ */) {\n    terminator = 0x5D;/* ] */\n    isMapping = false;\n    _result = [];\n  } else if (ch === 0x7B/* { */) {\n    terminator = 0x7D;/* } */\n    isMapping = true;\n    _result = {};\n  } else {\n    return false;\n  }\n\n  if (state.anchor !== null) {\n    state.anchorMap[state.anchor] = _result;\n  }\n\n  ch = state.input.charCodeAt(++state.position);\n\n  while (ch !== 0) {\n    skipSeparationSpace(state, true, nodeIndent);\n\n    ch = state.input.charCodeAt(state.position);\n\n    if (ch === terminator) {\n      state.position++;\n      state.tag = _tag;\n      state.anchor = _anchor;\n      state.kind = isMapping ? 'mapping' : 'sequence';\n      state.result = _result;\n      return true;\n    } else if (!readNext) {\n      throwError(state, 'missed comma between flow collection entries');\n    }\n\n    keyTag = keyNode = valueNode = null;\n    isPair = isExplicitPair = false;\n\n    if (ch === 0x3F/* ? */) {\n      following = state.input.charCodeAt(state.position + 1);\n\n      if (is_WS_OR_EOL(following)) {\n        isPair = isExplicitPair = true;\n        state.position++;\n        skipSeparationSpace(state, true, nodeIndent);\n      }\n    }\n\n    _line = state.line;\n    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);\n    keyTag = state.tag;\n    keyNode = state.result;\n    skipSeparationSpace(state, true, nodeIndent);\n\n    ch = state.input.charCodeAt(state.position);\n\n    if ((isExplicitPair || state.line === _line) && ch === 0x3A/* : */) {\n      isPair = true;\n      ch = state.input.charCodeAt(++state.position);\n      skipSeparationSpace(state, true, nodeIndent);\n      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);\n      valueNode = state.result;\n    }\n\n    if (isMapping) {\n      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode);\n    } else if (isPair) {\n      _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode));\n    } else {\n      _result.push(keyNode);\n    }\n\n    skipSeparationSpace(state, true, nodeIndent);\n\n    ch = state.input.charCodeAt(state.position);\n\n    if (ch === 0x2C/* , */) {\n      readNext = true;\n      ch = state.input.charCodeAt(++state.position);\n    } else {\n      readNext = false;\n    }\n  }\n\n  throwError(state, 'unexpected end of the stream within a flow collection');\n}\n\nfunction readBlockScalar(state, nodeIndent) {\n  var captureStart,\n      folding,\n      chomping       = CHOMPING_CLIP,\n      didReadContent = false,\n      detectedIndent = false,\n      textIndent     = nodeIndent,\n      emptyLines     = 0,\n      atMoreIndented = false,\n      tmp,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch === 0x7C/* | */) {\n    folding = false;\n  } else if (ch === 0x3E/* > */) {\n    folding = true;\n  } else {\n    return false;\n  }\n\n  state.kind = 'scalar';\n  state.result = '';\n\n  while (ch !== 0) {\n    ch = state.input.charCodeAt(++state.position);\n\n    if (ch === 0x2B/* + */ || ch === 0x2D/* - */) {\n      if (CHOMPING_CLIP === chomping) {\n        chomping = (ch === 0x2B/* + */) ? CHOMPING_KEEP : CHOMPING_STRIP;\n      } else {\n        throwError(state, 'repeat of a chomping mode identifier');\n      }\n\n    } else if ((tmp = fromDecimalCode(ch)) >= 0) {\n      if (tmp === 0) {\n        throwError(state, 'bad explicit indentation width of a block scalar; it cannot be less than one');\n      } else if (!detectedIndent) {\n        textIndent = nodeIndent + tmp - 1;\n        detectedIndent = true;\n      } else {\n        throwError(state, 'repeat of an indentation width identifier');\n      }\n\n    } else {\n      break;\n    }\n  }\n\n  if (is_WHITE_SPACE(ch)) {\n    do { ch = state.input.charCodeAt(++state.position); }\n    while (is_WHITE_SPACE(ch));\n\n    if (ch === 0x23/* # */) {\n      do { ch = state.input.charCodeAt(++state.position); }\n      while (!is_EOL(ch) && (ch !== 0));\n    }\n  }\n\n  while (ch !== 0) {\n    readLineBreak(state);\n    state.lineIndent = 0;\n\n    ch = state.input.charCodeAt(state.position);\n\n    while ((!detectedIndent || state.lineIndent < textIndent) &&\n           (ch === 0x20/* Space */)) {\n      state.lineIndent++;\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    if (!detectedIndent && state.lineIndent > textIndent) {\n      textIndent = state.lineIndent;\n    }\n\n    if (is_EOL(ch)) {\n      emptyLines++;\n      continue;\n    }\n\n    // End of the scalar.\n    if (state.lineIndent < textIndent) {\n\n      // Perform the chomping.\n      if (chomping === CHOMPING_KEEP) {\n        state.result += common.repeat('\\n', didReadContent ? 1 + emptyLines : emptyLines);\n      } else if (chomping === CHOMPING_CLIP) {\n        if (didReadContent) { // i.e. only if the scalar is not empty.\n          state.result += '\\n';\n        }\n      }\n\n      // Break this `while` cycle and go to the funciton's epilogue.\n      break;\n    }\n\n    // Folded style: use fancy rules to handle line breaks.\n    if (folding) {\n\n      // Lines starting with white space characters (more-indented lines) are not folded.\n      if (is_WHITE_SPACE(ch)) {\n        atMoreIndented = true;\n        // except for the first content line (cf. Example 8.1)\n        state.result += common.repeat('\\n', didReadContent ? 1 + emptyLines : emptyLines);\n\n      // End of more-indented block.\n      } else if (atMoreIndented) {\n        atMoreIndented = false;\n        state.result += common.repeat('\\n', emptyLines + 1);\n\n      // Just one line break - perceive as the same line.\n      } else if (emptyLines === 0) {\n        if (didReadContent) { // i.e. only if we have already read some scalar content.\n          state.result += ' ';\n        }\n\n      // Several line breaks - perceive as different lines.\n      } else {\n        state.result += common.repeat('\\n', emptyLines);\n      }\n\n    // Literal style: just add exact number of line breaks between content lines.\n    } else {\n      // Keep all line breaks except the header line break.\n      state.result += common.repeat('\\n', didReadContent ? 1 + emptyLines : emptyLines);\n    }\n\n    didReadContent = true;\n    detectedIndent = true;\n    emptyLines = 0;\n    captureStart = state.position;\n\n    while (!is_EOL(ch) && (ch !== 0)) {\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    captureSegment(state, captureStart, state.position, false);\n  }\n\n  return true;\n}\n\nfunction readBlockSequence(state, nodeIndent) {\n  var _line,\n      _tag      = state.tag,\n      _anchor   = state.anchor,\n      _result   = [],\n      following,\n      detected  = false,\n      ch;\n\n  if (state.anchor !== null) {\n    state.anchorMap[state.anchor] = _result;\n  }\n\n  ch = state.input.charCodeAt(state.position);\n\n  while (ch !== 0) {\n\n    if (ch !== 0x2D/* - */) {\n      break;\n    }\n\n    following = state.input.charCodeAt(state.position + 1);\n\n    if (!is_WS_OR_EOL(following)) {\n      break;\n    }\n\n    detected = true;\n    state.position++;\n\n    if (skipSeparationSpace(state, true, -1)) {\n      if (state.lineIndent <= nodeIndent) {\n        _result.push(null);\n        ch = state.input.charCodeAt(state.position);\n        continue;\n      }\n    }\n\n    _line = state.line;\n    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);\n    _result.push(state.result);\n    skipSeparationSpace(state, true, -1);\n\n    ch = state.input.charCodeAt(state.position);\n\n    if ((state.line === _line || state.lineIndent > nodeIndent) && (ch !== 0)) {\n      throwError(state, 'bad indentation of a sequence entry');\n    } else if (state.lineIndent < nodeIndent) {\n      break;\n    }\n  }\n\n  if (detected) {\n    state.tag = _tag;\n    state.anchor = _anchor;\n    state.kind = 'sequence';\n    state.result = _result;\n    return true;\n  }\n  return false;\n}\n\nfunction readBlockMapping(state, nodeIndent, flowIndent) {\n  var following,\n      allowCompact,\n      _line,\n      _pos,\n      _tag          = state.tag,\n      _anchor       = state.anchor,\n      _result       = {},\n      overridableKeys = {},\n      keyTag        = null,\n      keyNode       = null,\n      valueNode     = null,\n      atExplicitKey = false,\n      detected      = false,\n      ch;\n\n  if (state.anchor !== null) {\n    state.anchorMap[state.anchor] = _result;\n  }\n\n  ch = state.input.charCodeAt(state.position);\n\n  while (ch !== 0) {\n    following = state.input.charCodeAt(state.position + 1);\n    _line = state.line; // Save the current line.\n    _pos = state.position;\n\n    //\n    // Explicit notation case. There are two separate blocks:\n    // first for the key (denoted by \"?\") and second for the value (denoted by \":\")\n    //\n    if ((ch === 0x3F/* ? */ || ch === 0x3A/* : */) && is_WS_OR_EOL(following)) {\n\n      if (ch === 0x3F/* ? */) {\n        if (atExplicitKey) {\n          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);\n          keyTag = keyNode = valueNode = null;\n        }\n\n        detected = true;\n        atExplicitKey = true;\n        allowCompact = true;\n\n      } else if (atExplicitKey) {\n        // i.e. 0x3A/* : */ === character after the explicit key.\n        atExplicitKey = false;\n        allowCompact = true;\n\n      } else {\n        throwError(state, 'incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line');\n      }\n\n      state.position += 1;\n      ch = following;\n\n    //\n    // Implicit notation case. Flow-style node as the key first, then \":\", and the value.\n    //\n    } else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {\n\n      if (state.line === _line) {\n        ch = state.input.charCodeAt(state.position);\n\n        while (is_WHITE_SPACE(ch)) {\n          ch = state.input.charCodeAt(++state.position);\n        }\n\n        if (ch === 0x3A/* : */) {\n          ch = state.input.charCodeAt(++state.position);\n\n          if (!is_WS_OR_EOL(ch)) {\n            throwError(state, 'a whitespace character is expected after the key-value separator within a block mapping');\n          }\n\n          if (atExplicitKey) {\n            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);\n            keyTag = keyNode = valueNode = null;\n          }\n\n          detected = true;\n          atExplicitKey = false;\n          allowCompact = false;\n          keyTag = state.tag;\n          keyNode = state.result;\n\n        } else if (detected) {\n          throwError(state, 'can not read an implicit mapping pair; a colon is missed');\n\n        } else {\n          state.tag = _tag;\n          state.anchor = _anchor;\n          return true; // Keep the result of `composeNode`.\n        }\n\n      } else if (detected) {\n        throwError(state, 'can not read a block mapping entry; a multiline key may not be an implicit key');\n\n      } else {\n        state.tag = _tag;\n        state.anchor = _anchor;\n        return true; // Keep the result of `composeNode`.\n      }\n\n    } else {\n      break; // Reading is done. Go to the epilogue.\n    }\n\n    //\n    // Common reading code for both explicit and implicit notations.\n    //\n    if (state.line === _line || state.lineIndent > nodeIndent) {\n      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {\n        if (atExplicitKey) {\n          keyNode = state.result;\n        } else {\n          valueNode = state.result;\n        }\n      }\n\n      if (!atExplicitKey) {\n        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _pos);\n        keyTag = keyNode = valueNode = null;\n      }\n\n      skipSeparationSpace(state, true, -1);\n      ch = state.input.charCodeAt(state.position);\n    }\n\n    if (state.lineIndent > nodeIndent && (ch !== 0)) {\n      throwError(state, 'bad indentation of a mapping entry');\n    } else if (state.lineIndent < nodeIndent) {\n      break;\n    }\n  }\n\n  //\n  // Epilogue.\n  //\n\n  // Special case: last mapping's node contains only the key in explicit notation.\n  if (atExplicitKey) {\n    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);\n  }\n\n  // Expose the resulting mapping.\n  if (detected) {\n    state.tag = _tag;\n    state.anchor = _anchor;\n    state.kind = 'mapping';\n    state.result = _result;\n  }\n\n  return detected;\n}\n\nfunction readTagProperty(state) {\n  var _position,\n      isVerbatim = false,\n      isNamed    = false,\n      tagHandle,\n      tagName,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch !== 0x21/* ! */) return false;\n\n  if (state.tag !== null) {\n    throwError(state, 'duplication of a tag property');\n  }\n\n  ch = state.input.charCodeAt(++state.position);\n\n  if (ch === 0x3C/* < */) {\n    isVerbatim = true;\n    ch = state.input.charCodeAt(++state.position);\n\n  } else if (ch === 0x21/* ! */) {\n    isNamed = true;\n    tagHandle = '!!';\n    ch = state.input.charCodeAt(++state.position);\n\n  } else {\n    tagHandle = '!';\n  }\n\n  _position = state.position;\n\n  if (isVerbatim) {\n    do { ch = state.input.charCodeAt(++state.position); }\n    while (ch !== 0 && ch !== 0x3E/* > */);\n\n    if (state.position < state.length) {\n      tagName = state.input.slice(_position, state.position);\n      ch = state.input.charCodeAt(++state.position);\n    } else {\n      throwError(state, 'unexpected end of the stream within a verbatim tag');\n    }\n  } else {\n    while (ch !== 0 && !is_WS_OR_EOL(ch)) {\n\n      if (ch === 0x21/* ! */) {\n        if (!isNamed) {\n          tagHandle = state.input.slice(_position - 1, state.position + 1);\n\n          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {\n            throwError(state, 'named tag handle cannot contain such characters');\n          }\n\n          isNamed = true;\n          _position = state.position + 1;\n        } else {\n          throwError(state, 'tag suffix cannot contain exclamation marks');\n        }\n      }\n\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    tagName = state.input.slice(_position, state.position);\n\n    if (PATTERN_FLOW_INDICATORS.test(tagName)) {\n      throwError(state, 'tag suffix cannot contain flow indicator characters');\n    }\n  }\n\n  if (tagName && !PATTERN_TAG_URI.test(tagName)) {\n    throwError(state, 'tag name cannot contain such characters: ' + tagName);\n  }\n\n  if (isVerbatim) {\n    state.tag = tagName;\n\n  } else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {\n    state.tag = state.tagMap[tagHandle] + tagName;\n\n  } else if (tagHandle === '!') {\n    state.tag = '!' + tagName;\n\n  } else if (tagHandle === '!!') {\n    state.tag = 'tag:yaml.org,2002:' + tagName;\n\n  } else {\n    throwError(state, 'undeclared tag handle \"' + tagHandle + '\"');\n  }\n\n  return true;\n}\n\nfunction readAnchorProperty(state) {\n  var _position,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch !== 0x26/* & */) return false;\n\n  if (state.anchor !== null) {\n    throwError(state, 'duplication of an anchor property');\n  }\n\n  ch = state.input.charCodeAt(++state.position);\n  _position = state.position;\n\n  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {\n    ch = state.input.charCodeAt(++state.position);\n  }\n\n  if (state.position === _position) {\n    throwError(state, 'name of an anchor node must contain at least one character');\n  }\n\n  state.anchor = state.input.slice(_position, state.position);\n  return true;\n}\n\nfunction readAlias(state) {\n  var _position, alias,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch !== 0x2A/* * */) return false;\n\n  ch = state.input.charCodeAt(++state.position);\n  _position = state.position;\n\n  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {\n    ch = state.input.charCodeAt(++state.position);\n  }\n\n  if (state.position === _position) {\n    throwError(state, 'name of an alias node must contain at least one character');\n  }\n\n  alias = state.input.slice(_position, state.position);\n\n  if (!state.anchorMap.hasOwnProperty(alias)) {\n    throwError(state, 'unidentified alias \"' + alias + '\"');\n  }\n\n  state.result = state.anchorMap[alias];\n  skipSeparationSpace(state, true, -1);\n  return true;\n}\n\nfunction composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {\n  var allowBlockStyles,\n      allowBlockScalars,\n      allowBlockCollections,\n      indentStatus = 1, // 1: this>parent, 0: this=parent, -1: this<parent\n      atNewLine  = false,\n      hasContent = false,\n      typeIndex,\n      typeQuantity,\n      type,\n      flowIndent,\n      blockIndent;\n\n  if (state.listener !== null) {\n    state.listener('open', state);\n  }\n\n  state.tag    = null;\n  state.anchor = null;\n  state.kind   = null;\n  state.result = null;\n\n  allowBlockStyles = allowBlockScalars = allowBlockCollections =\n    CONTEXT_BLOCK_OUT === nodeContext ||\n    CONTEXT_BLOCK_IN  === nodeContext;\n\n  if (allowToSeek) {\n    if (skipSeparationSpace(state, true, -1)) {\n      atNewLine = true;\n\n      if (state.lineIndent > parentIndent) {\n        indentStatus = 1;\n      } else if (state.lineIndent === parentIndent) {\n        indentStatus = 0;\n      } else if (state.lineIndent < parentIndent) {\n        indentStatus = -1;\n      }\n    }\n  }\n\n  if (indentStatus === 1) {\n    while (readTagProperty(state) || readAnchorProperty(state)) {\n      if (skipSeparationSpace(state, true, -1)) {\n        atNewLine = true;\n        allowBlockCollections = allowBlockStyles;\n\n        if (state.lineIndent > parentIndent) {\n          indentStatus = 1;\n        } else if (state.lineIndent === parentIndent) {\n          indentStatus = 0;\n        } else if (state.lineIndent < parentIndent) {\n          indentStatus = -1;\n        }\n      } else {\n        allowBlockCollections = false;\n      }\n    }\n  }\n\n  if (allowBlockCollections) {\n    allowBlockCollections = atNewLine || allowCompact;\n  }\n\n  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {\n    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {\n      flowIndent = parentIndent;\n    } else {\n      flowIndent = parentIndent + 1;\n    }\n\n    blockIndent = state.position - state.lineStart;\n\n    if (indentStatus === 1) {\n      if (allowBlockCollections &&\n          (readBlockSequence(state, blockIndent) ||\n           readBlockMapping(state, blockIndent, flowIndent)) ||\n          readFlowCollection(state, flowIndent)) {\n        hasContent = true;\n      } else {\n        if ((allowBlockScalars && readBlockScalar(state, flowIndent)) ||\n            readSingleQuotedScalar(state, flowIndent) ||\n            readDoubleQuotedScalar(state, flowIndent)) {\n          hasContent = true;\n\n        } else if (readAlias(state)) {\n          hasContent = true;\n\n          if (state.tag !== null || state.anchor !== null) {\n            throwError(state, 'alias node should not have any properties');\n          }\n\n        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {\n          hasContent = true;\n\n          if (state.tag === null) {\n            state.tag = '?';\n          }\n        }\n\n        if (state.anchor !== null) {\n          state.anchorMap[state.anchor] = state.result;\n        }\n      }\n    } else if (indentStatus === 0) {\n      // Special case: block sequences are allowed to have same indentation level as the parent.\n      // http://www.yaml.org/spec/1.2/spec.html#id2799784\n      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);\n    }\n  }\n\n  if (state.tag !== null && state.tag !== '!') {\n    if (state.tag === '?') {\n      for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {\n        type = state.implicitTypes[typeIndex];\n\n        // Implicit resolving is not allowed for non-scalar types, and '?'\n        // non-specific tag is only assigned to plain scalars. So, it isn't\n        // needed to check for 'kind' conformity.\n\n        if (type.resolve(state.result)) { // `state.result` updated in resolver if matched\n          state.result = type.construct(state.result);\n          state.tag = type.tag;\n          if (state.anchor !== null) {\n            state.anchorMap[state.anchor] = state.result;\n          }\n          break;\n        }\n      }\n    } else if (_hasOwnProperty.call(state.typeMap[state.kind || 'fallback'], state.tag)) {\n      type = state.typeMap[state.kind || 'fallback'][state.tag];\n\n      if (state.result !== null && type.kind !== state.kind) {\n        throwError(state, 'unacceptable node kind for !<' + state.tag + '> tag; it should be \"' + type.kind + '\", not \"' + state.kind + '\"');\n      }\n\n      if (!type.resolve(state.result)) { // `state.result` updated in resolver if matched\n        throwError(state, 'cannot resolve a node with !<' + state.tag + '> explicit tag');\n      } else {\n        state.result = type.construct(state.result);\n        if (state.anchor !== null) {\n          state.anchorMap[state.anchor] = state.result;\n        }\n      }\n    } else {\n      throwError(state, 'unknown tag !<' + state.tag + '>');\n    }\n  }\n\n  if (state.listener !== null) {\n    state.listener('close', state);\n  }\n  return state.tag !== null ||  state.anchor !== null || hasContent;\n}\n\nfunction readDocument(state) {\n  var documentStart = state.position,\n      _position,\n      directiveName,\n      directiveArgs,\n      hasDirectives = false,\n      ch;\n\n  state.version = null;\n  state.checkLineBreaks = state.legacy;\n  state.tagMap = {};\n  state.anchorMap = {};\n\n  while ((ch = state.input.charCodeAt(state.position)) !== 0) {\n    skipSeparationSpace(state, true, -1);\n\n    ch = state.input.charCodeAt(state.position);\n\n    if (state.lineIndent > 0 || ch !== 0x25/* % */) {\n      break;\n    }\n\n    hasDirectives = true;\n    ch = state.input.charCodeAt(++state.position);\n    _position = state.position;\n\n    while (ch !== 0 && !is_WS_OR_EOL(ch)) {\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    directiveName = state.input.slice(_position, state.position);\n    directiveArgs = [];\n\n    if (directiveName.length < 1) {\n      throwError(state, 'directive name must not be less than one character in length');\n    }\n\n    while (ch !== 0) {\n      while (is_WHITE_SPACE(ch)) {\n        ch = state.input.charCodeAt(++state.position);\n      }\n\n      if (ch === 0x23/* # */) {\n        do { ch = state.input.charCodeAt(++state.position); }\n        while (ch !== 0 && !is_EOL(ch));\n        break;\n      }\n\n      if (is_EOL(ch)) break;\n\n      _position = state.position;\n\n      while (ch !== 0 && !is_WS_OR_EOL(ch)) {\n        ch = state.input.charCodeAt(++state.position);\n      }\n\n      directiveArgs.push(state.input.slice(_position, state.position));\n    }\n\n    if (ch !== 0) readLineBreak(state);\n\n    if (_hasOwnProperty.call(directiveHandlers, directiveName)) {\n      directiveHandlers[directiveName](state, directiveName, directiveArgs);\n    } else {\n      throwWarning(state, 'unknown document directive \"' + directiveName + '\"');\n    }\n  }\n\n  skipSeparationSpace(state, true, -1);\n\n  if (state.lineIndent === 0 &&\n      state.input.charCodeAt(state.position)     === 0x2D/* - */ &&\n      state.input.charCodeAt(state.position + 1) === 0x2D/* - */ &&\n      state.input.charCodeAt(state.position + 2) === 0x2D/* - */) {\n    state.position += 3;\n    skipSeparationSpace(state, true, -1);\n\n  } else if (hasDirectives) {\n    throwError(state, 'directives end mark is expected');\n  }\n\n  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);\n  skipSeparationSpace(state, true, -1);\n\n  if (state.checkLineBreaks &&\n      PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {\n    throwWarning(state, 'non-ASCII line breaks are interpreted as content');\n  }\n\n  state.documents.push(state.result);\n\n  if (state.position === state.lineStart && testDocumentSeparator(state)) {\n\n    if (state.input.charCodeAt(state.position) === 0x2E/* . */) {\n      state.position += 3;\n      skipSeparationSpace(state, true, -1);\n    }\n    return;\n  }\n\n  if (state.position < (state.length - 1)) {\n    throwError(state, 'end of the stream or a document separator is expected');\n  } else {\n    return;\n  }\n}\n\n\nfunction loadDocuments(input, options) {\n  input = String(input);\n  options = options || {};\n\n  if (input.length !== 0) {\n\n    // Add tailing `\\n` if not exists\n    if (input.charCodeAt(input.length - 1) !== 0x0A/* LF */ &&\n        input.charCodeAt(input.length - 1) !== 0x0D/* CR */) {\n      input += '\\n';\n    }\n\n    // Strip BOM\n    if (input.charCodeAt(0) === 0xFEFF) {\n      input = input.slice(1);\n    }\n  }\n\n  var state = new State(input, options);\n\n  // Use 0 as string terminator. That significantly simplifies bounds check.\n  state.input += '\\0';\n\n  while (state.input.charCodeAt(state.position) === 0x20/* Space */) {\n    state.lineIndent += 1;\n    state.position += 1;\n  }\n\n  while (state.position < (state.length - 1)) {\n    readDocument(state);\n  }\n\n  return state.documents;\n}\n\n\nfunction loadAll(input, iterator, options) {\n  var documents = loadDocuments(input, options), index, length;\n\n  if (typeof iterator !== 'function') {\n    return documents;\n  }\n\n  for (index = 0, length = documents.length; index < length; index += 1) {\n    iterator(documents[index]);\n  }\n}\n\n\nfunction load(input, options) {\n  var documents = loadDocuments(input, options);\n\n  if (documents.length === 0) {\n    /*eslint-disable no-undefined*/\n    return undefined;\n  } else if (documents.length === 1) {\n    return documents[0];\n  }\n  throw new YAMLException('expected a single document in the stream, but found more');\n}\n\n\nfunction safeLoadAll(input, output, options) {\n  if (typeof output === 'function') {\n    loadAll(input, output, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));\n  } else {\n    return loadAll(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));\n  }\n}\n\n\nfunction safeLoad(input, options) {\n  return load(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));\n}\n\n\nmodule.exports.loadAll     = loadAll;\nmodule.exports.load        = load;\nmodule.exports.safeLoadAll = safeLoadAll;\nmodule.exports.safeLoad    = safeLoad;\n","'use strict';\n\n/*eslint-disable no-use-before-define*/\n\nvar common              = require('./common');\nvar YAMLException       = require('./exception');\nvar DEFAULT_FULL_SCHEMA = require('./schema/default_full');\nvar DEFAULT_SAFE_SCHEMA = require('./schema/default_safe');\n\nvar _toString       = Object.prototype.toString;\nvar _hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar CHAR_TAB                  = 0x09; /* Tab */\nvar CHAR_LINE_FEED            = 0x0A; /* LF */\nvar CHAR_SPACE                = 0x20; /* Space */\nvar CHAR_EXCLAMATION          = 0x21; /* ! */\nvar CHAR_DOUBLE_QUOTE         = 0x22; /* \" */\nvar CHAR_SHARP                = 0x23; /* # */\nvar CHAR_PERCENT              = 0x25; /* % */\nvar CHAR_AMPERSAND            = 0x26; /* & */\nvar CHAR_SINGLE_QUOTE         = 0x27; /* ' */\nvar CHAR_ASTERISK             = 0x2A; /* * */\nvar CHAR_COMMA                = 0x2C; /* , */\nvar CHAR_MINUS                = 0x2D; /* - */\nvar CHAR_COLON                = 0x3A; /* : */\nvar CHAR_GREATER_THAN         = 0x3E; /* > */\nvar CHAR_QUESTION             = 0x3F; /* ? */\nvar CHAR_COMMERCIAL_AT        = 0x40; /* @ */\nvar CHAR_LEFT_SQUARE_BRACKET  = 0x5B; /* [ */\nvar CHAR_RIGHT_SQUARE_BRACKET = 0x5D; /* ] */\nvar CHAR_GRAVE_ACCENT         = 0x60; /* ` */\nvar CHAR_LEFT_CURLY_BRACKET   = 0x7B; /* { */\nvar CHAR_VERTICAL_LINE        = 0x7C; /* | */\nvar CHAR_RIGHT_CURLY_BRACKET  = 0x7D; /* } */\n\nvar ESCAPE_SEQUENCES = {};\n\nESCAPE_SEQUENCES[0x00]   = '\\\\0';\nESCAPE_SEQUENCES[0x07]   = '\\\\a';\nESCAPE_SEQUENCES[0x08]   = '\\\\b';\nESCAPE_SEQUENCES[0x09]   = '\\\\t';\nESCAPE_SEQUENCES[0x0A]   = '\\\\n';\nESCAPE_SEQUENCES[0x0B]   = '\\\\v';\nESCAPE_SEQUENCES[0x0C]   = '\\\\f';\nESCAPE_SEQUENCES[0x0D]   = '\\\\r';\nESCAPE_SEQUENCES[0x1B]   = '\\\\e';\nESCAPE_SEQUENCES[0x22]   = '\\\\\"';\nESCAPE_SEQUENCES[0x5C]   = '\\\\\\\\';\nESCAPE_SEQUENCES[0x85]   = '\\\\N';\nESCAPE_SEQUENCES[0xA0]   = '\\\\_';\nESCAPE_SEQUENCES[0x2028] = '\\\\L';\nESCAPE_SEQUENCES[0x2029] = '\\\\P';\n\nvar DEPRECATED_BOOLEANS_SYNTAX = [\n  'y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON',\n  'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF'\n];\n\nfunction compileStyleMap(schema, map) {\n  var result, keys, index, length, tag, style, type;\n\n  if (map === null) return {};\n\n  result = {};\n  keys = Object.keys(map);\n\n  for (index = 0, length = keys.length; index < length; index += 1) {\n    tag = keys[index];\n    style = String(map[tag]);\n\n    if (tag.slice(0, 2) === '!!') {\n      tag = 'tag:yaml.org,2002:' + tag.slice(2);\n    }\n    type = schema.compiledTypeMap['fallback'][tag];\n\n    if (type && _hasOwnProperty.call(type.styleAliases, style)) {\n      style = type.styleAliases[style];\n    }\n\n    result[tag] = style;\n  }\n\n  return result;\n}\n\nfunction encodeHex(character) {\n  var string, handle, length;\n\n  string = character.toString(16).toUpperCase();\n\n  if (character <= 0xFF) {\n    handle = 'x';\n    length = 2;\n  } else if (character <= 0xFFFF) {\n    handle = 'u';\n    length = 4;\n  } else if (character <= 0xFFFFFFFF) {\n    handle = 'U';\n    length = 8;\n  } else {\n    throw new YAMLException('code point within a string may not be greater than 0xFFFFFFFF');\n  }\n\n  return '\\\\' + handle + common.repeat('0', length - string.length) + string;\n}\n\nfunction State(options) {\n  this.schema        = options['schema'] || DEFAULT_FULL_SCHEMA;\n  this.indent        = Math.max(1, (options['indent'] || 2));\n  this.noArrayIndent = options['noArrayIndent'] || false;\n  this.skipInvalid   = options['skipInvalid'] || false;\n  this.flowLevel     = (common.isNothing(options['flowLevel']) ? -1 : options['flowLevel']);\n  this.styleMap      = compileStyleMap(this.schema, options['styles'] || null);\n  this.sortKeys      = options['sortKeys'] || false;\n  this.lineWidth     = options['lineWidth'] || 80;\n  this.noRefs        = options['noRefs'] || false;\n  this.noCompatMode  = options['noCompatMode'] || false;\n  this.condenseFlow  = options['condenseFlow'] || false;\n\n  this.implicitTypes = this.schema.compiledImplicit;\n  this.explicitTypes = this.schema.compiledExplicit;\n\n  this.tag = null;\n  this.result = '';\n\n  this.duplicates = [];\n  this.usedDuplicates = null;\n}\n\n// Indents every line in a string. Empty lines (\\n only) are not indented.\nfunction indentString(string, spaces) {\n  var ind = common.repeat(' ', spaces),\n      position = 0,\n      next = -1,\n      result = '',\n      line,\n      length = string.length;\n\n  while (position < length) {\n    next = string.indexOf('\\n', position);\n    if (next === -1) {\n      line = string.slice(position);\n      position = length;\n    } else {\n      line = string.slice(position, next + 1);\n      position = next + 1;\n    }\n\n    if (line.length && line !== '\\n') result += ind;\n\n    result += line;\n  }\n\n  return result;\n}\n\nfunction generateNextLine(state, level) {\n  return '\\n' + common.repeat(' ', state.indent * level);\n}\n\nfunction testImplicitResolving(state, str) {\n  var index, length, type;\n\n  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {\n    type = state.implicitTypes[index];\n\n    if (type.resolve(str)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n// [33] s-white ::= s-space | s-tab\nfunction isWhitespace(c) {\n  return c === CHAR_SPACE || c === CHAR_TAB;\n}\n\n// Returns true if the character can be printed without escaping.\n// From YAML 1.2: \"any allowed characters known to be non-printable\n// should also be escaped. [However,] This isn’t mandatory\"\n// Derived from nb-char - \\t - #x85 - #xA0 - #x2028 - #x2029.\nfunction isPrintable(c) {\n  return  (0x00020 <= c && c <= 0x00007E)\n      || ((0x000A1 <= c && c <= 0x00D7FF) && c !== 0x2028 && c !== 0x2029)\n      || ((0x0E000 <= c && c <= 0x00FFFD) && c !== 0xFEFF /* BOM */)\n      ||  (0x10000 <= c && c <= 0x10FFFF);\n}\n\n// Simplified test for values allowed after the first character in plain style.\nfunction isPlainSafe(c) {\n  // Uses a subset of nb-char - c-flow-indicator - \":\" - \"#\"\n  // where nb-char ::= c-printable - b-char - c-byte-order-mark.\n  return isPrintable(c) && c !== 0xFEFF\n    // - c-flow-indicator\n    && c !== CHAR_COMMA\n    && c !== CHAR_LEFT_SQUARE_BRACKET\n    && c !== CHAR_RIGHT_SQUARE_BRACKET\n    && c !== CHAR_LEFT_CURLY_BRACKET\n    && c !== CHAR_RIGHT_CURLY_BRACKET\n    // - \":\" - \"#\"\n    && c !== CHAR_COLON\n    && c !== CHAR_SHARP;\n}\n\n// Simplified test for values allowed as the first character in plain style.\nfunction isPlainSafeFirst(c) {\n  // Uses a subset of ns-char - c-indicator\n  // where ns-char = nb-char - s-white.\n  return isPrintable(c) && c !== 0xFEFF\n    && !isWhitespace(c) // - s-white\n    // - (c-indicator ::=\n    // “-” | “?” | “:” | “,” | “[” | “]” | “{” | “}”\n    && c !== CHAR_MINUS\n    && c !== CHAR_QUESTION\n    && c !== CHAR_COLON\n    && c !== CHAR_COMMA\n    && c !== CHAR_LEFT_SQUARE_BRACKET\n    && c !== CHAR_RIGHT_SQUARE_BRACKET\n    && c !== CHAR_LEFT_CURLY_BRACKET\n    && c !== CHAR_RIGHT_CURLY_BRACKET\n    // | “#” | “&” | “*” | “!” | “|” | “>” | “'” | “\"”\n    && c !== CHAR_SHARP\n    && c !== CHAR_AMPERSAND\n    && c !== CHAR_ASTERISK\n    && c !== CHAR_EXCLAMATION\n    && c !== CHAR_VERTICAL_LINE\n    && c !== CHAR_GREATER_THAN\n    && c !== CHAR_SINGLE_QUOTE\n    && c !== CHAR_DOUBLE_QUOTE\n    // | “%” | “@” | “`”)\n    && c !== CHAR_PERCENT\n    && c !== CHAR_COMMERCIAL_AT\n    && c !== CHAR_GRAVE_ACCENT;\n}\n\n// Determines whether block indentation indicator is required.\nfunction needIndentIndicator(string) {\n  var leadingSpaceRe = /^\\n* /;\n  return leadingSpaceRe.test(string);\n}\n\nvar STYLE_PLAIN   = 1,\n    STYLE_SINGLE  = 2,\n    STYLE_LITERAL = 3,\n    STYLE_FOLDED  = 4,\n    STYLE_DOUBLE  = 5;\n\n// Determines which scalar styles are possible and returns the preferred style.\n// lineWidth = -1 => no limit.\n// Pre-conditions: str.length > 0.\n// Post-conditions:\n//    STYLE_PLAIN or STYLE_SINGLE => no \\n are in the string.\n//    STYLE_LITERAL => no lines are suitable for folding (or lineWidth is -1).\n//    STYLE_FOLDED => a line > lineWidth and can be folded (and lineWidth != -1).\nfunction chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType) {\n  var i;\n  var char;\n  var hasLineBreak = false;\n  var hasFoldableLine = false; // only checked if shouldTrackWidth\n  var shouldTrackWidth = lineWidth !== -1;\n  var previousLineBreak = -1; // count the first line correctly\n  var plain = isPlainSafeFirst(string.charCodeAt(0))\n          && !isWhitespace(string.charCodeAt(string.length - 1));\n\n  if (singleLineOnly) {\n    // Case: no block styles.\n    // Check for disallowed characters to rule out plain and single.\n    for (i = 0; i < string.length; i++) {\n      char = string.charCodeAt(i);\n      if (!isPrintable(char)) {\n        return STYLE_DOUBLE;\n      }\n      plain = plain && isPlainSafe(char);\n    }\n  } else {\n    // Case: block styles permitted.\n    for (i = 0; i < string.length; i++) {\n      char = string.charCodeAt(i);\n      if (char === CHAR_LINE_FEED) {\n        hasLineBreak = true;\n        // Check if any line can be folded.\n        if (shouldTrackWidth) {\n          hasFoldableLine = hasFoldableLine ||\n            // Foldable line = too long, and not more-indented.\n            (i - previousLineBreak - 1 > lineWidth &&\n             string[previousLineBreak + 1] !== ' ');\n          previousLineBreak = i;\n        }\n      } else if (!isPrintable(char)) {\n        return STYLE_DOUBLE;\n      }\n      plain = plain && isPlainSafe(char);\n    }\n    // in case the end is missing a \\n\n    hasFoldableLine = hasFoldableLine || (shouldTrackWidth &&\n      (i - previousLineBreak - 1 > lineWidth &&\n       string[previousLineBreak + 1] !== ' '));\n  }\n  // Although every style can represent \\n without escaping, prefer block styles\n  // for multiline, since they're more readable and they don't add empty lines.\n  // Also prefer folding a super-long line.\n  if (!hasLineBreak && !hasFoldableLine) {\n    // Strings interpretable as another type have to be quoted;\n    // e.g. the string 'true' vs. the boolean true.\n    return plain && !testAmbiguousType(string)\n      ? STYLE_PLAIN : STYLE_SINGLE;\n  }\n  // Edge case: block indentation indicator can only have one digit.\n  if (indentPerLevel > 9 && needIndentIndicator(string)) {\n    return STYLE_DOUBLE;\n  }\n  // At this point we know block styles are valid.\n  // Prefer literal style unless we want to fold.\n  return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;\n}\n\n// Note: line breaking/folding is implemented for only the folded style.\n// NB. We drop the last trailing newline (if any) of a returned block scalar\n//  since the dumper adds its own newline. This always works:\n//    • No ending newline => unaffected; already using strip \"-\" chomping.\n//    • Ending newline    => removed then restored.\n//  Importantly, this keeps the \"+\" chomp indicator from gaining an extra line.\nfunction writeScalar(state, string, level, iskey) {\n  state.dump = (function () {\n    if (string.length === 0) {\n      return \"''\";\n    }\n    if (!state.noCompatMode &&\n        DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1) {\n      return \"'\" + string + \"'\";\n    }\n\n    var indent = state.indent * Math.max(1, level); // no 0-indent scalars\n    // As indentation gets deeper, let the width decrease monotonically\n    // to the lower bound min(state.lineWidth, 40).\n    // Note that this implies\n    //  state.lineWidth ≤ 40 + state.indent: width is fixed at the lower bound.\n    //  state.lineWidth > 40 + state.indent: width decreases until the lower bound.\n    // This behaves better than a constant minimum width which disallows narrower options,\n    // or an indent threshold which causes the width to suddenly increase.\n    var lineWidth = state.lineWidth === -1\n      ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);\n\n    // Without knowing if keys are implicit/explicit, assume implicit for safety.\n    var singleLineOnly = iskey\n      // No block styles in flow mode.\n      || (state.flowLevel > -1 && level >= state.flowLevel);\n    function testAmbiguity(string) {\n      return testImplicitResolving(state, string);\n    }\n\n    switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity)) {\n      case STYLE_PLAIN:\n        return string;\n      case STYLE_SINGLE:\n        return \"'\" + string.replace(/'/g, \"''\") + \"'\";\n      case STYLE_LITERAL:\n        return '|' + blockHeader(string, state.indent)\n          + dropEndingNewline(indentString(string, indent));\n      case STYLE_FOLDED:\n        return '>' + blockHeader(string, state.indent)\n          + dropEndingNewline(indentString(foldString(string, lineWidth), indent));\n      case STYLE_DOUBLE:\n        return '\"' + escapeString(string, lineWidth) + '\"';\n      default:\n        throw new YAMLException('impossible error: invalid scalar style');\n    }\n  }());\n}\n\n// Pre-conditions: string is valid for a block scalar, 1 <= indentPerLevel <= 9.\nfunction blockHeader(string, indentPerLevel) {\n  var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : '';\n\n  // note the special case: the string '\\n' counts as a \"trailing\" empty line.\n  var clip =          string[string.length - 1] === '\\n';\n  var keep = clip && (string[string.length - 2] === '\\n' || string === '\\n');\n  var chomp = keep ? '+' : (clip ? '' : '-');\n\n  return indentIndicator + chomp + '\\n';\n}\n\n// (See the note for writeScalar.)\nfunction dropEndingNewline(string) {\n  return string[string.length - 1] === '\\n' ? string.slice(0, -1) : string;\n}\n\n// Note: a long line without a suitable break point will exceed the width limit.\n// Pre-conditions: every char in str isPrintable, str.length > 0, width > 0.\nfunction foldString(string, width) {\n  // In folded style, $k$ consecutive newlines output as $k+1$ newlines—\n  // unless they're before or after a more-indented line, or at the very\n  // beginning or end, in which case $k$ maps to $k$.\n  // Therefore, parse each chunk as newline(s) followed by a content line.\n  var lineRe = /(\\n+)([^\\n]*)/g;\n\n  // first line (possibly an empty line)\n  var result = (function () {\n    var nextLF = string.indexOf('\\n');\n    nextLF = nextLF !== -1 ? nextLF : string.length;\n    lineRe.lastIndex = nextLF;\n    return foldLine(string.slice(0, nextLF), width);\n  }());\n  // If we haven't reached the first content line yet, don't add an extra \\n.\n  var prevMoreIndented = string[0] === '\\n' || string[0] === ' ';\n  var moreIndented;\n\n  // rest of the lines\n  var match;\n  while ((match = lineRe.exec(string))) {\n    var prefix = match[1], line = match[2];\n    moreIndented = (line[0] === ' ');\n    result += prefix\n      + (!prevMoreIndented && !moreIndented && line !== ''\n        ? '\\n' : '')\n      + foldLine(line, width);\n    prevMoreIndented = moreIndented;\n  }\n\n  return result;\n}\n\n// Greedy line breaking.\n// Picks the longest line under the limit each time,\n// otherwise settles for the shortest line over the limit.\n// NB. More-indented lines *cannot* be folded, as that would add an extra \\n.\nfunction foldLine(line, width) {\n  if (line === '' || line[0] === ' ') return line;\n\n  // Since a more-indented line adds a \\n, breaks can't be followed by a space.\n  var breakRe = / [^ ]/g; // note: the match index will always be <= length-2.\n  var match;\n  // start is an inclusive index. end, curr, and next are exclusive.\n  var start = 0, end, curr = 0, next = 0;\n  var result = '';\n\n  // Invariants: 0 <= start <= length-1.\n  //   0 <= curr <= next <= max(0, length-2). curr - start <= width.\n  // Inside the loop:\n  //   A match implies length >= 2, so curr and next are <= length-2.\n  while ((match = breakRe.exec(line))) {\n    next = match.index;\n    // maintain invariant: curr - start <= width\n    if (next - start > width) {\n      end = (curr > start) ? curr : next; // derive end <= length-2\n      result += '\\n' + line.slice(start, end);\n      // skip the space that was output as \\n\n      start = end + 1;                    // derive start <= length-1\n    }\n    curr = next;\n  }\n\n  // By the invariants, start <= length-1, so there is something left over.\n  // It is either the whole string or a part starting from non-whitespace.\n  result += '\\n';\n  // Insert a break if the remainder is too long and there is a break available.\n  if (line.length - start > width && curr > start) {\n    result += line.slice(start, curr) + '\\n' + line.slice(curr + 1);\n  } else {\n    result += line.slice(start);\n  }\n\n  return result.slice(1); // drop extra \\n joiner\n}\n\n// Escapes a double-quoted string.\nfunction escapeString(string) {\n  var result = '';\n  var char, nextChar;\n  var escapeSeq;\n\n  for (var i = 0; i < string.length; i++) {\n    char = string.charCodeAt(i);\n    // Check for surrogate pairs (reference Unicode 3.0 section \"3.7 Surrogates\").\n    if (char >= 0xD800 && char <= 0xDBFF/* high surrogate */) {\n      nextChar = string.charCodeAt(i + 1);\n      if (nextChar >= 0xDC00 && nextChar <= 0xDFFF/* low surrogate */) {\n        // Combine the surrogate pair and store it escaped.\n        result += encodeHex((char - 0xD800) * 0x400 + nextChar - 0xDC00 + 0x10000);\n        // Advance index one extra since we already used that char here.\n        i++; continue;\n      }\n    }\n    escapeSeq = ESCAPE_SEQUENCES[char];\n    result += !escapeSeq && isPrintable(char)\n      ? string[i]\n      : escapeSeq || encodeHex(char);\n  }\n\n  return result;\n}\n\nfunction writeFlowSequence(state, level, object) {\n  var _result = '',\n      _tag    = state.tag,\n      index,\n      length;\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    // Write only valid elements.\n    if (writeNode(state, level, object[index], false, false)) {\n      if (index !== 0) _result += ',' + (!state.condenseFlow ? ' ' : '');\n      _result += state.dump;\n    }\n  }\n\n  state.tag = _tag;\n  state.dump = '[' + _result + ']';\n}\n\nfunction writeBlockSequence(state, level, object, compact) {\n  var _result = '',\n      _tag    = state.tag,\n      index,\n      length;\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    // Write only valid elements.\n    if (writeNode(state, level + 1, object[index], true, true)) {\n      if (!compact || index !== 0) {\n        _result += generateNextLine(state, level);\n      }\n\n      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n        _result += '-';\n      } else {\n        _result += '- ';\n      }\n\n      _result += state.dump;\n    }\n  }\n\n  state.tag = _tag;\n  state.dump = _result || '[]'; // Empty sequence if no valid values.\n}\n\nfunction writeFlowMapping(state, level, object) {\n  var _result       = '',\n      _tag          = state.tag,\n      objectKeyList = Object.keys(object),\n      index,\n      length,\n      objectKey,\n      objectValue,\n      pairBuffer;\n\n  for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n    pairBuffer = state.condenseFlow ? '\"' : '';\n\n    if (index !== 0) pairBuffer += ', ';\n\n    objectKey = objectKeyList[index];\n    objectValue = object[objectKey];\n\n    if (!writeNode(state, level, objectKey, false, false)) {\n      continue; // Skip this pair because of invalid key;\n    }\n\n    if (state.dump.length > 1024) pairBuffer += '? ';\n\n    pairBuffer += state.dump + (state.condenseFlow ? '\"' : '') + ':' + (state.condenseFlow ? '' : ' ');\n\n    if (!writeNode(state, level, objectValue, false, false)) {\n      continue; // Skip this pair because of invalid value.\n    }\n\n    pairBuffer += state.dump;\n\n    // Both key and value are valid.\n    _result += pairBuffer;\n  }\n\n  state.tag = _tag;\n  state.dump = '{' + _result + '}';\n}\n\nfunction writeBlockMapping(state, level, object, compact) {\n  var _result       = '',\n      _tag          = state.tag,\n      objectKeyList = Object.keys(object),\n      index,\n      length,\n      objectKey,\n      objectValue,\n      explicitPair,\n      pairBuffer;\n\n  // Allow sorting keys so that the output file is deterministic\n  if (state.sortKeys === true) {\n    // Default sorting\n    objectKeyList.sort();\n  } else if (typeof state.sortKeys === 'function') {\n    // Custom sort function\n    objectKeyList.sort(state.sortKeys);\n  } else if (state.sortKeys) {\n    // Something is wrong\n    throw new YAMLException('sortKeys must be a boolean or a function');\n  }\n\n  for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n    pairBuffer = '';\n\n    if (!compact || index !== 0) {\n      pairBuffer += generateNextLine(state, level);\n    }\n\n    objectKey = objectKeyList[index];\n    objectValue = object[objectKey];\n\n    if (!writeNode(state, level + 1, objectKey, true, true, true)) {\n      continue; // Skip this pair because of invalid key.\n    }\n\n    explicitPair = (state.tag !== null && state.tag !== '?') ||\n                   (state.dump && state.dump.length > 1024);\n\n    if (explicitPair) {\n      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n        pairBuffer += '?';\n      } else {\n        pairBuffer += '? ';\n      }\n    }\n\n    pairBuffer += state.dump;\n\n    if (explicitPair) {\n      pairBuffer += generateNextLine(state, level);\n    }\n\n    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {\n      continue; // Skip this pair because of invalid value.\n    }\n\n    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n      pairBuffer += ':';\n    } else {\n      pairBuffer += ': ';\n    }\n\n    pairBuffer += state.dump;\n\n    // Both key and value are valid.\n    _result += pairBuffer;\n  }\n\n  state.tag = _tag;\n  state.dump = _result || '{}'; // Empty mapping if no valid pairs.\n}\n\nfunction detectType(state, object, explicit) {\n  var _result, typeList, index, length, type, style;\n\n  typeList = explicit ? state.explicitTypes : state.implicitTypes;\n\n  for (index = 0, length = typeList.length; index < length; index += 1) {\n    type = typeList[index];\n\n    if ((type.instanceOf  || type.predicate) &&\n        (!type.instanceOf || ((typeof object === 'object') && (object instanceof type.instanceOf))) &&\n        (!type.predicate  || type.predicate(object))) {\n\n      state.tag = explicit ? type.tag : '?';\n\n      if (type.represent) {\n        style = state.styleMap[type.tag] || type.defaultStyle;\n\n        if (_toString.call(type.represent) === '[object Function]') {\n          _result = type.represent(object, style);\n        } else if (_hasOwnProperty.call(type.represent, style)) {\n          _result = type.represent[style](object, style);\n        } else {\n          throw new YAMLException('!<' + type.tag + '> tag resolver accepts not \"' + style + '\" style');\n        }\n\n        state.dump = _result;\n      }\n\n      return true;\n    }\n  }\n\n  return false;\n}\n\n// Serializes `object` and writes it to global `result`.\n// Returns true on success, or false on invalid object.\n//\nfunction writeNode(state, level, object, block, compact, iskey) {\n  state.tag = null;\n  state.dump = object;\n\n  if (!detectType(state, object, false)) {\n    detectType(state, object, true);\n  }\n\n  var type = _toString.call(state.dump);\n\n  if (block) {\n    block = (state.flowLevel < 0 || state.flowLevel > level);\n  }\n\n  var objectOrArray = type === '[object Object]' || type === '[object Array]',\n      duplicateIndex,\n      duplicate;\n\n  if (objectOrArray) {\n    duplicateIndex = state.duplicates.indexOf(object);\n    duplicate = duplicateIndex !== -1;\n  }\n\n  if ((state.tag !== null && state.tag !== '?') || duplicate || (state.indent !== 2 && level > 0)) {\n    compact = false;\n  }\n\n  if (duplicate && state.usedDuplicates[duplicateIndex]) {\n    state.dump = '*ref_' + duplicateIndex;\n  } else {\n    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {\n      state.usedDuplicates[duplicateIndex] = true;\n    }\n    if (type === '[object Object]') {\n      if (block && (Object.keys(state.dump).length !== 0)) {\n        writeBlockMapping(state, level, state.dump, compact);\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + state.dump;\n        }\n      } else {\n        writeFlowMapping(state, level, state.dump);\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;\n        }\n      }\n    } else if (type === '[object Array]') {\n      var arrayLevel = (state.noArrayIndent && (level > 0)) ? level - 1 : level;\n      if (block && (state.dump.length !== 0)) {\n        writeBlockSequence(state, arrayLevel, state.dump, compact);\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + state.dump;\n        }\n      } else {\n        writeFlowSequence(state, arrayLevel, state.dump);\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;\n        }\n      }\n    } else if (type === '[object String]') {\n      if (state.tag !== '?') {\n        writeScalar(state, state.dump, level, iskey);\n      }\n    } else {\n      if (state.skipInvalid) return false;\n      throw new YAMLException('unacceptable kind of an object to dump ' + type);\n    }\n\n    if (state.tag !== null && state.tag !== '?') {\n      state.dump = '!<' + state.tag + '> ' + state.dump;\n    }\n  }\n\n  return true;\n}\n\nfunction getDuplicateReferences(object, state) {\n  var objects = [],\n      duplicatesIndexes = [],\n      index,\n      length;\n\n  inspectNode(object, objects, duplicatesIndexes);\n\n  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {\n    state.duplicates.push(objects[duplicatesIndexes[index]]);\n  }\n  state.usedDuplicates = new Array(length);\n}\n\nfunction inspectNode(object, objects, duplicatesIndexes) {\n  var objectKeyList,\n      index,\n      length;\n\n  if (object !== null && typeof object === 'object') {\n    index = objects.indexOf(object);\n    if (index !== -1) {\n      if (duplicatesIndexes.indexOf(index) === -1) {\n        duplicatesIndexes.push(index);\n      }\n    } else {\n      objects.push(object);\n\n      if (Array.isArray(object)) {\n        for (index = 0, length = object.length; index < length; index += 1) {\n          inspectNode(object[index], objects, duplicatesIndexes);\n        }\n      } else {\n        objectKeyList = Object.keys(object);\n\n        for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);\n        }\n      }\n    }\n  }\n}\n\nfunction dump(input, options) {\n  options = options || {};\n\n  var state = new State(options);\n\n  if (!state.noRefs) getDuplicateReferences(input, state);\n\n  if (writeNode(state, 0, input, true, true)) return state.dump + '\\n';\n\n  return '';\n}\n\nfunction safeDump(input, options) {\n  return dump(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));\n}\n\nmodule.exports.dump     = dump;\nmodule.exports.safeDump = safeDump;\n","'use strict';\n\n\nvar loader = require('./js-yaml/loader');\nvar dumper = require('./js-yaml/dumper');\n\n\nfunction deprecated(name) {\n  return function () {\n    throw new Error('Function ' + name + ' is deprecated and cannot be used.');\n  };\n}\n\n\nmodule.exports.Type                = require('./js-yaml/type');\nmodule.exports.Schema              = require('./js-yaml/schema');\nmodule.exports.FAILSAFE_SCHEMA     = require('./js-yaml/schema/failsafe');\nmodule.exports.JSON_SCHEMA         = require('./js-yaml/schema/json');\nmodule.exports.CORE_SCHEMA         = require('./js-yaml/schema/core');\nmodule.exports.DEFAULT_SAFE_SCHEMA = require('./js-yaml/schema/default_safe');\nmodule.exports.DEFAULT_FULL_SCHEMA = require('./js-yaml/schema/default_full');\nmodule.exports.load                = loader.load;\nmodule.exports.loadAll             = loader.loadAll;\nmodule.exports.safeLoad            = loader.safeLoad;\nmodule.exports.safeLoadAll         = loader.safeLoadAll;\nmodule.exports.dump                = dumper.dump;\nmodule.exports.safeDump            = dumper.safeDump;\nmodule.exports.YAMLException       = require('./js-yaml/exception');\n\n// Deprecated schema names from JS-YAML 2.0.x\nmodule.exports.MINIMAL_SCHEMA = require('./js-yaml/schema/failsafe');\nmodule.exports.SAFE_SCHEMA    = require('./js-yaml/schema/default_safe');\nmodule.exports.DEFAULT_SCHEMA = require('./js-yaml/schema/default_full');\n\n// Deprecated functions from JS-YAML 1.x.x\nmodule.exports.scan           = deprecated('scan');\nmodule.exports.parse          = deprecated('parse');\nmodule.exports.compose        = deprecated('compose');\nmodule.exports.addConstructor = deprecated('addConstructor');\n","const nonJsonTypes = [\"function\", \"symbol\", \"undefined\"];\nconst protectedProps = [\"constructor\", \"prototype\", \"__proto__\"];\nconst objectPrototype = Object.getPrototypeOf({});\n/**\n * Custom JSON serializer for Error objects.\n * Returns all built-in error properties, as well as extended properties.\n */\nexport function toJSON() {\n    // HACK: We have to cast the objects to `any` so we can use symbol indexers.\n    // see https://github.com/Microsoft/TypeScript/issues/1863\n    // tslint:disable: no-any no-unsafe-any\n    let pojo = {};\n    let error = this;\n    for (let key of getDeepKeys(error)) {\n        if (typeof key === \"string\") {\n            let value = error[key];\n            let type = typeof value;\n            if (!nonJsonTypes.includes(type)) {\n                pojo[key] = value;\n            }\n        }\n    }\n    // tslint:enable: no-any no-unsafe-any\n    return pojo;\n}\n/**\n * Returns own, inherited, enumerable, non-enumerable, string, and symbol keys of `obj`.\n * Does NOT return members of the base Object prototype, or the specified omitted keys.\n */\nexport function getDeepKeys(obj, omit = []) {\n    let keys = [];\n    // Crawl the prototype chain, finding all the string and symbol keys\n    while (obj && obj !== objectPrototype) {\n        keys = keys.concat(Object.getOwnPropertyNames(obj), Object.getOwnPropertySymbols(obj));\n        obj = Object.getPrototypeOf(obj);\n    }\n    // De-duplicate the list of keys\n    let uniqueKeys = new Set(keys);\n    // Remove any omitted keys\n    for (let key of omit.concat(protectedProps)) {\n        uniqueKeys.delete(key);\n    }\n    return uniqueKeys;\n}\n//# sourceMappingURL=to-json.js.map","import util from \"util\";\nimport { getDeepKeys } from \"./to-json\";\n// The `inspect()` method is actually a Symbol, not a string key.\n// https://nodejs.org/api/util.html#util_util_inspect_custom\nconst inspectMethod = util.inspect.custom || Symbol.for(\"nodejs.util.inspect.custom\");\n/**\n * Ono supports Node's `util.format()` formatting for error messages.\n *\n * @see https://nodejs.org/api/util.html#util_util_format_format_args\n */\nexport const formatter = util.format;\n/**\n * Adds an `inspect()` method to support Node's `util.inspect()` function.\n *\n * @see https://nodejs.org/api/util.html#util_util_inspect_custom\n */\nexport function addInspectMethod(newError) {\n    // @ts-ignore\n    newError[inspectMethod] = inspect;\n}\n/**\n * Returns a representation of the error for Node's `util.inspect()` method.\n *\n * @see https://nodejs.org/api/util.html#util_custom_inspection_functions_on_objects\n */\nfunction inspect() {\n    // HACK: We have to cast the objects to `any` so we can use symbol indexers.\n    // see https://github.com/Microsoft/TypeScript/issues/1863\n    // tslint:disable: no-any no-unsafe-any\n    let pojo = {};\n    let error = this;\n    for (let key of getDeepKeys(error)) {\n        let value = error[key];\n        pojo[key] = value;\n    }\n    // Don't include the `inspect()` method on the output object,\n    // otherwise it will cause `util.inspect()` to go into an infinite loop\n    // @ts-ignore\n    delete pojo[inspectMethod]; // tslint:disable-line: no-dynamic-delete\n    // tslint:enable: no-any no-unsafe-any\n    return pojo;\n}\n//# sourceMappingURL=isomorphic.node.js.map","const newline = /\\r?\\n/;\nconst onoCall = /\\bono\\b/;\n/**\n * Does a one-time determination of whether this JavaScript engine\n * supports lazy `Error.stack` properties.\n */\nexport const supportsLazyStack = Boolean(\n// ES5 property descriptors must be supported\nObject.getOwnPropertyDescriptor && Object.defineProperty &&\n    // Chrome on Android doesn't support lazy stacks :(\n    (typeof navigator === \"undefined\" || !/Android/.test(navigator.userAgent)));\n/**\n * Does this error have a lazy stack property?\n */\nexport function hasLazyStack(error) {\n    if (!supportsLazyStack) {\n        return false;\n    }\n    let descriptor = Object.getOwnPropertyDescriptor(error, \"stack\");\n    if (!descriptor) {\n        return false;\n    }\n    return typeof descriptor.get === \"function\";\n}\n/**\n * Appends the original `Error.stack` property to the new Error's stack.\n */\nexport function joinStacks(newError, originalError) {\n    let newStack = popStack(newError.stack);\n    let originalStack = originalError ? originalError.stack : undefined;\n    if (newStack && originalStack) {\n        return newStack + \"\\n\\n\" + originalStack;\n    }\n    else {\n        return newStack || originalStack;\n    }\n}\n/**\n * Calls `joinStacks` lazily, when the `Error.stack` property is accessed.\n */\nexport function lazyJoinStacks(newError, originalError) {\n    let descriptor = Object.getOwnPropertyDescriptor(newError, \"stack\");\n    if (originalError && descriptor && typeof descriptor.get === \"function\") {\n        Object.defineProperty(newError, \"stack\", {\n            get: () => {\n                let newStack = descriptor.get.apply(newError);\n                return joinStacks({ stack: newStack }, originalError);\n            },\n            enumerable: false,\n            configurable: true\n        });\n    }\n    else {\n        lazyPopStack(newError);\n    }\n}\n/**\n * Removes Ono from the stack, so that the stack starts at the original error location\n */\nfunction popStack(stack) {\n    if (stack === undefined) {\n        return undefined;\n    }\n    let lines = stack.split(newline);\n    if (lines.length < 2) {\n        // The stack only has one line, so there's nothing we can remove\n        return stack;\n    }\n    // Find the `ono` call in the stack, and remove it\n    for (let i = 0; i < lines.length; i++) {\n        let line = lines[i];\n        if (onoCall.test(line)) {\n            lines.splice(i, 1);\n            return lines.join(\"\\n\");\n        }\n    }\n    // If we get here, then the stack doesn't contain a call to `ono`.\n    // This may be due to minification or some optimization of the JS engine.\n    // So just return the stack as-is.\n    return stack;\n}\n/**\n * Calls `popStack` lazily, when the `Error.stack` property is accessed.\n */\nfunction lazyPopStack(error) {\n    let descriptor = Object.getOwnPropertyDescriptor(error, \"stack\");\n    if (descriptor && typeof descriptor.get === \"function\") {\n        Object.defineProperty(error, \"stack\", {\n            get: () => popStack(descriptor.get.apply(error)),\n            enumerable: false,\n            configurable: true\n        });\n    }\n}\n//# sourceMappingURL=stack.js.map","import { addInspectMethod } from \"./isomorphic.node\";\nimport { hasLazyStack, joinStacks, lazyJoinStacks } from \"./stack\";\nimport { getDeepKeys, toJSON } from \"./to-json\";\nconst protectedProps = [\"name\", \"message\", \"stack\"];\n/**\n * Extends the new error with the properties of the original error and the `props` object.\n *\n * @param newError - The error object to extend\n * @param originalError - The original error object, if any\n * @param props - Additional properties to add, if any\n */\nexport function extendError(newError, originalError, props) {\n    extendStack(newError, originalError);\n    // Copy properties from the original error\n    if (originalError && typeof originalError === \"object\") {\n        mergeErrors(newError, originalError);\n    }\n    // The default `toJSON` method doesn't output props like `name`, `message`, `stack`, etc.\n    // So replace it with one that outputs every property of the error.\n    newError.toJSON = toJSON;\n    // On Node.js, add support for the `util.inspect()` method\n    if (addInspectMethod) {\n        addInspectMethod(newError);\n    }\n    // Finally, copy custom properties that were specified by the user.\n    // These props OVERWRITE any previous props\n    if (props && typeof props === \"object\") {\n        Object.assign(newError, props);\n    }\n}\n/**\n * Extend the error stack to include its cause\n */\nfunction extendStack(newError, originalError) {\n    if (hasLazyStack(newError)) {\n        lazyJoinStacks(newError, originalError);\n    }\n    else {\n        newError.stack = joinStacks(newError, originalError);\n    }\n}\n/**\n * Merges properties of the original error with the new error.\n *\n * @param newError - The error object to extend\n * @param originalError - The original error object, if any\n */\nfunction mergeErrors(newError, originalError) {\n    // Get the original error's keys\n    // NOTE: We specifically exclude properties that we have already set on the new error.\n    // This is _especially_ important for the `stack` property, because this property has\n    // a lazy getter in some environments\n    let keys = getDeepKeys(originalError, protectedProps);\n    // HACK: We have to cast the errors to `any` so we can use symbol indexers.\n    // see https://github.com/Microsoft/TypeScript/issues/1863\n    // tslint:disable: no-any no-unsafe-any\n    let _newError = newError;\n    let _originalError = originalError;\n    for (let key of keys) {\n        if (_newError[key] === undefined) {\n            try {\n                _newError[key] = _originalError[key];\n            }\n            catch (e) {\n                // This property is read-only, so it can't be copied\n            }\n        }\n    }\n}\n//# sourceMappingURL=extend-error.js.map","import { extendError } from \"./extend-error\";\nconst onoConstructor = Ono;\nconst onoSingleton = Ono(Error);\nexport { onoConstructor as Ono, onoSingleton as ono };\n/**\n * Creates an `Ono` instance for a specifc error type.\n */\nfunction Ono(klass) {\n    // tslint:disable-next-line: no-shadowed-variable\n    return function ono(...args) {\n        let originalError;\n        let props;\n        let formatArgs;\n        let formattedMessage = \"\";\n        // Determine which arguments were actually specified\n        if (typeof args[0] === \"string\") {\n            formatArgs = args;\n        }\n        else if (typeof args[1] === \"string\") {\n            if (args[0] instanceof Error) {\n                originalError = args[0];\n            }\n            else {\n                props = args[0];\n            }\n            formatArgs = args.slice(1);\n        }\n        else {\n            originalError = args[0];\n            props = args[1];\n            formatArgs = args.slice(2);\n        }\n        // If there are any format arguments, then format the error message\n        if (formatArgs.length > 0) {\n            formattedMessage = onoSingleton.formatter.apply(undefined, formatArgs);\n        }\n        if (originalError && originalError.message) {\n            // The inner-error's message will be added to the new message\n            formattedMessage += (formattedMessage ? \" \\n\" : \"\") + originalError.message;\n        }\n        // @ts-ignore\n        // Create the new error\n        // NOTE: DON'T move this line to a separate function! We don't want to pollute the stack trace\n        let newError = new klass(formattedMessage);\n        // Extend the error with the properties of the original error and the `props` object\n        extendError(newError, originalError, props);\n        return newError;\n    };\n}\n//# sourceMappingURL=ono.js.map","import { formatter } from \"./isomorphic.node\";\nimport { Ono, ono } from \"./ono\";\nimport { toJSON as _toJSON } from \"./to-json\";\n// Create Ono instances for each of the JavaScript error types\nono.error = new Ono(Error);\nono.eval = new Ono(EvalError);\nono.range = new Ono(RangeError);\nono.reference = new Ono(ReferenceError);\nono.syntax = new Ono(SyntaxError);\nono.type = new Ono(TypeError);\nono.uri = new Ono(URIError);\n// Default to Node's `util.format()` functionality, but allow users to substitute their own\nono.formatter = formatter;\n/**\n * Returns an object containing all properties of the given Error object,\n * which can be used with `JSON.stringify()`.\n */\nOno.toJSON = function toJSON(error) {\n    return _toJSON.call(error);\n};\n// Export the Ono singleton and the Ono constructor as named exports\nexport { ono, Ono };\n// tslint:disable-next-line: no-default-export\nexport default ono;\n// CommonJS default export hack\nif (typeof module === \"object\" && typeof module.exports === \"object\") {\n    module.exports = Object.assign(module.exports.default, module.exports); // tslint:disable-line: no-unsafe-any\n}\n//# sourceMappingURL=index.js.map","/* eslint lines-around-comment: [2, {beforeBlockComment: false}] */\n\"use strict\";\n\nconst yaml = require(\"js-yaml\");\nconst { ono } = require(\"ono\");\n\n/**\n * Simple YAML parsing functions, similar to {@link JSON.parse} and {@link JSON.stringify}\n */\nmodule.exports = {\n  /**\n   * Parses a YAML string and returns the value.\n   *\n   * @param {string} text - The YAML string to be parsed\n   * @param {function} [reviver] - Not currently supported. Provided for consistency with {@link JSON.parse}\n   * @returns {*}\n   */\n  parse (text, reviver) {\n    try {\n      return yaml.safeLoad(text);\n    }\n    catch (e) {\n      if (e instanceof Error) {\n        throw e;\n      }\n      else {\n        // https://github.com/nodeca/js-yaml/issues/153\n        throw ono(e, e.message);\n      }\n    }\n  },\n\n  /**\n   * Converts a JavaScript value to a YAML string.\n   *\n   * @param   {*} value - The value to convert to YAML\n   * @param   {function|array} replacer - Not currently supported. Provided for consistency with {@link JSON.stringify}\n   * @param   {string|number} space - The number of spaces to use for indentation, or a string containing the number of spaces.\n   * @returns {string}\n   */\n  stringify (value, replacer, space) {\n    try {\n      let indent = (typeof space === \"string\" ? space.length : space) || 2;\n      return yaml.safeDump(value, { indent });\n    }\n    catch (e) {\n      if (e instanceof Error) {\n        throw e;\n      }\n      else {\n        // https://github.com/nodeca/js-yaml/issues/153\n        throw ono(e, e.message);\n      }\n    }\n  }\n};\n","\"use strict\";\n\nconst YAML = require(\"../util/yaml\");\n\nmodule.exports = {\n  /**\n   * The order that this parser will run, in relation to other parsers.\n   *\n   * @type {number}\n   */\n  order: 200,\n\n  /**\n   * Whether to allow \"empty\" files. This includes zero-byte files, as well as empty JSON objects.\n   *\n   * @type {boolean}\n   */\n  allowEmpty: true,\n\n  /**\n   * Determines whether this parser can parse a given file reference.\n   * Parsers that match will be tried, in order, until one successfully parses the file.\n   * Parsers that don't match will be skipped, UNLESS none of the parsers match, in which case\n   * every parser will be tried.\n   *\n   * @type {RegExp|string[]|function}\n   */\n  canParse: [\".yaml\", \".yml\", \".json\"],  // JSON is valid YAML\n\n  /**\n   * Parses the given file as YAML\n   *\n   * @param {object} file           - An object containing information about the referenced file\n   * @param {string} file.url       - The full URL of the referenced file\n   * @param {string} file.extension - The lowercased file extension (e.g. \".txt\", \".html\", etc.)\n   * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver\n   * @returns {Promise}\n   */\n  parse (file) {\n    return new Promise(((resolve, reject) => {\n      let data = file.data;\n      if (Buffer.isBuffer(data)) {\n        data = data.toString();\n      }\n\n      if (typeof data === \"string\") {\n        resolve(YAML.parse(data));\n      }\n      else {\n        // data is already a JavaScript value (object, array, number, null, NaN, etc.)\n        resolve(data);\n      }\n    }));\n  }\n};\n","\"use strict\";\n\nlet TEXT_REGEXP = /\\.(txt|htm|html|md|xml|js|min|map|css|scss|less|svg)$/i;\n\nmodule.exports = {\n  /**\n   * The order that this parser will run, in relation to other parsers.\n   *\n   * @type {number}\n   */\n  order: 300,\n\n  /**\n   * Whether to allow \"empty\" files (zero bytes).\n   *\n   * @type {boolean}\n   */\n  allowEmpty: true,\n\n  /**\n   * The encoding that the text is expected to be in.\n   *\n   * @type {string}\n   */\n  encoding: \"utf8\",\n\n  /**\n   * Determines whether this parser can parse a given file reference.\n   * Parsers that return true will be tried, in order, until one successfully parses the file.\n   * Parsers that return false will be skipped, UNLESS all parsers returned false, in which case\n   * every parser will be tried.\n   *\n   * @param {object} file           - An object containing information about the referenced file\n   * @param {string} file.url       - The full URL of the referenced file\n   * @param {string} file.extension - The lowercased file extension (e.g. \".txt\", \".html\", etc.)\n   * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver\n   * @returns {boolean}\n   */\n  canParse (file) {\n    // Use this parser if the file is a string or Buffer, and has a known text-based extension\n    return (typeof file.data === \"string\" || Buffer.isBuffer(file.data)) && TEXT_REGEXP.test(file.url);\n  },\n\n  /**\n   * Parses the given file as text\n   *\n   * @param {object} file           - An object containing information about the referenced file\n   * @param {string} file.url       - The full URL of the referenced file\n   * @param {string} file.extension - The lowercased file extension (e.g. \".txt\", \".html\", etc.)\n   * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver\n   * @returns {Promise<string>}\n   */\n  parse (file) {\n    if (typeof file.data === \"string\") {\n      return file.data;\n    }\n    else if (Buffer.isBuffer(file.data)) {\n      return file.data.toString(this.encoding);\n    }\n    else {\n      throw new Error(\"data is not text\");\n    }\n  }\n};\n","\"use strict\";\n\nlet BINARY_REGEXP = /\\.(jpeg|jpg|gif|png|bmp|ico)$/i;\n\nmodule.exports = {\n  /**\n   * The order that this parser will run, in relation to other parsers.\n   *\n   * @type {number}\n   */\n  order: 400,\n\n  /**\n   * Whether to allow \"empty\" files (zero bytes).\n   *\n   * @type {boolean}\n   */\n  allowEmpty: true,\n\n  /**\n   * Determines whether this parser can parse a given file reference.\n   * Parsers that return true will be tried, in order, until one successfully parses the file.\n   * Parsers that return false will be skipped, UNLESS all parsers returned false, in which case\n   * every parser will be tried.\n   *\n   * @param {object} file           - An object containing information about the referenced file\n   * @param {string} file.url       - The full URL of the referenced file\n   * @param {string} file.extension - The lowercased file extension (e.g. \".txt\", \".html\", etc.)\n   * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver\n   * @returns {boolean}\n   */\n  canParse (file) {\n    // Use this parser if the file is a Buffer, and has a known binary extension\n    return Buffer.isBuffer(file.data) && BINARY_REGEXP.test(file.url);\n  },\n\n  /**\n   * Parses the given data as a Buffer (byte array).\n   *\n   * @param {object} file           - An object containing information about the referenced file\n   * @param {string} file.url       - The full URL of the referenced file\n   * @param {string} file.extension - The lowercased file extension (e.g. \".txt\", \".html\", etc.)\n   * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver\n   * @returns {Promise<Buffer>}\n   */\n  parse (file) {\n    if (Buffer.isBuffer(file.data)) {\n      return file.data;\n    }\n    else {\n      // This will reject if data is anything other than a string or typed array\n      return Buffer.from(file.data);\n    }\n  }\n};\n","\"use strict\";\n\nlet isWindows = /^win/.test(process.platform),\n    forwardSlashPattern = /\\//g,\n    protocolPattern = /^(\\w{2,}):\\/\\//i,\n    url = module.exports;\n\n// RegExp patterns to URL-encode special characters in local filesystem paths\nlet urlEncodePatterns = [\n  /\\?/g, \"%3F\",\n  /\\#/g, \"%23\",\n];\n\n// RegExp patterns to URL-decode special characters for local filesystem paths\nlet urlDecodePatterns = [\n  /\\%23/g, \"#\",\n  /\\%24/g, \"$\",\n  /\\%26/g, \"&\",\n  /\\%2C/g, \",\",\n  /\\%40/g, \"@\"\n];\n\nexports.parse = require(\"url\").parse;\nexports.resolve = require(\"url\").resolve;\n\n/**\n * Returns the current working directory (in Node) or the current page URL (in browsers).\n *\n * @returns {string}\n */\nexports.cwd = function cwd () {\n  return process.browser ? location.href : process.cwd() + \"/\";\n};\n\n/**\n * Returns the protocol of the given URL, or `undefined` if it has no protocol.\n *\n * @param   {string} path\n * @returns {?string}\n */\nexports.getProtocol = function getProtocol (path) {\n  let match = protocolPattern.exec(path);\n  if (match) {\n    return match[1].toLowerCase();\n  }\n};\n\n/**\n * Returns the lowercased file extension of the given URL,\n * or an empty string if it has no extension.\n *\n * @param   {string} path\n * @returns {string}\n */\nexports.getExtension = function getExtension (path) {\n  let lastDot = path.lastIndexOf(\".\");\n  if (lastDot >= 0) {\n    return path.substr(lastDot).toLowerCase();\n  }\n  return \"\";\n};\n\n/**\n * Returns the hash (URL fragment), of the given path.\n * If there is no hash, then the root hash (\"#\") is returned.\n *\n * @param   {string} path\n * @returns {string}\n */\nexports.getHash = function getHash (path) {\n  let hashIndex = path.indexOf(\"#\");\n  if (hashIndex >= 0) {\n    return path.substr(hashIndex);\n  }\n  return \"#\";\n};\n\n/**\n * Removes the hash (URL fragment), if any, from the given path.\n *\n * @param   {string} path\n * @returns {string}\n */\nexports.stripHash = function stripHash (path) {\n  let hashIndex = path.indexOf(\"#\");\n  if (hashIndex >= 0) {\n    path = path.substr(0, hashIndex);\n  }\n  return path;\n};\n\n/**\n * Determines whether the given path is an HTTP(S) URL.\n *\n * @param   {string} path\n * @returns {boolean}\n */\nexports.isHttp = function isHttp (path) {\n  let protocol = url.getProtocol(path);\n  if (protocol === \"http\" || protocol === \"https\") {\n    return true;\n  }\n  else if (protocol === undefined) {\n    // There is no protocol.  If we're running in a browser, then assume it's HTTP.\n    return process.browser;\n  }\n  else {\n    // It's some other protocol, such as \"ftp://\", \"mongodb://\", etc.\n    return false;\n  }\n};\n\n/**\n * Determines whether the given path is a filesystem path.\n * This includes \"file://\" URLs.\n *\n * @param   {string} path\n * @returns {boolean}\n */\nexports.isFileSystemPath = function isFileSystemPath (path) {\n  if (process.browser) {\n    // We're running in a browser, so assume that all paths are URLs.\n    // This way, even relative paths will be treated as URLs rather than as filesystem paths\n    return false;\n  }\n\n  let protocol = url.getProtocol(path);\n  return protocol === undefined || protocol === \"file\";\n};\n\n/**\n * Converts a filesystem path to a properly-encoded URL.\n *\n * This is intended to handle situations where JSON Schema $Ref Parser is called\n * with a filesystem path that contains characters which are not allowed in URLs.\n *\n * @example\n * The following filesystem paths would be converted to the following URLs:\n *\n *    <\"!@#$%^&*+=?'>.json              ==>   %3C%22!@%23$%25%5E&*+=%3F\\'%3E.json\n *    C:\\\\My Documents\\\\File (1).json   ==>   C:/My%20Documents/File%20(1).json\n *    file://Project #42/file.json      ==>   file://Project%20%2342/file.json\n *\n * @param {string} path\n * @returns {string}\n */\nexports.fromFileSystemPath = function fromFileSystemPath (path) {\n  // Step 1: On Windows, replace backslashes with forward slashes,\n  // rather than encoding them as \"%5C\"\n  if (isWindows) {\n    path = path.replace(/\\\\/g, \"/\");\n  }\n\n  // Step 2: `encodeURI` will take care of MOST characters\n  path = encodeURI(path);\n\n  // Step 3: Manually encode characters that are not encoded by `encodeURI`.\n  // This includes characters such as \"#\" and \"?\", which have special meaning in URLs,\n  // but are just normal characters in a filesystem path.\n  for (let i = 0; i < urlEncodePatterns.length; i += 2) {\n    path = path.replace(urlEncodePatterns[i], urlEncodePatterns[i + 1]);\n  }\n\n  return path;\n};\n\n/**\n * Converts a URL to a local filesystem path.\n *\n * @param {string}  path\n * @param {boolean} [keepFileProtocol] - If true, then \"file://\" will NOT be stripped\n * @returns {string}\n */\nexports.toFileSystemPath = function toFileSystemPath (path, keepFileProtocol) {\n  // Step 1: `decodeURI` will decode characters such as Cyrillic characters, spaces, etc.\n  path = decodeURI(path);\n\n  // Step 2: Manually decode characters that are not decoded by `decodeURI`.\n  // This includes characters such as \"#\" and \"?\", which have special meaning in URLs,\n  // but are just normal characters in a filesystem path.\n  for (let i = 0; i < urlDecodePatterns.length; i += 2) {\n    path = path.replace(urlDecodePatterns[i], urlDecodePatterns[i + 1]);\n  }\n\n  // Step 3: If it's a \"file://\" URL, then format it consistently\n  // or convert it to a local filesystem path\n  let isFileUrl = path.substr(0, 7).toLowerCase() === \"file://\";\n  if (isFileUrl) {\n    // Strip-off the protocol, and the initial \"/\", if there is one\n    path = path[7] === \"/\" ? path.substr(8) : path.substr(7);\n\n    // insert a colon (\":\") after the drive letter on Windows\n    if (isWindows && path[1] === \"/\") {\n      path = path[0] + \":\" + path.substr(1);\n    }\n\n    if (keepFileProtocol) {\n      // Return the consistently-formatted \"file://\" URL\n      path = \"file:///\" + path;\n    }\n    else {\n      // Convert the \"file://\" URL to a local filesystem path.\n      // On Windows, it will start with something like \"C:/\".\n      // On Posix, it will start with \"/\"\n      isFileUrl = false;\n      path = isWindows ? path : \"/\" + path;\n    }\n  }\n\n  // Step 4: Normalize Windows paths (unless it's a \"file://\" URL)\n  if (isWindows && !isFileUrl) {\n    // Replace forward slashes with backslashes\n    path = path.replace(forwardSlashPattern, \"\\\\\");\n\n    // Capitalize the drive letter\n    if (path.substr(1, 2) === \":\\\\\") {\n      path = path[0].toUpperCase() + path.substr(1);\n    }\n  }\n\n  return path;\n};\n","\"use strict\";\nconst fs = require(\"fs\");\nconst { ono } = require(\"ono\");\nconst url = require(\"../util/url\");\n\nmodule.exports = {\n  /**\n   * The order that this resolver will run, in relation to other resolvers.\n   *\n   * @type {number}\n   */\n  order: 100,\n\n  /**\n   * Determines whether this resolver can read a given file reference.\n   * Resolvers that return true will be tried, in order, until one successfully resolves the file.\n   * Resolvers that return false will not be given a chance to resolve the file.\n   *\n   * @param {object} file           - An object containing information about the referenced file\n   * @param {string} file.url       - The full URL of the referenced file\n   * @param {string} file.extension - The lowercased file extension (e.g. \".txt\", \".html\", etc.)\n   * @returns {boolean}\n   */\n  canRead (file) {\n    return url.isFileSystemPath(file.url);\n  },\n\n  /**\n   * Reads the given file and returns its raw contents as a Buffer.\n   *\n   * @param {object} file           - An object containing information about the referenced file\n   * @param {string} file.url       - The full URL of the referenced file\n   * @param {string} file.extension - The lowercased file extension (e.g. \".txt\", \".html\", etc.)\n   * @returns {Promise<Buffer>}\n   */\n  read (file) {\n    return new Promise(((resolve, reject) => {\n      let path;\n      try {\n        path = url.toFileSystemPath(file.url);\n      }\n      catch (err) {\n        reject(ono.uri(err, `Malformed URI: ${file.url}`));\n      }\n\n      // console.log('Opening file: %s', path);\n\n      try {\n        fs.readFile(path, (err, data) => {\n          if (err) {\n            reject(ono(err, `Error opening file \"${path}\"`));\n          }\n          else {\n            resolve(data);\n          }\n        });\n      }\n      catch (err) {\n        reject(ono(err, `Error opening file \"${path}\"`));\n      }\n    }));\n  }\n};\n","\"use strict\";\n\nconst http = require(\"http\");\nconst https = require(\"https\");\nconst { ono } = require(\"ono\");\nconst url = require(\"../util/url\");\n\nmodule.exports = {\n  /**\n   * The order that this resolver will run, in relation to other resolvers.\n   *\n   * @type {number}\n   */\n  order: 200,\n\n  /**\n   * HTTP headers to send when downloading files.\n   *\n   * @example:\n   * {\n   *   \"User-Agent\": \"JSON Schema $Ref Parser\",\n   *   Accept: \"application/json\"\n   * }\n   *\n   * @type {object}\n   */\n  headers: null,\n\n  /**\n   * HTTP request timeout (in milliseconds).\n   *\n   * @type {number}\n   */\n  timeout: 5000, // 5 seconds\n\n  /**\n   * The maximum number of HTTP redirects to follow.\n   * To disable automatic following of redirects, set this to zero.\n   *\n   * @type {number}\n   */\n  redirects: 5,\n\n  /**\n   * The `withCredentials` option of XMLHttpRequest.\n   * Set this to `true` if you're downloading files from a CORS-enabled server that requires authentication\n   *\n   * @type {boolean}\n   */\n  withCredentials: false,\n\n  /**\n   * Determines whether this resolver can read a given file reference.\n   * Resolvers that return true will be tried in order, until one successfully resolves the file.\n   * Resolvers that return false will not be given a chance to resolve the file.\n   *\n   * @param {object} file           - An object containing information about the referenced file\n   * @param {string} file.url       - The full URL of the referenced file\n   * @param {string} file.extension - The lowercased file extension (e.g. \".txt\", \".html\", etc.)\n   * @returns {boolean}\n   */\n  canRead (file) {\n    return url.isHttp(file.url);\n  },\n\n  /**\n   * Reads the given URL and returns its raw contents as a Buffer.\n   *\n   * @param {object} file           - An object containing information about the referenced file\n   * @param {string} file.url       - The full URL of the referenced file\n   * @param {string} file.extension - The lowercased file extension (e.g. \".txt\", \".html\", etc.)\n   * @returns {Promise<Buffer>}\n   */\n  read (file) {\n    let u = url.parse(file.url);\n\n    if (process.browser && !u.protocol) {\n      // Use the protocol of the current page\n      u.protocol = url.parse(location.href).protocol;\n    }\n\n    return download(u, this);\n  }\n};\n\n/**\n * Downloads the given file.\n *\n * @param {Url|string} u        - The url to download (can be a parsed {@link Url} object)\n * @param {object} httpOptions  - The `options.resolve.http` object\n * @param {number} [redirects]  - The redirect URLs that have already been followed\n *\n * @returns {Promise<Buffer>}\n * The promise resolves with the raw downloaded data, or rejects if there is an HTTP error.\n */\nfunction download (u, httpOptions, redirects) {\n  return new Promise(((resolve, reject) => {\n    u = url.parse(u);\n    redirects = redirects || [];\n    redirects.push(u.href);\n\n    get(u, httpOptions)\n      .then((res) => {\n        if (res.statusCode >= 400) {\n          throw ono({ status: res.statusCode }, `HTTP ERROR ${res.statusCode}`);\n        }\n        else if (res.statusCode >= 300) {\n          if (redirects.length > httpOptions.redirects) {\n            reject(ono({ status: res.statusCode },\n              `Error downloading ${redirects[0]}. \\nToo many redirects: \\n  ${redirects.join(\" \\n  \")}`));\n          }\n          else if (!res.headers.location) {\n            throw ono({ status: res.statusCode }, `HTTP ${res.statusCode} redirect with no location header`);\n          }\n          else {\n            // console.log('HTTP %d redirect %s -> %s', res.statusCode, u.href, res.headers.location);\n            let redirectTo = url.resolve(u, res.headers.location);\n            download(redirectTo, httpOptions, redirects).then(resolve, reject);\n          }\n        }\n        else {\n          resolve(res.body || Buffer.alloc(0));\n        }\n      })\n      .catch((err) => {\n        reject(ono(err, `Error downloading ${u.href}`));\n      });\n  }));\n}\n\n/**\n * Sends an HTTP GET request.\n *\n * @param {Url} u - A parsed {@link Url} object\n * @param {object} httpOptions - The `options.resolve.http` object\n *\n * @returns {Promise<Response>}\n * The promise resolves with the HTTP Response object.\n */\nfunction get (u, httpOptions) {\n  return new Promise(((resolve, reject) => {\n    // console.log('GET', u.href);\n\n    let protocol = u.protocol === \"https:\" ? https : http;\n    let req = protocol.get({\n      hostname: u.hostname,\n      port: u.port,\n      path: u.path,\n      auth: u.auth,\n      protocol: u.protocol,\n      headers: httpOptions.headers || {},\n      withCredentials: httpOptions.withCredentials\n    });\n\n    if (typeof req.setTimeout === \"function\") {\n      req.setTimeout(httpOptions.timeout);\n    }\n\n    req.on(\"timeout\", () => {\n      req.abort();\n    });\n\n    req.on(\"error\", reject);\n\n    req.once(\"response\", (res) => {\n      res.body = Buffer.alloc(0);\n\n      res.on(\"data\", (data) => {\n        res.body = Buffer.concat([res.body, Buffer.from(data)]);\n      });\n\n      res.on(\"error\", reject);\n\n      res.on(\"end\", () => {\n        resolve(res);\n      });\n    });\n  }));\n}\n","/* eslint lines-around-comment: [2, {beforeBlockComment: false}] */\n\"use strict\";\n\nconst jsonParser = require(\"./parsers/json\");\nconst yamlParser = require(\"./parsers/yaml\");\nconst textParser = require(\"./parsers/text\");\nconst binaryParser = require(\"./parsers/binary\");\nconst fileResolver = require(\"./resolvers/file\");\nconst httpResolver = require(\"./resolvers/http\");\n\nmodule.exports = $RefParserOptions;\n\n/**\n * Options that determine how JSON schemas are parsed, resolved, and dereferenced.\n *\n * @param {object|$RefParserOptions} [options] - Overridden options\n * @constructor\n */\nfunction $RefParserOptions (options) {\n  merge(this, $RefParserOptions.defaults);\n  merge(this, options);\n}\n\n$RefParserOptions.defaults = {\n  /**\n   * Determines how different types of files will be parsed.\n   *\n   * You can add additional parsers of your own, replace an existing one with\n   * your own implemenation, or disable any parser by setting it to false.\n   */\n  parse: {\n    json: jsonParser,\n    yaml: yamlParser,\n    text: textParser,\n    binary: binaryParser,\n  },\n\n  /**\n   * Determines how JSON References will be resolved.\n   *\n   * You can add additional resolvers of your own, replace an existing one with\n   * your own implemenation, or disable any resolver by setting it to false.\n   */\n  resolve: {\n    file: fileResolver,\n    http: httpResolver,\n\n    /**\n     * Determines whether external $ref pointers will be resolved.\n     * If this option is disabled, then none of above resolvers will be called.\n     * Instead, external $ref pointers will simply be ignored.\n     *\n     * @type {boolean}\n     */\n    external: true,\n  },\n\n  /**\n   * Determines the types of JSON references that are allowed.\n   */\n  dereference: {\n    /**\n     * Dereference circular (recursive) JSON references?\n     * If false, then a {@link ReferenceError} will be thrown if a circular reference is found.\n     * If \"ignore\", then circular references will not be dereferenced.\n     *\n     * @type {boolean|string}\n     */\n    circular: true\n  },\n};\n\n/**\n * Merges the properties of the source object into the target object.\n *\n * @param {object} target - The object that we're populating\n * @param {?object} source - The options that are being merged\n * @returns {object}\n */\nfunction merge (target, source) {\n  if (isMergeable(source)) {\n    let keys = Object.keys(source);\n    for (let i = 0; i < keys.length; i++) {\n      let key = keys[i];\n      let sourceSetting = source[key];\n      let targetSetting = target[key];\n\n      if (isMergeable(sourceSetting)) {\n        // It's a nested object, so merge it recursively\n        target[key] = merge(targetSetting || {}, sourceSetting);\n      }\n      else if (sourceSetting !== undefined) {\n        // It's a scalar value, function, or array. No merging necessary. Just overwrite the target value.\n        target[key] = sourceSetting;\n      }\n    }\n  }\n  return target;\n}\n\n/**\n * Determines whether the given value can be merged,\n * or if it is a scalar value that should just override the target value.\n *\n * @param   {*}  val\n * @returns {Boolean}\n */\nfunction isMergeable (val) {\n  return val &&\n    (typeof val === \"object\") &&\n    !Array.isArray(val) &&\n    !(val instanceof RegExp) &&\n    !(val instanceof Date);\n}\n","\"use strict\";\n\nmodule.exports = Pointer;\n\nconst $Ref = require(\"./ref\");\nconst url = require(\"./util/url\");\nconst { ono } = require(\"ono\");\nconst slashes = /\\//g;\nconst tildes = /~/g;\nconst escapedSlash = /~1/g;\nconst escapedTilde = /~0/g;\n\n/**\n * This class represents a single JSON pointer and its resolved value.\n *\n * @param {$Ref} $ref\n * @param {string} path\n * @param {string} [friendlyPath] - The original user-specified path (used for error messages)\n * @constructor\n */\nfunction Pointer ($ref, path, friendlyPath) {\n  /**\n   * The {@link $Ref} object that contains this {@link Pointer} object.\n   * @type {$Ref}\n   */\n  this.$ref = $ref;\n\n  /**\n   * The file path or URL, containing the JSON pointer in the hash.\n   * This path is relative to the path of the main JSON schema file.\n   * @type {string}\n   */\n  this.path = path;\n\n  /**\n   * The original path or URL, used for error messages.\n   * @type {string}\n   */\n  this.originalPath = friendlyPath || path;\n\n  /**\n   * The value of the JSON pointer.\n   * Can be any JSON type, not just objects. Unknown file types are represented as Buffers (byte arrays).\n   * @type {?*}\n   */\n  this.value = undefined;\n\n  /**\n   * Indicates whether the pointer references itself.\n   * @type {boolean}\n   */\n  this.circular = false;\n\n  /**\n   * The number of indirect references that were traversed to resolve the value.\n   * Resolving a single pointer may require resolving multiple $Refs.\n   * @type {number}\n   */\n  this.indirections = 0;\n}\n\n/**\n * Resolves the value of a nested property within the given object.\n *\n * @param {*} obj - The object that will be crawled\n * @param {$RefParserOptions} options\n *\n * @returns {Pointer}\n * Returns a JSON pointer whose {@link Pointer#value} is the resolved value.\n * If resolving this value required resolving other JSON references, then\n * the {@link Pointer#$ref} and {@link Pointer#path} will reflect the resolution path\n * of the resolved value.\n */\nPointer.prototype.resolve = function (obj, options) {\n  let tokens = Pointer.parse(this.path);\n\n  // Crawl the object, one token at a time\n  this.value = obj;\n  for (let i = 0; i < tokens.length; i++) {\n    if (resolveIf$Ref(this, options)) {\n      // The $ref path has changed, so append the remaining tokens to the path\n      this.path = Pointer.join(this.path, tokens.slice(i));\n    }\n\n    let token = tokens[i];\n    if (this.value[token] === undefined) {\n      throw ono.syntax(`Error resolving $ref pointer \"${this.originalPath}\". \\nToken \"${token}\" does not exist.`);\n    }\n    else {\n      this.value = this.value[token];\n    }\n  }\n\n  // Resolve the final value\n  resolveIf$Ref(this, options);\n  return this;\n};\n\n/**\n * Sets the value of a nested property within the given object.\n *\n * @param {*} obj - The object that will be crawled\n * @param {*} value - the value to assign\n * @param {$RefParserOptions} options\n *\n * @returns {*}\n * Returns the modified object, or an entirely new object if the entire object is overwritten.\n */\nPointer.prototype.set = function (obj, value, options) {\n  let tokens = Pointer.parse(this.path);\n  let token;\n\n  if (tokens.length === 0) {\n    // There are no tokens, replace the entire object with the new value\n    this.value = value;\n    return value;\n  }\n\n  // Crawl the object, one token at a time\n  this.value = obj;\n  for (let i = 0; i < tokens.length - 1; i++) {\n    resolveIf$Ref(this, options);\n\n    token = tokens[i];\n    if (this.value && this.value[token] !== undefined) {\n      // The token exists\n      this.value = this.value[token];\n    }\n    else {\n      // The token doesn't exist, so create it\n      this.value = setValue(this, token, {});\n    }\n  }\n\n  // Set the value of the final token\n  resolveIf$Ref(this, options);\n  token = tokens[tokens.length - 1];\n  setValue(this, token, value);\n\n  // Return the updated object\n  return obj;\n};\n\n/**\n * Parses a JSON pointer (or a path containing a JSON pointer in the hash)\n * and returns an array of the pointer's tokens.\n * (e.g. \"schema.json#/definitions/person/name\" => [\"definitions\", \"person\", \"name\"])\n *\n * The pointer is parsed according to RFC 6901\n * {@link https://tools.ietf.org/html/rfc6901#section-3}\n *\n * @param {string} path\n * @returns {string[]}\n */\nPointer.parse = function (path) {\n  // Get the JSON pointer from the path's hash\n  let pointer = url.getHash(path).substr(1);\n\n  // If there's no pointer, then there are no tokens,\n  // so return an empty array\n  if (!pointer) {\n    return [];\n  }\n\n  // Split into an array\n  pointer = pointer.split(\"/\");\n\n  // Decode each part, according to RFC 6901\n  for (let i = 0; i < pointer.length; i++) {\n    pointer[i] = decodeURIComponent(pointer[i].replace(escapedSlash, \"/\").replace(escapedTilde, \"~\"));\n  }\n\n  if (pointer[0] !== \"\") {\n    throw ono.syntax(`Invalid $ref pointer \"${pointer}\". Pointers must begin with \"#/\"`);\n  }\n\n  return pointer.slice(1);\n};\n\n/**\n * Creates a JSON pointer path, by joining one or more tokens to a base path.\n *\n * @param {string} base - The base path (e.g. \"schema.json#/definitions/person\")\n * @param {string|string[]} tokens - The token(s) to append (e.g. [\"name\", \"first\"])\n * @returns {string}\n */\nPointer.join = function (base, tokens) {\n  // Ensure that the base path contains a hash\n  if (base.indexOf(\"#\") === -1) {\n    base += \"#\";\n  }\n\n  // Append each token to the base path\n  tokens = Array.isArray(tokens) ? tokens : [tokens];\n  for (let i = 0; i < tokens.length; i++) {\n    let token = tokens[i];\n    // Encode the token, according to RFC 6901\n    base += \"/\" + encodeURIComponent(token.replace(tildes, \"~0\").replace(slashes, \"~1\"));\n  }\n\n  return base;\n};\n\n/**\n * If the given pointer's {@link Pointer#value} is a JSON reference,\n * then the reference is resolved and {@link Pointer#value} is replaced with the resolved value.\n * In addition, {@link Pointer#path} and {@link Pointer#$ref} are updated to reflect the\n * resolution path of the new value.\n *\n * @param {Pointer} pointer\n * @param {$RefParserOptions} options\n * @returns {boolean} - Returns `true` if the resolution path changed\n */\nfunction resolveIf$Ref (pointer, options) {\n  // Is the value a JSON reference? (and allowed?)\n\n  if ($Ref.isAllowed$Ref(pointer.value, options)) {\n    let $refPath = url.resolve(pointer.path, pointer.value.$ref);\n\n    if ($refPath === pointer.path) {\n      // The value is a reference to itself, so there's nothing to do.\n      pointer.circular = true;\n    }\n    else {\n      let resolved = pointer.$ref.$refs._resolve($refPath, options);\n      pointer.indirections += resolved.indirections + 1;\n\n      if ($Ref.isExtended$Ref(pointer.value)) {\n        // This JSON reference \"extends\" the resolved value, rather than simply pointing to it.\n        // So the resolved path does NOT change.  Just the value does.\n        pointer.value = $Ref.dereference(pointer.value, resolved.value);\n        return false;\n      }\n      else {\n        // Resolve the reference\n        pointer.$ref = resolved.$ref;\n        pointer.path = resolved.path;\n        pointer.value = resolved.value;\n      }\n\n      return true;\n    }\n  }\n}\n\n/**\n * Sets the specified token value of the {@link Pointer#value}.\n *\n * The token is evaluated according to RFC 6901.\n * {@link https://tools.ietf.org/html/rfc6901#section-4}\n *\n * @param {Pointer} pointer - The JSON Pointer whose value will be modified\n * @param {string} token - A JSON Pointer token that indicates how to modify `obj`\n * @param {*} value - The value to assign\n * @returns {*} - Returns the assigned value\n */\nfunction setValue (pointer, token, value) {\n  if (pointer.value && typeof pointer.value === \"object\") {\n    if (token === \"-\" && Array.isArray(pointer.value)) {\n      pointer.value.push(value);\n    }\n    else {\n      pointer.value[token] = value;\n    }\n  }\n  else {\n    throw ono.syntax(`Error assigning $ref pointer \"${pointer.path}\". \\nCannot set \"${token}\" of a non-object.`);\n  }\n  return value;\n}\n","\"use strict\";\n\nmodule.exports = $Ref;\n\nconst Pointer = require(\"./pointer\");\n\n/**\n * This class represents a single JSON reference and its resolved value.\n *\n * @constructor\n */\nfunction $Ref () {\n  /**\n   * The file path or URL of the referenced file.\n   * This path is relative to the path of the main JSON schema file.\n   *\n   * This path does NOT contain document fragments (JSON pointers). It always references an ENTIRE file.\n   * Use methods such as {@link $Ref#get}, {@link $Ref#resolve}, and {@link $Ref#exists} to get\n   * specific JSON pointers within the file.\n   *\n   * @type {string}\n   */\n  this.path = undefined;\n\n  /**\n   * The resolved value of the JSON reference.\n   * Can be any JSON type, not just objects. Unknown file types are represented as Buffers (byte arrays).\n   * @type {?*}\n   */\n  this.value = undefined;\n\n  /**\n   * The {@link $Refs} object that contains this {@link $Ref} object.\n   * @type {$Refs}\n   */\n  this.$refs = undefined;\n\n  /**\n   * Indicates the type of {@link $Ref#path} (e.g. \"file\", \"http\", etc.)\n   * @type {?string}\n   */\n  this.pathType = undefined;\n}\n\n/**\n * Determines whether the given JSON reference exists within this {@link $Ref#value}.\n *\n * @param {string} path - The full path being resolved, optionally with a JSON pointer in the hash\n * @param {$RefParserOptions} options\n * @returns {boolean}\n */\n$Ref.prototype.exists = function (path, options) {\n  try {\n    this.resolve(path, options);\n    return true;\n  }\n  catch (e) {\n    return false;\n  }\n};\n\n/**\n * Resolves the given JSON reference within this {@link $Ref#value} and returns the resolved value.\n *\n * @param {string} path - The full path being resolved, optionally with a JSON pointer in the hash\n * @param {$RefParserOptions} options\n * @returns {*} - Returns the resolved value\n */\n$Ref.prototype.get = function (path, options) {\n  return this.resolve(path, options).value;\n};\n\n/**\n * Resolves the given JSON reference within this {@link $Ref#value}.\n *\n * @param {string} path - The full path being resolved, optionally with a JSON pointer in the hash\n * @param {$RefParserOptions} options\n * @param {string} [friendlyPath] - The original user-specified path (used for error messages)\n * @returns {Pointer}\n */\n$Ref.prototype.resolve = function (path, options, friendlyPath) {\n  let pointer = new Pointer(this, path, friendlyPath);\n  return pointer.resolve(this.value, options);\n};\n\n/**\n * Sets the value of a nested property within this {@link $Ref#value}.\n * If the property, or any of its parents don't exist, they will be created.\n *\n * @param {string} path - The full path of the property to set, optionally with a JSON pointer in the hash\n * @param {*} value - The value to assign\n */\n$Ref.prototype.set = function (path, value) {\n  let pointer = new Pointer(this, path);\n  this.value = pointer.set(this.value, value);\n};\n\n/**\n * Determines whether the given value is a JSON reference.\n *\n * @param {*} value - The value to inspect\n * @returns {boolean}\n */\n$Ref.is$Ref = function (value) {\n  return value && typeof value === \"object\" && typeof value.$ref === \"string\" && value.$ref.length > 0;\n};\n\n/**\n * Determines whether the given value is an external JSON reference.\n *\n * @param {*} value - The value to inspect\n * @returns {boolean}\n */\n$Ref.isExternal$Ref = function (value) {\n  return $Ref.is$Ref(value) && value.$ref[0] !== \"#\";\n};\n\n/**\n * Determines whether the given value is a JSON reference, and whether it is allowed by the options.\n * For example, if it references an external file, then options.resolve.external must be true.\n *\n * @param {*} value - The value to inspect\n * @param {$RefParserOptions} options\n * @returns {boolean}\n */\n$Ref.isAllowed$Ref = function (value, options) {\n  if ($Ref.is$Ref(value)) {\n    if (value.$ref.substr(0, 2) === \"#/\" || value.$ref === \"#\") {\n      // It's a JSON Pointer reference, which is always allowed\n      return true;\n    }\n    else if (value.$ref[0] !== \"#\" && (!options || options.resolve.external)) {\n      // It's an external reference, which is allowed by the options\n      return true;\n    }\n  }\n};\n\n/**\n * Determines whether the given value is a JSON reference that \"extends\" its resolved value.\n * That is, it has extra properties (in addition to \"$ref\"), so rather than simply pointing to\n * an existing value, this $ref actually creates a NEW value that is a shallow copy of the resolved\n * value, plus the extra properties.\n *\n * @example:\n *  {\n *    person: {\n *      properties: {\n *        firstName: { type: string }\n *        lastName: { type: string }\n *      }\n *    }\n *    employee: {\n *      properties: {\n *        $ref: #/person/properties\n *        salary: { type: number }\n *      }\n *    }\n *  }\n *\n *  In this example, \"employee\" is an extended $ref, since it extends \"person\" with an additional\n *  property (salary).  The result is a NEW value that looks like this:\n *\n *  {\n *    properties: {\n *      firstName: { type: string }\n *      lastName: { type: string }\n *      salary: { type: number }\n *    }\n *  }\n *\n * @param {*} value - The value to inspect\n * @returns {boolean}\n */\n$Ref.isExtended$Ref = function (value) {\n  return $Ref.is$Ref(value) && Object.keys(value).length > 1;\n};\n\n/**\n * Returns the resolved value of a JSON Reference.\n * If necessary, the resolved value is merged with the JSON Reference to create a new object\n *\n * @example:\n *  {\n *    person: {\n *      properties: {\n *        firstName: { type: string }\n *        lastName: { type: string }\n *      }\n *    }\n *    employee: {\n *      properties: {\n *        $ref: #/person/properties\n *        salary: { type: number }\n *      }\n *    }\n *  }\n *\n *  When \"person\" and \"employee\" are merged, you end up with the following object:\n *\n *  {\n *    properties: {\n *      firstName: { type: string }\n *      lastName: { type: string }\n *      salary: { type: number }\n *    }\n *  }\n *\n * @param {object} $ref - The JSON reference object (the one with the \"$ref\" property)\n * @param {*} resolvedValue - The resolved value, which can be any type\n * @returns {*} - Returns the dereferenced value\n */\n$Ref.dereference = function ($ref, resolvedValue) {\n  if (resolvedValue && typeof resolvedValue === \"object\" && $Ref.isExtended$Ref($ref)) {\n    let merged = {};\n    for (let key of Object.keys($ref)) {\n      if (key !== \"$ref\") {\n        merged[key] = $ref[key];\n      }\n    }\n\n    for (let key of Object.keys(resolvedValue)) {\n      if (!(key in merged)) {\n        merged[key] = resolvedValue[key];\n      }\n    }\n\n    return merged;\n  }\n  else {\n    // Completely replace the original reference with the resolved value\n    return resolvedValue;\n  }\n};\n","\"use strict\";\n\nconst { ono } = require(\"ono\");\nconst $Ref = require(\"./ref\");\nconst url = require(\"./util/url\");\n\nmodule.exports = $Refs;\n\n/**\n * This class is a map of JSON references and their resolved values.\n */\nfunction $Refs () {\n  /**\n   * Indicates whether the schema contains any circular references.\n   *\n   * @type {boolean}\n   */\n  this.circular = false;\n\n  /**\n   * A map of paths/urls to {@link $Ref} objects\n   *\n   * @type {object}\n   * @protected\n   */\n  this._$refs = {};\n\n  /**\n   * The {@link $Ref} object that is the root of the JSON schema.\n   *\n   * @type {$Ref}\n   * @protected\n   */\n  this._root$Ref = null;\n}\n\n/**\n * Returns the paths of all the files/URLs that are referenced by the JSON schema,\n * including the schema itself.\n *\n * @param {...string|string[]} [types] - Only return paths of the given types (\"file\", \"http\", etc.)\n * @returns {string[]}\n */\n$Refs.prototype.paths = function (types) {\n  let paths = getPaths(this._$refs, arguments);\n  return paths.map((path) => {\n    return path.decoded;\n  });\n};\n\n/**\n * Returns the map of JSON references and their resolved values.\n *\n * @param {...string|string[]} [types] - Only return references of the given types (\"file\", \"http\", etc.)\n * @returns {object}\n */\n$Refs.prototype.values = function (types) {\n  let $refs = this._$refs;\n  let paths = getPaths($refs, arguments);\n  return paths.reduce((obj, path) => {\n    obj[path.decoded] = $refs[path.encoded].value;\n    return obj;\n  }, {});\n};\n\n/**\n * Returns a POJO (plain old JavaScript object) for serialization as JSON.\n *\n * @returns {object}\n */\n$Refs.prototype.toJSON = $Refs.prototype.values;\n\n/**\n * Determines whether the given JSON reference exists.\n *\n * @param {string} path - The path being resolved, optionally with a JSON pointer in the hash\n * @param {$RefParserOptions} [options]\n * @returns {boolean}\n */\n$Refs.prototype.exists = function (path, options) {\n  try {\n    this._resolve(path, options);\n    return true;\n  }\n  catch (e) {\n    return false;\n  }\n};\n\n/**\n * Resolves the given JSON reference and returns the resolved value.\n *\n * @param {string} path - The path being resolved, with a JSON pointer in the hash\n * @param {$RefParserOptions} [options]\n * @returns {*} - Returns the resolved value\n */\n$Refs.prototype.get = function (path, options) {\n  return this._resolve(path, options).value;\n};\n\n/**\n * Sets the value of a nested property within this {@link $Ref#value}.\n * If the property, or any of its parents don't exist, they will be created.\n *\n * @param {string} path - The path of the property to set, optionally with a JSON pointer in the hash\n * @param {*} value - The value to assign\n */\n$Refs.prototype.set = function (path, value) {\n  let absPath = url.resolve(this._root$Ref.path, path);\n  let withoutHash = url.stripHash(absPath);\n  let $ref = this._$refs[withoutHash];\n\n  if (!$ref) {\n    throw ono(`Error resolving $ref pointer \"${path}\". \\n\"${withoutHash}\" not found.`);\n  }\n\n  $ref.set(absPath, value);\n};\n\n/**\n * Creates a new {@link $Ref} object and adds it to this {@link $Refs} object.\n *\n * @param {string} path  - The file path or URL of the referenced file\n */\n$Refs.prototype._add = function (path) {\n  let withoutHash = url.stripHash(path);\n\n  let $ref = new $Ref();\n  $ref.path = withoutHash;\n  $ref.$refs = this;\n\n  this._$refs[withoutHash] = $ref;\n  this._root$Ref = this._root$Ref || $ref;\n\n  return $ref;\n};\n\n/**\n * Resolves the given JSON reference.\n *\n * @param {string} path - The path being resolved, optionally with a JSON pointer in the hash\n * @param {$RefParserOptions} [options]\n * @returns {Pointer}\n * @protected\n */\n$Refs.prototype._resolve = function (path, options) {\n  let absPath = url.resolve(this._root$Ref.path, path);\n  let withoutHash = url.stripHash(absPath);\n  let $ref = this._$refs[withoutHash];\n\n  if (!$ref) {\n    throw ono(`Error resolving $ref pointer \"${path}\". \\n\"${withoutHash}\" not found.`);\n  }\n\n  return $ref.resolve(absPath, options, path);\n};\n\n/**\n * Returns the specified {@link $Ref} object, or undefined.\n *\n * @param {string} path - The path being resolved, optionally with a JSON pointer in the hash\n * @returns {$Ref|undefined}\n * @protected\n */\n$Refs.prototype._get$Ref = function (path) {\n  path = url.resolve(this._root$Ref.path, path);\n  let withoutHash = url.stripHash(path);\n  return this._$refs[withoutHash];\n};\n\n/**\n * Returns the encoded and decoded paths keys of the given object.\n *\n * @param {object} $refs - The object whose keys are URL-encoded paths\n * @param {...string|string[]} [types] - Only return paths of the given types (\"file\", \"http\", etc.)\n * @returns {object[]}\n */\nfunction getPaths ($refs, types) {\n  let paths = Object.keys($refs);\n\n  // Filter the paths by type\n  types = Array.isArray(types[0]) ? types[0] : Array.prototype.slice.call(types);\n  if (types.length > 0 && types[0]) {\n    paths = paths.filter((key) => {\n      return types.indexOf($refs[key].pathType) !== -1;\n    });\n  }\n\n  // Decode local filesystem paths\n  return paths.map((path) => {\n    return {\n      encoded: path,\n      decoded: $refs[path].pathType === \"file\" ? url.toFileSystemPath(path, true) : path\n    };\n  });\n}\n","\"use strict\";\n\n/**\n * Returns the given plugins as an array, rather than an object map.\n * All other methods in this module expect an array of plugins rather than an object map.\n *\n * @param  {object} plugins - A map of plugin objects\n * @return {object[]}\n */\nexports.all = function (plugins) {\n  return Object.keys(plugins)\n    .filter((key) => {\n      return typeof plugins[key] === \"object\";\n    })\n    .map((key) => {\n      plugins[key].name = key;\n      return plugins[key];\n    });\n};\n\n/**\n * Filters the given plugins, returning only the ones return `true` for the given method.\n *\n * @param  {object[]} plugins - An array of plugin objects\n * @param  {string}   method  - The name of the filter method to invoke for each plugin\n * @param  {object}   file    - A file info object, which will be passed to each method\n * @return {object[]}\n */\nexports.filter = function (plugins, method, file) {\n  return plugins\n    .filter((plugin) => {\n      return !!getResult(plugin, method, file);\n    });\n};\n\n/**\n * Sorts the given plugins, in place, by their `order` property.\n *\n * @param {object[]} plugins - An array of plugin objects\n * @returns {object[]}\n */\nexports.sort = function (plugins) {\n  for (let plugin of plugins) {\n    plugin.order = plugin.order || Number.MAX_SAFE_INTEGER;\n  }\n\n  return plugins.sort((a, b) => { return a.order - b.order; });\n};\n\n/**\n * Runs the specified method of the given plugins, in order, until one of them returns a successful result.\n * Each method can return a synchronous value, a Promise, or call an error-first callback.\n * If the promise resolves successfully, or the callback is called without an error, then the result\n * is immediately returned and no further plugins are called.\n * If the promise rejects, or the callback is called with an error, then the next plugin is called.\n * If ALL plugins fail, then the last error is thrown.\n *\n * @param {object[]}  plugins - An array of plugin objects\n * @param {string}    method  - The name of the method to invoke for each plugin\n * @param {object}    file    - A file info object, which will be passed to each method\n * @returns {Promise}\n */\nexports.run = function (plugins, method, file, $refs) {\n  let plugin, lastError, index = 0;\n\n  return new Promise(((resolve, reject) => {\n    runNextPlugin();\n\n    function runNextPlugin () {\n      plugin = plugins[index++];\n      if (!plugin) {\n        // There are no more functions, so re-throw the last error\n        return reject(lastError);\n      }\n\n      try {\n        // console.log('  %s', plugin.name);\n        let result = getResult(plugin, method, file, callback, $refs);\n        if (result && typeof result.then === \"function\") {\n          // A promise was returned\n          result.then(onSuccess, onError);\n        }\n        else if (result !== undefined) {\n          // A synchronous result was returned\n          onSuccess(result);\n        }\n        // else { the callback will be called }\n      }\n      catch (e) {\n        onError(e);\n      }\n    }\n\n    function callback (err, result) {\n      if (err) {\n        onError(err);\n      }\n      else {\n        onSuccess(result);\n      }\n    }\n\n    function onSuccess (result) {\n      // console.log('    success');\n      resolve({\n        plugin,\n        result\n      });\n    }\n\n    function onError (err) {\n      // console.log('    %s', err.message || err);\n      lastError = err;\n      runNextPlugin();\n    }\n  }));\n};\n\n/**\n * Returns the value of the given property.\n * If the property is a function, then the result of the function is returned.\n * If the value is a RegExp, then it will be tested against the file URL.\n * If the value is an aray, then it will be compared against the file extension.\n *\n * @param   {object}   obj        - The object whose property/method is called\n * @param   {string}   prop       - The name of the property/method to invoke\n * @param   {object}   file       - A file info object, which will be passed to the method\n * @param   {function} [callback] - A callback function, which will be passed to the method\n * @returns {*}\n */\nfunction getResult (obj, prop, file, callback, $refs) {\n  let value = obj[prop];\n\n  if (typeof value === \"function\") {\n    return value.apply(obj, [file, callback, $refs]);\n  }\n\n  if (!callback) {\n    // The synchronous plugin functions (canParse and canRead)\n    // allow a \"shorthand\" syntax, where the user can match\n    // files by RegExp or by file extension.\n    if (value instanceof RegExp) {\n      return value.test(file.url);\n    }\n    else if (typeof value === \"string\") {\n      return value === file.extension;\n    }\n    else if (Array.isArray(value)) {\n      return value.indexOf(file.extension) !== -1;\n    }\n  }\n\n  return value;\n}\n","\"use strict\";\n\nconst { ono } = require(\"ono\");\nconst url = require(\"./util/url\");\nconst plugins = require(\"./util/plugins\");\n\nmodule.exports = parse;\n\n/**\n * Reads and parses the specified file path or URL.\n *\n * @param {string} path - This path MUST already be resolved, since `read` doesn't know the resolution context\n * @param {$Refs} $refs\n * @param {$RefParserOptions} options\n *\n * @returns {Promise}\n * The promise resolves with the parsed file contents, NOT the raw (Buffer) contents.\n */\nasync function parse (path, $refs, options) {\n  try {\n    // Remove the URL fragment, if any\n    path = url.stripHash(path);\n\n    // Add a new $Ref for this file, even though we don't have the value yet.\n    // This ensures that we don't simultaneously read & parse the same file multiple times\n    let $ref = $refs._add(path);\n\n    // This \"file object\" will be passed to all resolvers and parsers.\n    let file = {\n      url: path,\n      extension: url.getExtension(path),\n    };\n\n    // Read the file and then parse the data\n    const resolver = await readFile(file, options, $refs);\n    $ref.pathType = resolver.plugin.name;\n    file.data = resolver.result;\n\n    const parser = await parseFile(file, options, $refs);\n    $ref.value = parser.result;\n\n    return parser.result;\n  }\n  catch (e) {\n    return Promise.reject(e);\n  }\n}\n\n/**\n * Reads the given file, using the configured resolver plugins\n *\n * @param {object} file           - An object containing information about the referenced file\n * @param {string} file.url       - The full URL of the referenced file\n * @param {string} file.extension - The lowercased file extension (e.g. \".txt\", \".html\", etc.)\n * @param {$RefParserOptions} options\n *\n * @returns {Promise}\n * The promise resolves with the raw file contents and the resolver that was used.\n */\nfunction readFile (file, options, $refs) {\n  return new Promise(((resolve, reject) => {\n    // console.log('Reading %s', file.url);\n\n    // Find the resolvers that can read this file\n    let resolvers = plugins.all(options.resolve);\n    resolvers = plugins.filter(resolvers, \"canRead\", file);\n\n    // Run the resolvers, in order, until one of them succeeds\n    plugins.sort(resolvers);\n    plugins.run(resolvers, \"read\", file, $refs)\n      .then(resolve, onError);\n\n    function onError (err) {\n      // Throw the original error, if it's one of our own (user-friendly) errors.\n      // Otherwise, throw a generic, friendly error.\n      if (err && !(err instanceof SyntaxError)) {\n        reject(err);\n      }\n      else {\n        reject(ono.syntax(`Unable to resolve $ref pointer \"${file.url}\"`));\n      }\n    }\n  }));\n}\n\n/**\n * Parses the given file's contents, using the configured parser plugins.\n *\n * @param {object} file           - An object containing information about the referenced file\n * @param {string} file.url       - The full URL of the referenced file\n * @param {string} file.extension - The lowercased file extension (e.g. \".txt\", \".html\", etc.)\n * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver\n * @param {$RefParserOptions} options\n *\n * @returns {Promise}\n * The promise resolves with the parsed file contents and the parser that was used.\n */\nfunction parseFile (file, options, $refs) {\n  return new Promise(((resolve, reject) => {\n    // console.log('Parsing %s', file.url);\n\n    // Find the parsers that can read this file type.\n    // If none of the parsers are an exact match for this file, then we'll try ALL of them.\n    // This handles situations where the file IS a supported type, just with an unknown extension.\n    let allParsers = plugins.all(options.parse);\n    let filteredParsers = plugins.filter(allParsers, \"canParse\", file);\n    let parsers = filteredParsers.length > 0 ? filteredParsers : allParsers;\n\n    // Run the parsers, in order, until one of them succeeds\n    plugins.sort(parsers);\n    plugins.run(parsers, \"parse\", file, $refs)\n      .then(onParsed, onError);\n\n    function onParsed (parser) {\n      if (!parser.plugin.allowEmpty && isEmpty(parser.result)) {\n        reject(ono.syntax(`Error parsing \"${file.url}\" as ${parser.plugin.name}. \\nParsed value is empty`));\n      }\n      else {\n        resolve(parser);\n      }\n    }\n\n    function onError (err) {\n      if (err) {\n        err = err instanceof Error ? err : new Error(err);\n        reject(ono.syntax(err, `Error parsing ${file.url}`));\n      }\n      else {\n        reject(ono.syntax(`Unable to parse ${file.url}`));\n      }\n    }\n  }));\n}\n\n/**\n * Determines whether the parsed value is \"empty\".\n *\n * @param {*} value\n * @returns {boolean}\n */\nfunction isEmpty (value) {\n  return value === undefined ||\n    (typeof value === \"object\" && Object.keys(value).length === 0) ||\n    (typeof value === \"string\" && value.trim().length === 0) ||\n    (Buffer.isBuffer(value) && value.length === 0);\n}\n","\"use strict\";\n\nconst Options = require(\"./options\");\n\nmodule.exports = normalizeArgs;\n\n/**\n * Normalizes the given arguments, accounting for optional args.\n *\n * @param {Arguments} args\n * @returns {object}\n */\nfunction normalizeArgs (args) {\n  let path, schema, options, callback;\n  args = Array.prototype.slice.call(args);\n\n  if (typeof args[args.length - 1] === \"function\") {\n    // The last parameter is a callback function\n    callback = args.pop();\n  }\n\n  if (typeof args[0] === \"string\") {\n    // The first parameter is the path\n    path = args[0];\n    if (typeof args[2] === \"object\") {\n      // The second parameter is the schema, and the third parameter is the options\n      schema = args[1];\n      options = args[2];\n    }\n    else {\n      // The second parameter is the options\n      schema = undefined;\n      options = args[1];\n    }\n  }\n  else {\n    // The first parameter is the schema\n    path = \"\";\n    schema = args[0];\n    options = args[1];\n  }\n\n  if (!(options instanceof Options)) {\n    options = new Options(options);\n  }\n\n  return {\n    path,\n    schema,\n    options,\n    callback\n  };\n}\n","\"use strict\";\n\nconst $Ref = require(\"./ref\");\nconst Pointer = require(\"./pointer\");\nconst parse = require(\"./parse\");\nconst url = require(\"./util/url\");\n\nmodule.exports = resolveExternal;\n\n/**\n * Crawls the JSON schema, finds all external JSON references, and resolves their values.\n * This method does not mutate the JSON schema. The resolved values are added to {@link $RefParser#$refs}.\n *\n * NOTE: We only care about EXTERNAL references here. INTERNAL references are only relevant when dereferencing.\n *\n * @param {$RefParser} parser\n * @param {$RefParserOptions} options\n *\n * @returns {Promise}\n * The promise resolves once all JSON references in the schema have been resolved,\n * including nested references that are contained in externally-referenced files.\n */\nfunction resolveExternal (parser, options) {\n  if (!options.resolve.external) {\n    // Nothing to resolve, so exit early\n    return Promise.resolve();\n  }\n\n  try {\n    // console.log('Resolving $ref pointers in %s', parser.$refs._root$Ref.path);\n    let promises = crawl(parser.schema, parser.$refs._root$Ref.path + \"#\", parser.$refs, options);\n    return Promise.all(promises);\n  }\n  catch (e) {\n    return Promise.reject(e);\n  }\n}\n\n/**\n * Recursively crawls the given value, and resolves any external JSON references.\n *\n * @param {*} obj - The value to crawl. If it's not an object or array, it will be ignored.\n * @param {string} path - The full path of `obj`, possibly with a JSON Pointer in the hash\n * @param {$Refs} $refs\n * @param {$RefParserOptions} options\n *\n * @returns {Promise[]}\n * Returns an array of promises. There will be one promise for each JSON reference in `obj`.\n * If `obj` does not contain any JSON references, then the array will be empty.\n * If any of the JSON references point to files that contain additional JSON references,\n * then the corresponding promise will internally reference an array of promises.\n */\nfunction crawl (obj, path, $refs, options) {\n  let promises = [];\n\n  if (obj && typeof obj === \"object\") {\n    if ($Ref.isExternal$Ref(obj)) {\n      promises.push(resolve$Ref(obj, path, $refs, options));\n    }\n    else {\n      for (let key of Object.keys(obj)) {\n        let keyPath = Pointer.join(path, key);\n        let value = obj[key];\n\n        if ($Ref.isExternal$Ref(value)) {\n          promises.push(resolve$Ref(value, keyPath, $refs, options));\n        }\n        else {\n          promises = promises.concat(crawl(value, keyPath, $refs, options));\n        }\n      }\n    }\n  }\n\n  return promises;\n}\n\n/**\n * Resolves the given JSON Reference, and then crawls the resulting value.\n *\n * @param {{$ref: string}} $ref - The JSON Reference to resolve\n * @param {string} path - The full path of `$ref`, possibly with a JSON Pointer in the hash\n * @param {$Refs} $refs\n * @param {$RefParserOptions} options\n *\n * @returns {Promise}\n * The promise resolves once all JSON references in the object have been resolved,\n * including nested references that are contained in externally-referenced files.\n */\nasync function resolve$Ref ($ref, path, $refs, options) {\n  // console.log('Resolving $ref pointer \"%s\" at %s', $ref.$ref, path);\n\n  let resolvedPath = url.resolve(path, $ref.$ref);\n  let withoutHash = url.stripHash(resolvedPath);\n\n  // Do we already have this $ref?\n  $ref = $refs._$refs[withoutHash];\n  if ($ref) {\n    // We've already parsed this $ref, so use the existing value\n    return Promise.resolve($ref.value);\n  }\n\n  // Parse the $referenced file/url\n  const result = await parse(resolvedPath, $refs, options);\n\n  // Crawl the parsed value\n  // console.log('Resolving $ref pointers in %s', withoutHash);\n  let promises = crawl(result, withoutHash + \"#\", $refs, options);\n\n  return Promise.all(promises);\n}\n","\"use strict\";\n\nconst $Ref = require(\"./ref\");\nconst Pointer = require(\"./pointer\");\nconst url = require(\"./util/url\");\n\nmodule.exports = bundle;\n\n/**\n * Bundles all external JSON references into the main JSON schema, thus resulting in a schema that\n * only has *internal* references, not any *external* references.\n * This method mutates the JSON schema object, adding new references and re-mapping existing ones.\n *\n * @param {$RefParser} parser\n * @param {$RefParserOptions} options\n */\nfunction bundle (parser, options) {\n  // console.log('Bundling $ref pointers in %s', parser.$refs._root$Ref.path);\n\n  // Build an inventory of all $ref pointers in the JSON Schema\n  let inventory = [];\n  crawl(parser, \"schema\", parser.$refs._root$Ref.path + \"#\", \"#\", 0, inventory, parser.$refs, options);\n\n  // Remap all $ref pointers\n  remap(inventory);\n}\n\n/**\n * Recursively crawls the given value, and inventories all JSON references.\n *\n * @param {object} parent - The object containing the value to crawl. If the value is not an object or array, it will be ignored.\n * @param {string} key - The property key of `parent` to be crawled\n * @param {string} path - The full path of the property being crawled, possibly with a JSON Pointer in the hash\n * @param {string} pathFromRoot - The path of the property being crawled, from the schema root\n * @param {object[]} inventory - An array of already-inventoried $ref pointers\n * @param {$Refs} $refs\n * @param {$RefParserOptions} options\n */\nfunction crawl (parent, key, path, pathFromRoot, indirections, inventory, $refs, options) {\n  let obj = key === null ? parent : parent[key];\n\n  if (obj && typeof obj === \"object\") {\n    if ($Ref.isAllowed$Ref(obj)) {\n      inventory$Ref(parent, key, path, pathFromRoot, indirections, inventory, $refs, options);\n    }\n    else {\n      // Crawl the object in a specific order that's optimized for bundling.\n      // This is important because it determines how `pathFromRoot` gets built,\n      // which later determines which keys get dereferenced and which ones get remapped\n      let keys = Object.keys(obj)\n        .sort((a, b) => {\n          // Most people will expect references to be bundled into the the \"definitions\" property,\n          // so we always crawl that property first, if it exists.\n          if (a === \"definitions\") {\n            return -1;\n          }\n          else if (b === \"definitions\") {\n            return 1;\n          }\n          else {\n            // Otherwise, crawl the keys based on their length.\n            // This produces the shortest possible bundled references\n            return a.length - b.length;\n          }\n        });\n\n      // eslint-disable-next-line no-shadow\n      for (let key of keys) {\n        let keyPath = Pointer.join(path, key);\n        let keyPathFromRoot = Pointer.join(pathFromRoot, key);\n        let value = obj[key];\n\n        if ($Ref.isAllowed$Ref(value)) {\n          inventory$Ref(obj, key, path, keyPathFromRoot, indirections, inventory, $refs, options);\n        }\n        else {\n          crawl(obj, key, keyPath, keyPathFromRoot, indirections, inventory, $refs, options);\n        }\n      }\n    }\n  }\n}\n\n/**\n * Inventories the given JSON Reference (i.e. records detailed information about it so we can\n * optimize all $refs in the schema), and then crawls the resolved value.\n *\n * @param {object} $refParent - The object that contains a JSON Reference as one of its keys\n * @param {string} $refKey - The key in `$refParent` that is a JSON Reference\n * @param {string} path - The full path of the JSON Reference at `$refKey`, possibly with a JSON Pointer in the hash\n * @param {string} pathFromRoot - The path of the JSON Reference at `$refKey`, from the schema root\n * @param {object[]} inventory - An array of already-inventoried $ref pointers\n * @param {$Refs} $refs\n * @param {$RefParserOptions} options\n */\nfunction inventory$Ref ($refParent, $refKey, path, pathFromRoot, indirections, inventory, $refs, options) {\n  let $ref = $refKey === null ? $refParent : $refParent[$refKey];\n  let $refPath = url.resolve(path, $ref.$ref);\n  let pointer = $refs._resolve($refPath, options);\n  let depth = Pointer.parse(pathFromRoot).length;\n  let file = url.stripHash(pointer.path);\n  let hash = url.getHash(pointer.path);\n  let external = file !== $refs._root$Ref.path;\n  let extended = $Ref.isExtended$Ref($ref);\n  indirections += pointer.indirections;\n\n  let existingEntry = findInInventory(inventory, $refParent, $refKey);\n  if (existingEntry) {\n    // This $Ref has already been inventoried, so we don't need to process it again\n    if (depth < existingEntry.depth || indirections < existingEntry.indirections) {\n      removeFromInventory(inventory, existingEntry);\n    }\n    else {\n      return;\n    }\n  }\n\n  inventory.push({\n    $ref,                   // The JSON Reference (e.g. {$ref: string})\n    parent: $refParent,           // The object that contains this $ref pointer\n    key: $refKey,                 // The key in `parent` that is the $ref pointer\n    pathFromRoot,   // The path to the $ref pointer, from the JSON Schema root\n    depth,                 // How far from the JSON Schema root is this $ref pointer?\n    file,                   // The file that the $ref pointer resolves to\n    hash,                   // The hash within `file` that the $ref pointer resolves to\n    value: pointer.value,         // The resolved value of the $ref pointer\n    circular: pointer.circular,   // Is this $ref pointer DIRECTLY circular? (i.e. it references itself)\n    extended,           // Does this $ref extend its resolved value? (i.e. it has extra properties, in addition to \"$ref\")\n    external,           // Does this $ref pointer point to a file other than the main JSON Schema file?\n    indirections,   // The number of indirect references that were traversed to resolve the value\n  });\n\n  // Recursively crawl the resolved value\n  crawl(pointer.value, null, pointer.path, pathFromRoot, indirections + 1, inventory, $refs, options);\n}\n\n/**\n * Re-maps every $ref pointer, so that they're all relative to the root of the JSON Schema.\n * Each referenced value is dereferenced EXACTLY ONCE.  All subsequent references to the same\n * value are re-mapped to point to the first reference.\n *\n * @example:\n *  {\n *    first: { $ref: somefile.json#/some/part },\n *    second: { $ref: somefile.json#/another/part },\n *    third: { $ref: somefile.json },\n *    fourth: { $ref: somefile.json#/some/part/sub/part }\n *  }\n *\n * In this example, there are four references to the same file, but since the third reference points\n * to the ENTIRE file, that's the only one we need to dereference.  The other three can just be\n * remapped to point inside the third one.\n *\n * On the other hand, if the third reference DIDN'T exist, then the first and second would both need\n * to be dereferenced, since they point to different parts of the file. The fourth reference does NOT\n * need to be dereferenced, because it can be remapped to point inside the first one.\n *\n * @param {object[]} inventory\n */\nfunction remap (inventory) {\n  // Group & sort all the $ref pointers, so they're in the order that we need to dereference/remap them\n  inventory.sort((a, b) => {\n    if (a.file !== b.file) {\n      // Group all the $refs that point to the same file\n      return a.file < b.file ? -1 : +1;\n    }\n    else if (a.hash !== b.hash) {\n      // Group all the $refs that point to the same part of the file\n      return a.hash < b.hash ? -1 : +1;\n    }\n    else if (a.circular !== b.circular) {\n      // If the $ref points to itself, then sort it higher than other $refs that point to this $ref\n      return a.circular ? -1 : +1;\n    }\n    else if (a.extended !== b.extended) {\n      // If the $ref extends the resolved value, then sort it lower than other $refs that don't extend the value\n      return a.extended ? +1 : -1;\n    }\n    else if (a.indirections !== b.indirections) {\n      // Sort direct references higher than indirect references\n      return a.indirections - b.indirections;\n    }\n    else if (a.depth !== b.depth) {\n      // Sort $refs by how close they are to the JSON Schema root\n      return a.depth - b.depth;\n    }\n    else {\n      // Determine how far each $ref is from the \"definitions\" property.\n      // Most people will expect references to be bundled into the the \"definitions\" property if possible.\n      let aDefinitionsIndex = a.pathFromRoot.lastIndexOf(\"/definitions\");\n      let bDefinitionsIndex = b.pathFromRoot.lastIndexOf(\"/definitions\");\n\n      if (aDefinitionsIndex !== bDefinitionsIndex) {\n        // Give higher priority to the $ref that's closer to the \"definitions\" property\n        return bDefinitionsIndex - aDefinitionsIndex;\n      }\n      else {\n        // All else is equal, so use the shorter path, which will produce the shortest possible reference\n        return a.pathFromRoot.length - b.pathFromRoot.length;\n      }\n    }\n  });\n\n  let file, hash, pathFromRoot;\n  for (let entry of inventory) {\n    // console.log('Re-mapping $ref pointer \"%s\" at %s', entry.$ref.$ref, entry.pathFromRoot);\n\n    if (!entry.external) {\n      // This $ref already resolves to the main JSON Schema file\n      entry.$ref.$ref = entry.hash;\n    }\n    else if (entry.file === file && entry.hash === hash) {\n      // This $ref points to the same value as the prevous $ref, so remap it to the same path\n      entry.$ref.$ref = pathFromRoot;\n    }\n    else if (entry.file === file && entry.hash.indexOf(hash + \"/\") === 0) {\n      // This $ref points to a sub-value of the prevous $ref, so remap it beneath that path\n      entry.$ref.$ref = Pointer.join(pathFromRoot, Pointer.parse(entry.hash.replace(hash, \"#\")));\n    }\n    else {\n      // We've moved to a new file or new hash\n      file = entry.file;\n      hash = entry.hash;\n      pathFromRoot = entry.pathFromRoot;\n\n      // This is the first $ref to point to this value, so dereference the value.\n      // Any other $refs that point to the same value will point to this $ref instead\n      entry.$ref = entry.parent[entry.key] = $Ref.dereference(entry.$ref, entry.value);\n\n      if (entry.circular) {\n        // This $ref points to itself\n        entry.$ref.$ref = entry.pathFromRoot;\n      }\n    }\n\n    // console.log('    new value: %s', (entry.$ref && entry.$ref.$ref) ? entry.$ref.$ref : '[object Object]');\n  }\n}\n\n/**\n * TODO\n */\nfunction findInInventory (inventory, $refParent, $refKey) {\n  for (let i = 0; i < inventory.length; i++) {\n    let existingEntry = inventory[i];\n    if (existingEntry.parent === $refParent && existingEntry.key === $refKey) {\n      return existingEntry;\n    }\n  }\n}\n\nfunction removeFromInventory (inventory, entry) {\n  let index = inventory.indexOf(entry);\n  inventory.splice(index, 1);\n}\n","\"use strict\";\n\nconst $Ref = require(\"./ref\");\nconst Pointer = require(\"./pointer\");\nconst { ono } = require(\"ono\");\nconst url = require(\"./util/url\");\n\nmodule.exports = dereference;\n\n/**\n * Crawls the JSON schema, finds all JSON references, and dereferences them.\n * This method mutates the JSON schema object, replacing JSON references with their resolved value.\n *\n * @param {$RefParser} parser\n * @param {$RefParserOptions} options\n */\nfunction dereference (parser, options) {\n  // console.log('Dereferencing $ref pointers in %s', parser.$refs._root$Ref.path);\n  let dereferenced = crawl(parser.schema, parser.$refs._root$Ref.path, \"#\", [], parser.$refs, options);\n  parser.$refs.circular = dereferenced.circular;\n  parser.schema = dereferenced.value;\n}\n\n/**\n * Recursively crawls the given value, and dereferences any JSON references.\n *\n * @param {*} obj - The value to crawl. If it's not an object or array, it will be ignored.\n * @param {string} path - The full path of `obj`, possibly with a JSON Pointer in the hash\n * @param {string} pathFromRoot - The path of `obj` from the schema root\n * @param {object[]} parents - An array of the parent objects that have already been dereferenced\n * @param {$Refs} $refs\n * @param {$RefParserOptions} options\n * @returns {{value: object, circular: boolean}}\n */\nfunction crawl (obj, path, pathFromRoot, parents, $refs, options) {\n  let dereferenced;\n  let result = {\n    value: obj,\n    circular: false\n  };\n\n  if (obj && typeof obj === \"object\") {\n    parents.push(obj);\n\n    if ($Ref.isAllowed$Ref(obj, options)) {\n      dereferenced = dereference$Ref(obj, path, pathFromRoot, parents, $refs, options);\n      result.circular = dereferenced.circular;\n      result.value = dereferenced.value;\n    }\n    else {\n      for (let key of Object.keys(obj)) {\n        let keyPath = Pointer.join(path, key);\n        let keyPathFromRoot = Pointer.join(pathFromRoot, key);\n        let value = obj[key];\n        let circular = false;\n\n        if ($Ref.isAllowed$Ref(value, options)) {\n          dereferenced = dereference$Ref(value, keyPath, keyPathFromRoot, parents, $refs, options);\n          circular = dereferenced.circular;\n          obj[key] = dereferenced.value;\n        }\n        else {\n          if (parents.indexOf(value) === -1) {\n            dereferenced = crawl(value, keyPath, keyPathFromRoot, parents, $refs, options);\n            circular = dereferenced.circular;\n            obj[key] = dereferenced.value;\n          }\n          else {\n            circular = foundCircularReference(keyPath, $refs, options);\n          }\n        }\n\n        // Set the \"isCircular\" flag if this or any other property is circular\n        result.circular = result.circular || circular;\n      }\n    }\n\n    parents.pop();\n  }\n\n  return result;\n}\n\n/**\n * Dereferences the given JSON Reference, and then crawls the resulting value.\n *\n * @param {{$ref: string}} $ref - The JSON Reference to resolve\n * @param {string} path - The full path of `$ref`, possibly with a JSON Pointer in the hash\n * @param {string} pathFromRoot - The path of `$ref` from the schema root\n * @param {object[]} parents - An array of the parent objects that have already been dereferenced\n * @param {$Refs} $refs\n * @param {$RefParserOptions} options\n * @returns {{value: object, circular: boolean}}\n */\nfunction dereference$Ref ($ref, path, pathFromRoot, parents, $refs, options) {\n  // console.log('Dereferencing $ref pointer \"%s\" at %s', $ref.$ref, path);\n\n  let $refPath = url.resolve(path, $ref.$ref);\n  let pointer = $refs._resolve($refPath, options);\n\n  // Check for circular references\n  let directCircular = pointer.circular;\n  let circular = directCircular || parents.indexOf(pointer.value) !== -1;\n  circular && foundCircularReference(path, $refs, options);\n\n  // Dereference the JSON reference\n  let dereferencedValue = $Ref.dereference($ref, pointer.value);\n\n  // Crawl the dereferenced value (unless it's circular)\n  if (!circular) {\n    // Determine if the dereferenced value is circular\n    let dereferenced = crawl(dereferencedValue, pointer.path, pathFromRoot, parents, $refs, options);\n    circular = dereferenced.circular;\n    dereferencedValue = dereferenced.value;\n  }\n\n  if (circular && !directCircular && options.dereference.circular === \"ignore\") {\n    // The user has chosen to \"ignore\" circular references, so don't change the value\n    dereferencedValue = $ref;\n  }\n\n  if (directCircular) {\n    // The pointer is a DIRECT circular reference (i.e. it references itself).\n    // So replace the $ref path with the absolute path from the JSON Schema root\n    dereferencedValue.$ref = pathFromRoot;\n  }\n\n  return {\n    circular,\n    value: dereferencedValue\n  };\n}\n\n/**\n * Called when a circular reference is found.\n * It sets the {@link $Refs#circular} flag, and throws an error if options.dereference.circular is false.\n *\n * @param {string} keyPath - The JSON Reference path of the circular reference\n * @param {$Refs} $refs\n * @param {$RefParserOptions} options\n * @returns {boolean} - always returns true, to indicate that a circular reference was found\n */\nfunction foundCircularReference (keyPath, $refs, options) {\n  $refs.circular = true;\n  if (!options.dereference.circular) {\n    throw ono.reference(`Circular $ref pointer found at ${keyPath}`);\n  }\n  return true;\n}\n","\"use strict\"\n\nvar next = (global.process && process.nextTick) || global.setImmediate || function (f) {\n  setTimeout(f, 0)\n}\n\nmodule.exports = function maybe (cb, promise) {\n  if (cb) {\n    promise\n      .then(function (result) {\n        next(function () { cb(null, result) })\n      }, function (err) {\n        next(function () { cb(err) })\n      })\n    return undefined\n  }\n  else {\n    return promise\n  }\n}\n","\"use strict\";\n\nconst Options = require(\"./options\");\nconst $Refs = require(\"./refs\");\nconst parse = require(\"./parse\");\nconst normalizeArgs = require(\"./normalize-args\");\nconst resolveExternal = require(\"./resolve-external\");\nconst bundle = require(\"./bundle\");\nconst dereference = require(\"./dereference\");\nconst url = require(\"./util/url\");\nconst maybe = require(\"call-me-maybe\");\nconst { ono } = require(\"ono\");\n\nmodule.exports = $RefParser;\nmodule.exports.YAML = require(\"./util/yaml\");\n\n/**\n * This class parses a JSON schema, builds a map of its JSON references and their resolved values,\n * and provides methods for traversing, manipulating, and dereferencing those references.\n *\n * @constructor\n */\nfunction $RefParser () {\n  /**\n   * The parsed (and possibly dereferenced) JSON schema object\n   *\n   * @type {object}\n   * @readonly\n   */\n  this.schema = null;\n\n  /**\n   * The resolved JSON references\n   *\n   * @type {$Refs}\n   * @readonly\n   */\n  this.$refs = new $Refs();\n}\n\n/**\n * Parses the given JSON schema.\n * This method does not resolve any JSON references.\n * It just reads a single file in JSON or YAML format, and parse it as a JavaScript object.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.\n * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed\n * @param {function} [callback] - An error-first callback. The second parameter is the parsed JSON schema object.\n * @returns {Promise} - The returned promise resolves with the parsed JSON schema object.\n */\n$RefParser.parse = function (path, schema, options, callback) {\n  let Class = this; // eslint-disable-line consistent-this\n  let instance = new Class();\n  return instance.parse.apply(instance, arguments);\n};\n\n/**\n * Parses the given JSON schema.\n * This method does not resolve any JSON references.\n * It just reads a single file in JSON or YAML format, and parse it as a JavaScript object.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.\n * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed\n * @param {function} [callback] - An error-first callback. The second parameter is the parsed JSON schema object.\n * @returns {Promise} - The returned promise resolves with the parsed JSON schema object.\n */\n$RefParser.prototype.parse = async function (path, schema, options, callback) {\n  let args = normalizeArgs(arguments);\n  let promise;\n\n  if (!args.path && !args.schema) {\n    let err = ono(`Expected a file path, URL, or object. Got ${args.path || args.schema}`);\n    return maybe(args.callback, Promise.reject(err));\n  }\n\n  // Reset everything\n  this.schema = null;\n  this.$refs = new $Refs();\n\n  // If the path is a filesystem path, then convert it to a URL.\n  // NOTE: According to the JSON Reference spec, these should already be URLs,\n  // but, in practice, many people use local filesystem paths instead.\n  // So we're being generous here and doing the conversion automatically.\n  // This is not intended to be a 100% bulletproof solution.\n  // If it doesn't work for your use-case, then use a URL instead.\n  let pathType = \"http\";\n  if (url.isFileSystemPath(args.path)) {\n    args.path = url.fromFileSystemPath(args.path);\n    pathType = \"file\";\n  }\n\n  // Resolve the absolute path of the schema\n  args.path = url.resolve(url.cwd(), args.path);\n\n  if (args.schema && typeof args.schema === \"object\") {\n    // A schema object was passed-in.\n    // So immediately add a new $Ref with the schema object as its value\n    let $ref = this.$refs._add(args.path);\n    $ref.value = args.schema;\n    $ref.pathType = pathType;\n    promise = Promise.resolve(args.schema);\n  }\n  else {\n    // Parse the schema file/url\n    promise = parse(args.path, this.$refs, args.options);\n  }\n\n  let me = this;\n  try {\n    let result = await promise;\n\n    if (!result || typeof result !== \"object\" || Buffer.isBuffer(result)) {\n      throw ono.syntax(`\"${me.$refs._root$Ref.path || result}\" is not a valid JSON Schema`);\n    }\n    else {\n      me.schema = result;\n      return maybe(args.callback, Promise.resolve(me.schema));\n    }\n  }\n  catch (e) {\n    return maybe(args.callback, Promise.reject(e));\n  }\n};\n\n/**\n * Parses the given JSON schema and resolves any JSON references, including references in\n * externally-referenced files.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.\n * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed and resolved\n * @param {function} [callback]\n * - An error-first callback. The second parameter is a {@link $Refs} object containing the resolved JSON references\n *\n * @returns {Promise}\n * The returned promise resolves with a {@link $Refs} object containing the resolved JSON references\n */\n$RefParser.resolve = function (path, schema, options, callback) {\n  let Class = this; // eslint-disable-line consistent-this\n  let instance = new Class();\n  return instance.resolve.apply(instance, arguments);\n};\n\n/**\n * Parses the given JSON schema and resolves any JSON references, including references in\n * externally-referenced files.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.\n * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed and resolved\n * @param {function} [callback]\n * - An error-first callback. The second parameter is a {@link $Refs} object containing the resolved JSON references\n *\n * @returns {Promise}\n * The returned promise resolves with a {@link $Refs} object containing the resolved JSON references\n */\n$RefParser.prototype.resolve = async function (path, schema, options, callback) {\n  let me = this;\n  let args = normalizeArgs(arguments);\n\n  try {\n    await this.parse(args.path, args.schema, args.options);\n    await resolveExternal(me, args.options);\n    return maybe(args.callback, Promise.resolve(me.$refs));\n  }\n  catch (err) {\n    return maybe(args.callback, Promise.reject(err));\n  }\n};\n\n/**\n * Parses the given JSON schema, resolves any JSON references, and bundles all external references\n * into the main JSON schema. This produces a JSON schema that only has *internal* references,\n * not any *external* references.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.\n * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed, resolved, and dereferenced\n * @param {function} [callback] - An error-first callback. The second parameter is the bundled JSON schema object\n * @returns {Promise} - The returned promise resolves with the bundled JSON schema object.\n */\n$RefParser.bundle = function (path, schema, options, callback) {\n  let Class = this; // eslint-disable-line consistent-this\n  let instance = new Class();\n  return instance.bundle.apply(instance, arguments);\n};\n\n/**\n * Parses the given JSON schema, resolves any JSON references, and bundles all external references\n * into the main JSON schema. This produces a JSON schema that only has *internal* references,\n * not any *external* references.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.\n * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed, resolved, and dereferenced\n * @param {function} [callback] - An error-first callback. The second parameter is the bundled JSON schema object\n * @returns {Promise} - The returned promise resolves with the bundled JSON schema object.\n */\n$RefParser.prototype.bundle = async function (path, schema, options, callback) {\n  let me = this;\n  let args = normalizeArgs(arguments);\n\n  try {\n    await this.resolve(args.path, args.schema, args.options);\n    bundle(me, args.options);\n    return maybe(args.callback, Promise.resolve(me.schema));\n  }\n  catch (err) {\n    return maybe(args.callback, Promise.reject(err));\n  }\n};\n\n/**\n * Parses the given JSON schema, resolves any JSON references, and dereferences the JSON schema.\n * That is, all JSON references are replaced with their resolved values.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.\n * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed, resolved, and dereferenced\n * @param {function} [callback] - An error-first callback. The second parameter is the dereferenced JSON schema object\n * @returns {Promise} - The returned promise resolves with the dereferenced JSON schema object.\n */\n$RefParser.dereference = function (path, schema, options, callback) {\n  let Class = this; // eslint-disable-line consistent-this\n  let instance = new Class();\n  return instance.dereference.apply(instance, arguments);\n};\n\n/**\n * Parses the given JSON schema, resolves any JSON references, and dereferences the JSON schema.\n * That is, all JSON references are replaced with their resolved values.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.\n * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed, resolved, and dereferenced\n * @param {function} [callback] - An error-first callback. The second parameter is the dereferenced JSON schema object\n * @returns {Promise} - The returned promise resolves with the dereferenced JSON schema object.\n */\n$RefParser.prototype.dereference = async function (path, schema, options, callback) {\n  let me = this;\n  let args = normalizeArgs(arguments);\n\n  try {\n    await this.resolve(args.path, args.schema, args.options);\n    dereference(me, args.options);\n    return maybe(args.callback, Promise.resolve(me.schema));\n  }\n  catch (err) {\n    return maybe(args.callback, Promise.reject(err));\n  }\n};\n","/**\n * This class defines a registry for custom formats used within JSF.\n */\nclass Registry {\n  constructor() {\n    // empty by default\n    this.data = {};\n  }\n\n  /**\n   * Unregisters custom format(s)\n   * @param name\n   */\n  unregister(name) {\n    if (!name) {\n      this.data = {};\n    } else {\n      delete this.data[name];\n    }\n  }\n\n  /**\n   * Registers custom format\n   */\n  register(name, callback) {\n    this.data[name] = callback;\n  }\n\n  /**\n   * Register many formats at one shot\n   */\n  registerMany(formats) {\n    Object.keys(formats).forEach(name => {\n      this.data[name] = formats[name];\n    });\n  }\n\n  /**\n   * Returns element by registry key\n   */\n  get(name) {\n    const format = this.data[name];\n\n    return format;\n  }\n\n  /**\n   * Returns the whole registry content\n   */\n  list() {\n    return this.data;\n  }\n}\n\nexport default Registry;\n","import Registry from './Registry';\n\nconst defaults = {};\n\ndefaults.defaultInvalidTypeProduct = null;\ndefaults.defaultRandExpMax = 10;\n\ndefaults.ignoreProperties = [];\ndefaults.ignoreMissingRefs = false;\ndefaults.failOnInvalidTypes = true;\ndefaults.failOnInvalidFormat = true;\n\ndefaults.alwaysFakeOptionals = false;\ndefaults.optionalsProbability = false;\ndefaults.fixedProbabilities = false;\ndefaults.useExamplesValue = false;\ndefaults.useDefaultValue = false;\ndefaults.requiredOnly = false;\n\ndefaults.minItems = 0;\ndefaults.maxItems = null;\ndefaults.minLength = 0;\ndefaults.maxLength = null;\n\ndefaults.resolveJsonPath = false;\ndefaults.reuseProperties = false;\ndefaults.fillProperties = true;\n\ndefaults.random = Math.random;\n\n/**\n * This class defines a registry for custom settings used within JSF.\n */\nclass OptionRegistry extends Registry {\n  constructor() {\n    super();\n    this.data = { ...defaults };\n    this._defaults = defaults;\n  }\n\n  get defaults() {\n    return { ...this._defaults };\n  }\n}\n\nexport default OptionRegistry;\n","import OptionRegistry from '../class/OptionRegistry';\n\n// instantiate\nconst registry = new OptionRegistry();\n\n/**\n * Custom option API\n *\n * @param nameOrOptionMap\n * @returns {any}\n */\nfunction optionAPI(nameOrOptionMap, optionalValue) {\n  if (typeof nameOrOptionMap === 'string') {\n    if (typeof optionalValue !== 'undefined') {\n      return registry.register(nameOrOptionMap, optionalValue);\n    }\n\n    return registry.get(nameOrOptionMap);\n  }\n\n  return registry.registerMany(nameOrOptionMap);\n}\n\noptionAPI.getDefaults = () => registry.defaults;\n\nexport default optionAPI;\n","const ALL_TYPES = ['array', 'object', 'integer', 'number', 'string', 'boolean', 'null'];\n\nconst MOST_NEAR_DATETIME = 2524608000000;\n\nconst MIN_INTEGER = -100000000;\nconst MAX_INTEGER = 100000000;\n\nconst MIN_NUMBER = -100;\nconst MAX_NUMBER = 100;\n\nexport default {\n  ALL_TYPES,\n  MIN_NUMBER,\n  MAX_NUMBER,\n  MIN_INTEGER,\n  MAX_INTEGER,\n  MOST_NEAR_DATETIME,\n};\n","module.exports = {\n  ROOT       : 0,\n  GROUP      : 1,\n  POSITION   : 2,\n  SET        : 3,\n  RANGE      : 4,\n  REPETITION : 5,\n  REFERENCE  : 6,\n  CHAR       : 7,\n};\n","const types = require('./types');\n\nconst INTS = () => [{ type: types.RANGE , from: 48, to: 57 }];\n\nconst WORDS = () => {\n  return [\n    { type: types.CHAR, value: 95 },\n    { type: types.RANGE, from: 97, to: 122 },\n    { type: types.RANGE, from: 65, to: 90 }\n  ].concat(INTS());\n};\n\nconst WHITESPACE = () => {\n  return [\n    { type: types.CHAR, value: 9 },\n    { type: types.CHAR, value: 10 },\n    { type: types.CHAR, value: 11 },\n    { type: types.CHAR, value: 12 },\n    { type: types.CHAR, value: 13 },\n    { type: types.CHAR, value: 32 },\n    { type: types.CHAR, value: 160 },\n    { type: types.CHAR, value: 5760 },\n    { type: types.RANGE, from: 8192, to: 8202 },\n    { type: types.CHAR, value: 8232 },\n    { type: types.CHAR, value: 8233 },\n    { type: types.CHAR, value: 8239 },\n    { type: types.CHAR, value: 8287 },\n    { type: types.CHAR, value: 12288 },\n    { type: types.CHAR, value: 65279 }\n  ];\n};\n\nconst NOTANYCHAR = () => {\n  return [\n    { type: types.CHAR, value: 10 },\n    { type: types.CHAR, value: 13 },\n    { type: types.CHAR, value: 8232 },\n    { type: types.CHAR, value: 8233 },\n  ];\n};\n\n// Predefined class objects.\nexports.words = () => ({ type: types.SET, set: WORDS(), not: false });\nexports.notWords = () => ({ type: types.SET, set: WORDS(), not: true });\nexports.ints = () => ({ type: types.SET, set: INTS(), not: false });\nexports.notInts = () => ({ type: types.SET, set: INTS(), not: true });\nexports.whitespace = () => ({ type: types.SET, set: WHITESPACE(), not: false });\nexports.notWhitespace = () => ({ type: types.SET, set: WHITESPACE(), not: true });\nexports.anyChar = () => ({ type: types.SET, set: NOTANYCHAR(), not: true });\n","const types = require('./types');\nconst sets  = require('./sets');\n\n\nconst CTRL = '@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^ ?';\nconst SLSH = { '0': 0, 't': 9, 'n': 10, 'v': 11, 'f': 12, 'r': 13 };\n\n/**\n * Finds character representations in str and convert all to\n * their respective characters\n *\n * @param {String} str\n * @return {String}\n */\nexports.strToChars = function(str) {\n  /* jshint maxlen: false */\n  var chars_regex = /(\\[\\\\b\\])|(\\\\)?\\\\(?:u([A-F0-9]{4})|x([A-F0-9]{2})|(0?[0-7]{2})|c([@A-Z[\\\\\\]^?])|([0tnvfr]))/g;\n  str = str.replace(chars_regex, function(s, b, lbs, a16, b16, c8, dctrl, eslsh) {\n    if (lbs) {\n      return s;\n    }\n\n    var code = b ? 8 :\n      a16   ? parseInt(a16, 16) :\n      b16   ? parseInt(b16, 16) :\n      c8    ? parseInt(c8,   8) :\n      dctrl ? CTRL.indexOf(dctrl) :\n      SLSH[eslsh];\n\n    var c = String.fromCharCode(code);\n\n    // Escape special regex characters.\n    if (/[[\\]{}^$.|?*+()]/.test(c)) {\n      c = '\\\\' + c;\n    }\n\n    return c;\n  });\n\n  return str;\n};\n\n\n/**\n * turns class into tokens\n * reads str until it encounters a ] not preceeded by a \\\n *\n * @param {String} str\n * @param {String} regexpStr\n * @return {Array.<Array.<Object>, Number>}\n */\nexports.tokenizeClass = (str, regexpStr) => {\n  /* jshint maxlen: false */\n  var tokens = [];\n  var regexp = /\\\\(?:(w)|(d)|(s)|(W)|(D)|(S))|((?:(?:\\\\)(.)|([^\\]\\\\]))-(?:\\\\)?([^\\]]))|(\\])|(?:\\\\)?([^])/g;\n  var rs, c;\n\n\n  while ((rs = regexp.exec(str)) != null) {\n    if (rs[1]) {\n      tokens.push(sets.words());\n\n    } else if (rs[2]) {\n      tokens.push(sets.ints());\n\n    } else if (rs[3]) {\n      tokens.push(sets.whitespace());\n\n    } else if (rs[4]) {\n      tokens.push(sets.notWords());\n\n    } else if (rs[5]) {\n      tokens.push(sets.notInts());\n\n    } else if (rs[6]) {\n      tokens.push(sets.notWhitespace());\n\n    } else if (rs[7]) {\n      tokens.push({\n        type: types.RANGE,\n        from: (rs[8] || rs[9]).charCodeAt(0),\n        to: rs[10].charCodeAt(0),\n      });\n\n    } else if ((c = rs[12])) {\n      tokens.push({\n        type: types.CHAR,\n        value: c.charCodeAt(0),\n      });\n\n    } else {\n      return [tokens, regexp.lastIndex];\n    }\n  }\n\n  exports.error(regexpStr, 'Unterminated character class');\n};\n\n\n/**\n * Shortcut to throw errors.\n *\n * @param {String} regexp\n * @param {String} msg\n */\nexports.error = (regexp, msg) => {\n  throw new SyntaxError('Invalid regular expression: /' + regexp + '/: ' + msg);\n};\n","const types = require('./types');\nexports.wordBoundary = () => ({ type: types.POSITION, value: 'b' });\nexports.nonWordBoundary = () => ({ type: types.POSITION, value: 'B' });\nexports.begin = () => ({ type: types.POSITION, value: '^' });\nexports.end = () => ({ type: types.POSITION, value: '$' });\n","const util      = require('./util');\nconst types     = require('./types');\nconst sets      = require('./sets');\nconst positions = require('./positions');\n\n\nmodule.exports = (regexpStr) => {\n  var i = 0, l, c,\n    start = { type: types.ROOT, stack: []},\n\n    // Keep track of last clause/group and stack.\n    lastGroup = start,\n    last = start.stack,\n    groupStack = [];\n\n\n  var repeatErr = (i) => {\n    util.error(regexpStr, `Nothing to repeat at column ${i - 1}`);\n  };\n\n  // Decode a few escaped characters.\n  var str = util.strToChars(regexpStr);\n  l = str.length;\n\n  // Iterate through each character in string.\n  while (i < l) {\n    c = str[i++];\n\n    switch (c) {\n      // Handle escaped characters, inclues a few sets.\n      case '\\\\':\n        c = str[i++];\n\n        switch (c) {\n          case 'b':\n            last.push(positions.wordBoundary());\n            break;\n\n          case 'B':\n            last.push(positions.nonWordBoundary());\n            break;\n\n          case 'w':\n            last.push(sets.words());\n            break;\n\n          case 'W':\n            last.push(sets.notWords());\n            break;\n\n          case 'd':\n            last.push(sets.ints());\n            break;\n\n          case 'D':\n            last.push(sets.notInts());\n            break;\n\n          case 's':\n            last.push(sets.whitespace());\n            break;\n\n          case 'S':\n            last.push(sets.notWhitespace());\n            break;\n\n          default:\n            // Check if c is integer.\n            // In which case it's a reference.\n            if (/\\d/.test(c)) {\n              last.push({ type: types.REFERENCE, value: parseInt(c, 10) });\n\n            // Escaped character.\n            } else {\n              last.push({ type: types.CHAR, value: c.charCodeAt(0) });\n            }\n        }\n\n        break;\n\n\n      // Positionals.\n      case '^':\n        last.push(positions.begin());\n        break;\n\n      case '$':\n        last.push(positions.end());\n        break;\n\n\n      // Handle custom sets.\n      case '[':\n        // Check if this class is 'anti' i.e. [^abc].\n        var not;\n        if (str[i] === '^') {\n          not = true;\n          i++;\n        } else {\n          not = false;\n        }\n\n        // Get all the characters in class.\n        var classTokens = util.tokenizeClass(str.slice(i), regexpStr);\n\n        // Increase index by length of class.\n        i += classTokens[1];\n        last.push({\n          type: types.SET,\n          set: classTokens[0],\n          not,\n        });\n\n        break;\n\n\n      // Class of any character except \\n.\n      case '.':\n        last.push(sets.anyChar());\n        break;\n\n\n      // Push group onto stack.\n      case '(':\n        // Create group.\n        var group = {\n          type: types.GROUP,\n          stack: [],\n          remember: true,\n        };\n\n        c = str[i];\n\n        // If if this is a special kind of group.\n        if (c === '?') {\n          c = str[i + 1];\n          i += 2;\n\n          // Match if followed by.\n          if (c === '=') {\n            group.followedBy = true;\n\n          // Match if not followed by.\n          } else if (c === '!') {\n            group.notFollowedBy = true;\n\n          } else if (c !== ':') {\n            util.error(regexpStr,\n              `Invalid group, character '${c}'` +\n              ` after '?' at column ${i - 1}`);\n          }\n\n          group.remember = false;\n        }\n\n        // Insert subgroup into current group stack.\n        last.push(group);\n\n        // Remember the current group for when the group closes.\n        groupStack.push(lastGroup);\n\n        // Make this new group the current group.\n        lastGroup = group;\n        last = group.stack;\n        break;\n\n\n      // Pop group out of stack.\n      case ')':\n        if (groupStack.length === 0) {\n          util.error(regexpStr, `Unmatched ) at column ${i - 1}`);\n        }\n        lastGroup = groupStack.pop();\n\n        // Check if this group has a PIPE.\n        // To get back the correct last stack.\n        last = lastGroup.options ?\n          lastGroup.options[lastGroup.options.length - 1] : lastGroup.stack;\n        break;\n\n\n      // Use pipe character to give more choices.\n      case '|':\n        // Create array where options are if this is the first PIPE\n        // in this clause.\n        if (!lastGroup.options) {\n          lastGroup.options = [lastGroup.stack];\n          delete lastGroup.stack;\n        }\n\n        // Create a new stack and add to options for rest of clause.\n        var stack = [];\n        lastGroup.options.push(stack);\n        last = stack;\n        break;\n\n\n      // Repetition.\n      // For every repetition, remove last element from last stack\n      // then insert back a RANGE object.\n      // This design is chosen because there could be more than\n      // one repetition symbols in a regex i.e. `a?+{2,3}`.\n      case '{':\n        var rs = /^(\\d+)(,(\\d+)?)?\\}/.exec(str.slice(i)), min, max;\n        if (rs !== null) {\n          if (last.length === 0) {\n            repeatErr(i);\n          }\n          min = parseInt(rs[1], 10);\n          max = rs[2] ? rs[3] ? parseInt(rs[3], 10) : Infinity : min;\n          i += rs[0].length;\n\n          last.push({\n            type: types.REPETITION,\n            min,\n            max,\n            value: last.pop(),\n          });\n        } else {\n          last.push({\n            type: types.CHAR,\n            value: 123,\n          });\n        }\n        break;\n\n      case '?':\n        if (last.length === 0) {\n          repeatErr(i);\n        }\n        last.push({\n          type: types.REPETITION,\n          min: 0,\n          max: 1,\n          value: last.pop(),\n        });\n        break;\n\n      case '+':\n        if (last.length === 0) {\n          repeatErr(i);\n        }\n        last.push({\n          type: types.REPETITION,\n          min: 1,\n          max: Infinity,\n          value: last.pop(),\n        });\n        break;\n\n      case '*':\n        if (last.length === 0) {\n          repeatErr(i);\n        }\n        last.push({\n          type: types.REPETITION,\n          min: 0,\n          max: Infinity,\n          value: last.pop(),\n        });\n        break;\n\n\n      // Default is a character that is not `\\[](){}?+*^$`.\n      default:\n        last.push({\n          type: types.CHAR,\n          value: c.charCodeAt(0),\n        });\n    }\n\n  }\n\n  // Check if any groups have not been closed.\n  if (groupStack.length !== 0) {\n    util.error(regexpStr, 'Unterminated group');\n  }\n\n  return start;\n};\n\nmodule.exports.types = types;\n","'use strict';\n/* eslint indent: 4 */\n\n\n// Private helper class\nclass SubRange {\n    constructor(low, high) {\n        this.low = low;\n        this.high = high;\n        this.length = 1 + high - low;\n    }\n\n    overlaps(range) {\n        return !(this.high < range.low || this.low > range.high);\n    }\n\n    touches(range) {\n        return !(this.high + 1 < range.low || this.low - 1 > range.high);\n    }\n\n    // Returns inclusive combination of SubRanges as a SubRange.\n    add(range) {\n        return new SubRange(\n            Math.min(this.low, range.low),\n            Math.max(this.high, range.high)\n        );\n    }\n\n    // Returns subtraction of SubRanges as an array of SubRanges.\n    // (There's a case where subtraction divides it in 2)\n    subtract(range) {\n        if (range.low <= this.low && range.high >= this.high) {\n            return [];\n        } else if (range.low > this.low && range.high < this.high) {\n            return [\n                new SubRange(this.low, range.low - 1),\n                new SubRange(range.high + 1, this.high)\n            ];\n        } else if (range.low <= this.low) {\n            return [new SubRange(range.high + 1, this.high)];\n        } else {\n            return [new SubRange(this.low, range.low - 1)];\n        }\n    }\n\n    toString() {\n        return this.low == this.high ?\n            this.low.toString() : this.low + '-' + this.high;\n    }\n}\n\n\nclass DRange {\n    constructor(a, b) {\n        this.ranges = [];\n        this.length = 0;\n        if (a != null) this.add(a, b);\n    }\n\n    _update_length() {\n        this.length = this.ranges.reduce((previous, range) => {\n            return previous + range.length;\n        }, 0);\n    }\n\n    add(a, b) {\n        var _add = (subrange) => {\n            var i = 0;\n            while (i < this.ranges.length && !subrange.touches(this.ranges[i])) {\n                i++;\n            }\n            var newRanges = this.ranges.slice(0, i);\n            while (i < this.ranges.length && subrange.touches(this.ranges[i])) {\n                subrange = subrange.add(this.ranges[i]);\n                i++;\n            }\n            newRanges.push(subrange);\n            this.ranges = newRanges.concat(this.ranges.slice(i));\n            this._update_length();\n        }\n\n        if (a instanceof DRange) {\n            a.ranges.forEach(_add);\n        } else {\n            if (b == null) b = a;\n            _add(new SubRange(a, b));\n        }\n        return this;\n    }\n\n    subtract(a, b) {\n        var _subtract = (subrange) => {\n            var i = 0;\n            while (i < this.ranges.length && !subrange.overlaps(this.ranges[i])) {\n                i++;\n            }\n            var newRanges = this.ranges.slice(0, i);\n            while (i < this.ranges.length && subrange.overlaps(this.ranges[i])) {\n                newRanges = newRanges.concat(this.ranges[i].subtract(subrange));\n                i++;\n            }\n            this.ranges = newRanges.concat(this.ranges.slice(i));\n            this._update_length();\n        };\n\n        if (a instanceof DRange) {\n            a.ranges.forEach(_subtract);\n        } else {\n            if (b == null) b = a;\n            _subtract(new SubRange(a, b));\n        }\n        return this;\n    }\n\n    intersect(a, b) {\n        var newRanges = [];\n        var _intersect = (subrange) => {\n            var i = 0;\n            while (i < this.ranges.length && !subrange.overlaps(this.ranges[i])) {\n                i++;\n            }\n            while (i < this.ranges.length && subrange.overlaps(this.ranges[i])) {\n                var low = Math.max(this.ranges[i].low, subrange.low);\n                var high = Math.min(this.ranges[i].high, subrange.high);\n                newRanges.push(new SubRange(low, high));\n                i++;\n            }\n        };\n\n        if (a instanceof DRange) {\n            a.ranges.forEach(_intersect);\n        } else {\n            if (b == null) b = a;\n            _intersect(new SubRange(a, b));\n        }\n        this.ranges = newRanges;\n        this._update_length();\n        return this;\n    }\n\n    index(index) {\n        var i = 0;\n        while (i < this.ranges.length && this.ranges[i].length <= index) {\n            index -= this.ranges[i].length;\n            i++;\n        }\n        return this.ranges[i].low + index;\n    }\n\n    toString() {\n        return '[ ' + this.ranges.join(', ') + ' ]';\n    }\n\n    clone() {\n        return new DRange(this);\n    }\n}\n\nmodule.exports = DRange;\n","const ret    = require('ret');\nconst DRange = require('drange');\nconst types  = ret.types;\n\n\nmodule.exports = class RandExp {\n  /**\n   * @constructor\n   * @param {RegExp|String} regexp\n   * @param {String} m\n   */\n  constructor(regexp, m) {\n    this._setDefaults(regexp);\n    if (regexp instanceof RegExp) {\n      this.ignoreCase = regexp.ignoreCase;\n      this.multiline = regexp.multiline;\n      regexp = regexp.source;\n\n    } else if (typeof regexp === 'string') {\n      this.ignoreCase = m && m.indexOf('i') !== -1;\n      this.multiline = m && m.indexOf('m') !== -1;\n    } else {\n      throw new Error('Expected a regexp or string');\n    }\n\n    this.tokens = ret(regexp);\n  }\n\n\n  /**\n   * Checks if some custom properties have been set for this regexp.\n   *\n   * @param {RandExp} randexp\n   * @param {RegExp} regexp\n   */\n  _setDefaults(regexp) {\n    // When a repetitional token has its max set to Infinite,\n    // randexp won't actually generate a random amount between min and Infinite\n    // instead it will see Infinite as min + 100.\n    this.max = regexp.max != null ? regexp.max :\n      RandExp.prototype.max != null ? RandExp.prototype.max : 100;\n\n    // This allows expanding to include additional characters\n    // for instance: RandExp.defaultRange.add(0, 65535);\n    this.defaultRange = regexp.defaultRange ?\n      regexp.defaultRange : this.defaultRange.clone();\n\n    if (regexp.randInt) {\n      this.randInt = regexp.randInt;\n    }\n  }\n\n\n  /**\n   * Generates the random string.\n   *\n   * @return {String}\n   */\n  gen() {\n    return this._gen(this.tokens, []);\n  }\n\n\n  /**\n   * Generate random string modeled after given tokens.\n   *\n   * @param {Object} token\n   * @param {Array.<String>} groups\n   * @return {String}\n   */\n  _gen(token, groups) {\n    var stack, str, n, i, l;\n\n    switch (token.type) {\n      case types.ROOT:\n      case types.GROUP:\n        // Ignore lookaheads for now.\n        if (token.followedBy || token.notFollowedBy) { return ''; }\n\n        // Insert placeholder until group string is generated.\n        if (token.remember && token.groupNumber === undefined) {\n          token.groupNumber = groups.push(null) - 1;\n        }\n\n        stack = token.options ?\n          this._randSelect(token.options) : token.stack;\n\n        str = '';\n        for (i = 0, l = stack.length; i < l; i++) {\n          str += this._gen(stack[i], groups);\n        }\n\n        if (token.remember) {\n          groups[token.groupNumber] = str;\n        }\n        return str;\n\n      case types.POSITION:\n        // Do nothing for now.\n        return '';\n\n      case types.SET:\n        var expandedSet = this._expand(token);\n        if (!expandedSet.length) { return ''; }\n        return String.fromCharCode(this._randSelect(expandedSet));\n\n      case types.REPETITION:\n        // Randomly generate number between min and max.\n        n = this.randInt(token.min,\n          token.max === Infinity ? token.min + this.max : token.max);\n\n        str = '';\n        for (i = 0; i < n; i++) {\n          str += this._gen(token.value, groups);\n        }\n\n        return str;\n\n      case types.REFERENCE:\n        return groups[token.value - 1] || '';\n\n      case types.CHAR:\n        var code = this.ignoreCase && this._randBool() ?\n          this._toOtherCase(token.value) : token.value;\n        return String.fromCharCode(code);\n    }\n  }\n\n\n  /**\n   * If code is alphabetic, converts to other case.\n   * If not alphabetic, returns back code.\n   *\n   * @param {Number} code\n   * @return {Number}\n   */\n  _toOtherCase(code) {\n    return code + (97 <= code && code <= 122 ? -32 :\n      65 <= code && code <= 90  ?  32 : 0);\n  }\n\n\n  /**\n   * Randomly returns a true or false value.\n   *\n   * @return {Boolean}\n   */\n  _randBool() {\n    return !this.randInt(0, 1);\n  }\n\n\n  /**\n   * Randomly selects and returns a value from the array.\n   *\n   * @param {Array.<Object>} arr\n   * @return {Object}\n   */\n  _randSelect(arr) {\n    if (arr instanceof DRange) {\n      return arr.index(this.randInt(0, arr.length - 1));\n    }\n    return arr[this.randInt(0, arr.length - 1)];\n  }\n\n\n  /**\n   * expands a token to a DiscontinuousRange of characters which has a\n   * length and an index function (for random selecting)\n   *\n   * @param {Object} token\n   * @return {DiscontinuousRange}\n   */\n  _expand(token) {\n    if (token.type === ret.types.CHAR) {\n      return new DRange(token.value);\n    } else if (token.type === ret.types.RANGE) {\n      return new DRange(token.from, token.to);\n    } else {\n      let drange = new DRange();\n      for (let i = 0; i < token.set.length; i++) {\n        let subrange = this._expand(token.set[i]);\n        drange.add(subrange);\n        if (this.ignoreCase) {\n          for (let j = 0; j < subrange.length; j++) {\n            let code = subrange.index(j);\n            let otherCaseCode = this._toOtherCase(code);\n            if (code !== otherCaseCode) {\n              drange.add(otherCaseCode);\n            }\n          }\n        }\n      }\n      if (token.not) {\n        return this.defaultRange.clone().subtract(drange);\n      } else {\n        return this.defaultRange.clone().intersect(drange);\n      }\n    }\n  }\n\n\n  /**\n   * Randomly generates and returns a number between a and b (inclusive).\n   *\n   * @param {Number} a\n   * @param {Number} b\n   * @return {Number}\n   */\n  randInt(a, b) {\n    return a + Math.floor(Math.random() * (1 + b - a));\n  }\n\n\n  /**\n   * Default range of characters to generate from.\n   */\n  get defaultRange() {\n    return this._range = this._range || new DRange(32, 126);\n  }\n\n  set defaultRange(range) {\n    this._range = range;\n  }\n\n\n  /**\n   *\n   * Enables use of randexp with a shorter call.\n   *\n   * @param {RegExp|String| regexp}\n   * @param {String} m\n   * @return {String}\n   */\n  static randexp(regexp, m) {\n    var randexp;\n    if(typeof regexp === 'string') {\n      regexp = new RegExp(regexp, m);\n    }\n\n    if (regexp._randexp === undefined) {\n      randexp = new RandExp(regexp, m);\n      regexp._randexp = randexp;\n    } else {\n      randexp = regexp._randexp;\n      randexp._setDefaults(regexp);\n    }\n    return randexp.gen();\n  }\n\n\n  /**\n   * Enables sugary /regexp/.gen syntax.\n   */\n  static sugar() {\n    /* eshint freeze:false */\n    RegExp.prototype.gen = function() {\n      return RandExp.randexp(this);\n    };\n  }\n};\n","import RandExp from 'randexp';\n\nimport optionAPI from '../api/option';\nimport env from './constants';\n\nfunction getRandomInteger(min, max) {\n  min = typeof min === 'undefined' ? env.MIN_INTEGER : min;\n  max = typeof max === 'undefined' ? env.MAX_INTEGER : max;\n\n  return Math.floor(optionAPI('random')() * ((max - min) + 1)) + min;\n}\n\nfunction _randexp(value) {\n  // set maximum default, see #193\n  RandExp.prototype.max = optionAPI('defaultRandExpMax');\n\n  // same implementation as the original except using our random\n  RandExp.prototype.randInt = (a, b) => a + Math.floor(optionAPI('random')() * (1 + (b - a)));\n\n  const re = new RandExp(value);\n\n  return re.gen();\n}\n\n/**\n * Returns random element of a collection\n *\n * @param collection\n * @returns {T}\n */\nfunction pick(collection) {\n  return collection[Math.floor(optionAPI('random')() * collection.length)];\n}\n\n/**\n * Returns shuffled collection of elements\n *\n * @param collection\n * @returns {T[]}\n */\nfunction shuffle(collection) {\n  let tmp;\n  let key;\n  let length = collection.length;\n\n  const copy = collection.slice();\n\n  for (; length > 0;) {\n    key = Math.floor(optionAPI('random')() * length);\n    // swap\n    length -= 1;\n    tmp = copy[length];\n    copy[length] = copy[key];\n    copy[key] = tmp;\n  }\n\n  return copy;\n}\n\n\n/**\n * Returns a random integer between min (inclusive) and max (inclusive)\n * Using Math.round() will give you a non-uniform distribution!\n * @see http://stackoverflow.com/a/1527820/769384\n */\nfunction getRandom(min, max) {\n  return (optionAPI('random')() * (max - min)) + min;\n}\n\n/**\n * Generates random number according to parameters passed\n *\n * @param min\n * @param max\n * @param defMin\n * @param defMax\n * @param hasPrecision\n * @returns {number}\n */\nfunction number(min, max, defMin, defMax, hasPrecision = false) {\n  defMin = typeof defMin === 'undefined' ? env.MIN_NUMBER : defMin;\n  defMax = typeof defMax === 'undefined' ? env.MAX_NUMBER : defMax;\n\n  min = typeof min === 'undefined' ? defMin : min;\n  max = typeof max === 'undefined' ? defMax : max;\n\n  if (max < min) {\n    max += min;\n  }\n\n  if (hasPrecision) {\n    return getRandom(min, max);\n  }\n\n  return getRandomInteger(min, max);\n}\n\nfunction by(type) {\n  switch (type) {\n    case 'seconds':\n      return number(0, 60) * 60;\n\n    case 'minutes':\n      return number(15, 50) * 612;\n\n    case 'hours':\n      return number(12, 72) * 36123;\n\n    case 'days':\n      return number(7, 30) * 86412345;\n\n    case 'weeks':\n      return number(4, 52) * 604812345;\n\n    case 'months':\n      return number(2, 13) * 2592012345;\n\n    case 'years':\n      return number(1, 20) * 31104012345;\n\n    default: break;\n  }\n}\n\nfunction date(step) {\n  if (step) {\n    return by(step);\n  }\n\n  const now = new Date();\n  const days = number(-1000, env.MOST_NEAR_DATETIME);\n\n  now.setTime(now.getTime() - days);\n\n  return now;\n}\n\nexport default {\n  pick,\n  date,\n  shuffle,\n  number,\n  randexp: _randexp,\n};\n","import optionAPI from '../api/option';\nimport env from './constants';\nimport random from './random';\n\nfunction getSubAttribute(obj, dotSeparatedKey) {\n  const keyElements = dotSeparatedKey.split('.');\n\n  while (keyElements.length) {\n    const prop = keyElements.shift();\n\n    if (!obj[prop]) {\n      break;\n    }\n\n    obj = obj[prop];\n  }\n  return obj;\n}\n\n/**\n * Returns true/false whether the object parameter has its own properties defined\n *\n * @param obj\n * @param properties\n * @returns {boolean}\n */\nfunction hasProperties(obj, ...properties) {\n  return properties.filter(key => {\n    return typeof obj[key] !== 'undefined';\n  }).length > 0;\n}\n\n/**\n * Returns typecasted value.\n * External generators (faker, chance, casual) may return data in non-expected formats, such as string, when you might expect an\n * integer. This function is used to force the typecast. This is the base formatter for all result values.\n *\n * @param type\n * @param schema\n * @param callback\n * @returns {any}\n */\nfunction typecast(type, schema, callback) {\n  const params = {};\n\n  // normalize constraints\n  switch (type || schema.type) {\n    case 'integer':\n    case 'number':\n      if (typeof schema.minimum !== 'undefined') {\n        params.minimum = schema.minimum;\n      }\n\n      if (typeof schema.maximum !== 'undefined') {\n        params.maximum = schema.maximum;\n      }\n\n      if (schema.enum) {\n        let min = Math.max(params.minimum || 0, 0);\n        let max = Math.min(params.maximum || Infinity, Infinity);\n\n        if (schema.exclusiveMinimum && min === schema.minimum) {\n          min += schema.multipleOf || 1;\n        }\n\n        if (schema.exclusiveMaximum && max === schema.maximum) {\n          max -= schema.multipleOf || 1;\n        }\n\n        // discard out-of-bounds enumerations\n        if (min || max !== Infinity) {\n          schema.enum = schema.enum.filter(x => {\n            if (x >= min && x <= max) {\n              return true;\n            }\n\n            return false;\n          });\n        }\n      }\n\n      break;\n\n    case 'string': {\n      if (typeof schema.minLength !== 'undefined') {\n        params.minLength = schema.minLength;\n      }\n\n      if (typeof schema.maxLength !== 'undefined') {\n        params.maxLength = schema.maxLength;\n      }\n\n      const _maxLength = optionAPI('maxLength');\n      const _minLength = optionAPI('minLength');\n\n      // Don't allow user to set max length above our maximum\n      if (_maxLength && params.maxLength > _maxLength) {\n        params.maxLength = _maxLength;\n      }\n\n      // Don't allow user to set min length above our maximum\n      if (_minLength && params.minLength < _minLength) {\n        params.minLength = _minLength;\n      }\n\n      break;\n    }\n\n    default: break;\n  }\n\n  // execute generator\n  let value = callback(params);\n\n  // normalize output value\n  switch (type || schema.type) {\n    case 'number':\n      value = parseFloat(value);\n      break;\n\n    case 'integer':\n      value = parseInt(value, 10);\n      break;\n\n    case 'boolean':\n      value = !!value;\n      break;\n\n    case 'string': {\n      value = String(value);\n\n      const min = Math.max(params.minLength || 0, 0);\n      const max = Math.min(params.maxLength || Infinity, Infinity);\n\n      while (value.length < min) {\n        if (!schema.pattern) {\n          value += `${random.pick([' ', '/', '_', '-', '+', '=', '@', '^'])}${value}`;\n        } else {\n          value += random.randexp(schema.pattern);\n        }\n      }\n\n      if (value.length > max) {\n        value = value.substr(0, max);\n      }\n\n      switch (schema.format) {\n        case 'date-time':\n        case 'datetime':\n          value = new Date(value).toISOString().replace(/([0-9])0+Z$/, '$1Z');\n          break;\n\n        case 'date':\n          value = new Date(value).toISOString().substr(0, 10);\n          break;\n\n        case 'time':\n          value = new Date(`1969-01-01 ${value}`).toISOString().substr(11);\n          break;\n\n        default:\n          break;\n      }\n      break;\n    }\n\n    default: break;\n  }\n\n  return value;\n}\n\nfunction merge(a, b) {\n  Object.keys(b).forEach(key => {\n    if (typeof b[key] !== 'object' || b[key] === null) {\n      a[key] = b[key];\n    } else if (Array.isArray(b[key])) {\n      a[key] = a[key] || [];\n      // fix #292 - skip duplicated values from merge object (b)\n      b[key].forEach(value => {\n        if (a[key].indexOf(value) === -1) {\n          a[key].push(value);\n        }\n      });\n    } else if (typeof a[key] !== 'object' || a[key] === null || Array.isArray(a[key])) {\n      a[key] = merge({}, b[key]);\n    } else {\n      a[key] = merge(a[key], b[key]);\n    }\n  });\n\n  return a;\n}\n\nfunction clone(obj) {\n  return JSON.parse(JSON.stringify(obj));\n}\n\nfunction short(schema) {\n  const s = JSON.stringify(schema);\n  const l = JSON.stringify(schema, null, 2);\n\n  return s.length > 400 ? `${l.substr(0, 400)}...` : l;\n}\n\nfunction anyValue() {\n  return random.pick([\n    false,\n    true,\n    null,\n    -1,\n    NaN,\n    Math.PI,\n    Infinity,\n    undefined,\n    [],\n    {},\n    // FIXME: use built-in random?\n    Math.random(),\n    Math.random().toString(36).substr(2),\n  ]);\n}\n\nfunction notValue(schema, parent) {\n  const copy = merge({}, parent);\n\n  if (typeof schema.minimum !== 'undefined') {\n    copy.maximum = schema.minimum;\n    copy.exclusiveMaximum = true;\n  }\n\n  if (typeof schema.maximum !== 'undefined') {\n    copy.minimum = schema.maximum > copy.maximum ? 0 : schema.maximum;\n    copy.exclusiveMinimum = true;\n  }\n\n  if (typeof schema.minLength !== 'undefined') {\n    copy.maxLength = schema.minLength;\n  }\n\n  if (typeof schema.maxLength !== 'undefined') {\n    copy.minLength = schema.maxLength > copy.maxLength ? 0 : schema.maxLength;\n  }\n\n  if (schema.type) {\n    copy.type = random.pick(env.ALL_TYPES.filter(x => {\n      const types = Array.isArray(schema.type) ? schema.type : [schema.type];\n\n      return types.every(type => {\n        // treat both types as _similar enough_ to be skipped equal\n        if (x === 'number' || x === 'integer') {\n          return type !== 'number' && type !== 'integer';\n        }\n\n        return x !== type;\n      });\n    }));\n  } else if (schema.enum) {\n    let value;\n\n    do {\n      value = anyValue();\n    } while (schema.enum.indexOf(value) !== -1);\n\n    copy.enum = [value];\n  }\n\n  if (schema.required && copy.properties) {\n    schema.required.forEach(prop => {\n      delete copy.properties[prop];\n    });\n  }\n\n  // TODO: explore more scenarios\n\n  return copy;\n}\n\n// FIXME: evaluate more constraints?\nfunction validate(value, schemas) {\n  return !schemas.every(x => {\n    if (typeof x.minimum !== 'undefined' && value >= x.minimum) {\n      return true;\n    }\n\n    if (typeof x.maximum !== 'undefined' && value <= x.maximum) {\n      return true;\n    }\n\n    return false;\n  });\n}\n\nfunction isKey(prop) {\n  return ['enum', 'const', 'default', 'examples', 'required', 'definitions'].indexOf(prop) !== -1;\n}\n\nfunction omitProps(obj, props) {\n  const copy = {};\n\n  Object.keys(obj).forEach(k => {\n    if (props.indexOf(k) === -1) {\n      if (Array.isArray(obj[k])) {\n        copy[k] = obj[k].slice();\n      } else {\n        copy[k] = obj[k] instanceof Object\n          ? merge({}, obj[k])\n          : obj[k];\n      }\n    }\n  });\n\n  return copy;\n}\n\nfunction template(value, schema) {\n  if (Array.isArray(value)) {\n    return value.map(x => template(x, schema));\n  }\n\n  if (typeof value === 'string') {\n    value = value.replace(/#\\{([\\w.-]+)\\}/g, (_, $1) => schema[$1]);\n  }\n\n  return value;\n}\n\nexport default {\n  getSubAttribute,\n  hasProperties,\n  omitProps,\n  typecast,\n  merge,\n  clone,\n  short,\n  notValue,\n  anyValue,\n  validate,\n  isKey,\n  template,\n};\n","import util from '../core/utils';\n\n// dynamic proxy for custom generators\nfunction proxy(gen) {\n  return (value, schema, property, rootSchema) => {\n    let fn = value;\n    let args = [];\n\n    // support for nested object, first-key is the generator\n    if (typeof value === 'object') {\n      fn = Object.keys(value)[0];\n\n      // treat the given array as arguments,\n      if (Array.isArray(value[fn])) {\n        // if the generator is expecting arrays they should be nested, e.g. `[[1, 2, 3], true, ...]`\n        args = value[fn];\n      } else {\n        args.push(value[fn]);\n      }\n    }\n\n    // support for keypaths, e.g. \"internet.email\"\n    const props = fn.split('.');\n\n    // retrieve a fresh dependency\n    let ctx = gen();\n\n    while (props.length > 1) {\n      ctx = ctx[props.shift()];\n    }\n\n    // retrieve last value from context object\n    value = typeof ctx === 'object' ? ctx[props[0]] : ctx;\n\n    // invoke dynamic generators\n    if (typeof value === 'function') {\n      value = value.apply(ctx, args.map(x => util.template(x, rootSchema)));\n    }\n\n    // test for pending callbacks\n    if (Object.prototype.toString.call(value) === '[object Object]') {\n      Object.keys(value).forEach(key => {\n        if (typeof value[key] === 'function') {\n          throw new Error(`Cannot resolve value for '${property}: ${fn}', given: ${value}`);\n        }\n      });\n    }\n\n    return value;\n  };\n}\n\n/**\n * Container is used to wrap external generators (faker, chance, casual, etc.) and its dependencies.\n *\n * - `jsf.extend('faker')` will enhance or define the given dependency.\n * - `jsf.define('faker')` will provide the \"faker\" keyword support.\n *\n * RandExp is not longer considered an \"extension\".\n */\nclass Container {\n  constructor() {\n    // dynamic requires - handle all dependencies\n    // they will NOT be included on the bundle\n    this.registry = {};\n    this.support = {};\n  }\n\n  /**\n   * Unregister extensions\n   * @param name\n   */\n  reset(name) {\n    if (!name) {\n      this.registry = {};\n      this.support = {};\n    } else {\n      delete this.registry[name];\n      delete this.support[name];\n    }\n  }\n\n  /**\n   * Override dependency given by name\n   * @param name\n   * @param callback\n   */\n  extend(name, callback) {\n    this.registry[name] = callback(this.registry[name]);\n\n    // built-in proxy (can be overridden)\n    if (!this.support[name]) {\n      this.support[name] = proxy(() => this.registry[name]);\n    }\n  }\n\n  /**\n   * Set keyword support by name\n   * @param name\n   * @param callback\n   */\n  define(name, callback) {\n    this.support[name] = callback;\n  }\n\n  /**\n   * Returns dependency given by name\n   * @param name\n   * @returns {Dependency}\n   */\n  get(name) {\n    if (typeof this.registry[name] === 'undefined') {\n      throw new ReferenceError(`'${name}' dependency doesn't exist.`);\n    }\n    return this.registry[name];\n  }\n\n  /**\n   * Apply a custom keyword\n   * @param schema\n   */\n  wrap(schema) {\n    const keys = Object.keys(schema);\n    const context = {};\n\n    let length = keys.length;\n\n    while (length--) { // eslint-disable-line\n      const fn = keys[length].replace(/^x-/, '');\n      const gen = this.support[fn];\n\n      if (typeof gen === 'function') {\n        Object.defineProperty(schema, 'generate', {\n          configurable: false,\n          enumerable: false,\n          writable: false,\n          value: rootSchema => gen.call(context, schema[keys[length]], schema, keys[length], rootSchema), // eslint-disable-line\n        });\n        break;\n      }\n    }\n\n    return schema;\n  }\n}\n\nexport default Container;\n","import Registry from '../class/Registry';\n\n// instantiate\nconst registry = new Registry();\n\n/**\n * Custom format API\n *\n * @see https://github.com/json-schema-faker/json-schema-faker#custom-formats\n * @param nameOrFormatMap\n * @param callback\n * @returns {any}\n */\nfunction formatAPI(nameOrFormatMap, callback) {\n  if (typeof nameOrFormatMap === 'undefined') {\n    return registry.list();\n  }\n\n  if (typeof nameOrFormatMap === 'string') {\n    if (typeof callback === 'function') {\n      registry.register(nameOrFormatMap, callback);\n    } else if (callback === null || callback === false) {\n      registry.unregister(nameOrFormatMap);\n    } else {\n      return registry.get(nameOrFormatMap);\n    }\n  } else {\n    registry.registerMany(nameOrFormatMap);\n  }\n}\n\nexport default formatAPI;\n","class ParseError extends Error {\n  constructor(message, path) {\n    super();\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor);\n    }\n    this.name = 'ParseError';\n    this.message = message;\n    this.path = path;\n  }\n}\n\nexport default ParseError;\n","const inferredProperties = {\n  array: [\n    'additionalItems',\n    'items',\n    'maxItems',\n    'minItems',\n    'uniqueItems',\n  ],\n  integer: [\n    'exclusiveMaximum',\n    'exclusiveMinimum',\n    'maximum',\n    'minimum',\n    'multipleOf',\n  ],\n  object: [\n    'additionalProperties',\n    'dependencies',\n    'maxProperties',\n    'minProperties',\n    'patternProperties',\n    'properties',\n    'required',\n  ],\n  string: [\n    'maxLength',\n    'minLength',\n    'pattern',\n    'format',\n  ],\n};\n\ninferredProperties.number = inferredProperties.integer;\n\nconst subschemaProperties = [\n  'additionalItems',\n  'items',\n  'additionalProperties',\n  'dependencies',\n  'patternProperties',\n  'properties',\n];\n\n/**\n * Iterates through all keys of `obj` and:\n * - checks whether those keys match properties of a given inferred type\n * - makes sure that `obj` is not a subschema; _Do not attempt to infer properties named as subschema containers. The\n * reason for this is that any property name within those containers that matches one of the properties used for\n * inferring missing type values causes the container itself to get processed which leads to invalid output. (Issue 62)_\n *\n * @returns {boolean}\n */\nfunction matchesType(obj, lastElementInPath, inferredTypeProperties) {\n  return Object.keys(obj).filter(prop => {\n    const isSubschema = subschemaProperties.indexOf(lastElementInPath) > -1;\n    const inferredPropertyFound = inferredTypeProperties.indexOf(prop) > -1;\n\n    if (inferredPropertyFound && !isSubschema) {\n      return true;\n    }\n\n    return false;\n  }).length > 0;\n}\n\n/**\n * Checks whether given `obj` type might be inferred. The mechanism iterates through all inferred types definitions,\n * tries to match allowed properties with properties of given `obj`. Returns type name, if inferred, or null.\n *\n * @returns {string|null}\n */\nfunction inferType(obj, schemaPath) {\n  const keys = Object.keys(inferredProperties);\n\n  for (let i = 0; i < keys.length; i += 1) {\n    const typeName = keys[i];\n    const lastElementInPath = schemaPath[schemaPath.length - 1];\n\n    if (matchesType(obj, lastElementInPath, inferredProperties[typeName])) {\n      return typeName;\n    }\n  }\n}\n\nexport default inferType;\n","import booleanGenerator from '../generators/boolean';\n\nconst booleanType = booleanGenerator;\n\nexport default booleanType;\n","import optionAPI from '../api/option';\n\n/**\n * Generates randomized boolean value.\n *\n * @returns {boolean}\n */\nfunction booleanGenerator() {\n  return optionAPI('random')() > 0.5;\n}\n\nexport default booleanGenerator;\n","import nullGenerator from '../generators/null';\n\nconst nullType = nullGenerator;\n\nexport default nullType;\n","/**\n * Generates null value.\n *\n * @returns {null}\n */\nfunction nullGenerator() {\n  return null;\n}\n\nexport default nullGenerator;\n","import random from '../core/random';\nimport env from '../core/constants';\n\nfunction numberType(value) {\n  let min = typeof value.minimum === 'undefined' ? env.MIN_INTEGER : value.minimum;\n  let max = typeof value.maximum === 'undefined' ? env.MAX_INTEGER : value.maximum;\n\n  const multipleOf = value.multipleOf;\n\n  if (multipleOf) {\n    max = Math.floor(max / multipleOf) * multipleOf;\n    min = Math.ceil(min / multipleOf) * multipleOf;\n  }\n\n  if (value.exclusiveMinimum && min === value.minimum) {\n    min += multipleOf || 1;\n  }\n\n  if (value.exclusiveMaximum && max === value.maximum) {\n    max -= multipleOf || 1;\n  }\n\n  if (min > max) {\n    return NaN;\n  }\n\n  if (multipleOf) {\n    if (String(multipleOf).indexOf('.') === -1) {\n      let base = random.number(Math.floor(min / multipleOf), Math.floor(max / multipleOf)) * multipleOf;\n\n      while (base < min) {\n        base += value.multipleOf;\n      }\n\n      return base;\n    }\n\n    const boundary = (max - min) / multipleOf;\n\n    let num;\n    let fix;\n\n    do {\n      num = random.number(0, boundary) * multipleOf;\n      fix = (num / multipleOf) % 1;\n    } while (fix !== 0);\n\n    // FIXME: https://github.com/json-schema-faker/json-schema-faker/issues/379\n\n    return num;\n  }\n\n  return random.number(min, max, undefined, undefined, true);\n}\n\nexport default numberType;\n","import random from '../core/random';\n\nconst LIPSUM_WORDS = `Lorem ipsum dolor sit amet consectetur adipisicing elit sed do eiusmod tempor incididunt ut labore\net dolore magna aliqua Ut enim ad minim veniam quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea\ncommodo consequat Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla\npariatur Excepteur sint occaecat cupidatat non proident sunt in culpa qui officia deserunt mollit anim id est\nlaborum`.split(/\\W/);\n\n/**\n * Generates randomized array of single lorem ipsum words.\n *\n * @param length\n * @returns {Array.<string>}\n */\nfunction wordsGenerator(length) {\n  const words = random.shuffle(LIPSUM_WORDS);\n\n  return words.slice(0, length);\n}\n\nexport default wordsGenerator;\n","import random from '../core/random';\nimport words from '../generators/words';\nimport utils from '../core/utils';\nimport optionAPI from '../api/option';\n\n// fallback generator\nconst anyType = { type: ['string', 'number', 'integer', 'boolean'] };\n\n// TODO provide types\nfunction objectType(value, path, resolve, traverseCallback) {\n  const props = {};\n\n  const properties = value.properties || {};\n  const patternProperties = value.patternProperties || {};\n  const requiredProperties = typeof value.required === 'boolean' ? [] : (value.required || []).slice();\n  const allowsAdditional = value.additionalProperties !== false;\n\n  const propertyKeys = Object.keys(properties);\n  const patternPropertyKeys = Object.keys(patternProperties);\n  const optionalProperties = propertyKeys.concat(patternPropertyKeys).reduce((_response, _key) => {\n    if (requiredProperties.indexOf(_key) === -1) _response.push(_key);\n    return _response;\n  }, []);\n  const allProperties = requiredProperties.concat(optionalProperties);\n\n  const additionalProperties = allowsAdditional // eslint-disable-line\n    ? (value.additionalProperties === true ? anyType : value.additionalProperties)\n    : value.additionalProperties;\n\n  if (!allowsAdditional\n    && propertyKeys.length === 0\n    && patternPropertyKeys.length === 0\n    && utils.hasProperties(value, 'minProperties', 'maxProperties', 'dependencies', 'required')\n  ) {\n    // just nothing\n    return {};\n  }\n\n  if (optionAPI('requiredOnly') === true) {\n    requiredProperties.forEach(key => {\n      if (properties[key]) {\n        props[key] = properties[key];\n      }\n    });\n\n    return traverseCallback(props, path.concat(['properties']), resolve);\n  }\n\n  const optionalsProbability = optionAPI('alwaysFakeOptionals') === true ? 1.0 : optionAPI('optionalsProbability');\n  const fixedProbabilities = optionAPI('alwaysFakeOptionals') || optionAPI('fixedProbabilities') || false;\n  const ignoreProperties = optionAPI('ignoreProperties') || [];\n\n  const min = Math.max(value.minProperties || 0, requiredProperties.length);\n  const max = value.maxProperties || (allProperties.length + random.number(1, 5));\n\n  let neededExtras = Math.max(0, min - requiredProperties.length);\n\n  if (allProperties.length === 1 && !requiredProperties.length) {\n    neededExtras = random.number(neededExtras, allProperties.length + (allProperties.length - min));\n  }\n\n  if (optionalsProbability !== false) {\n    if (fixedProbabilities === true) {\n      neededExtras = Math.round((min - requiredProperties.length) + (optionalsProbability * (allProperties.length - min)));\n    } else {\n      neededExtras = random.number(min - requiredProperties.length, optionalsProbability * (allProperties.length - min));\n    }\n  }\n\n  const extraPropertiesRandomOrder = random.shuffle(optionalProperties).slice(0, neededExtras);\n  const extraProperties = optionalProperties.filter(_item => {\n    return extraPropertiesRandomOrder.indexOf(_item) !== -1;\n  });\n\n  // properties are read from right-to-left\n  const _props = requiredProperties.concat(extraProperties).slice(0, max);\n  const _defns = [];\n\n  if (value.dependencies) {\n    Object.keys(value.dependencies).forEach(prop => {\n      const _required = value.dependencies[prop];\n\n      if (_props.indexOf(prop) !== -1) {\n        if (Array.isArray(_required)) {\n          // property-dependencies\n          _required.forEach(sub => {\n            if (_props.indexOf(sub) === -1) {\n              _props.push(sub);\n            }\n          });\n        } else {\n          _defns.push(_required);\n        }\n      }\n    });\n\n    // schema-dependencies\n    if (_defns.length) {\n      delete value.dependencies;\n\n      return traverseCallback({\n        allOf: _defns.concat(value),\n      }, path.concat(['properties']), resolve);\n    }\n  }\n\n  const skipped = [];\n  const missing = [];\n\n  _props.forEach(key => {\n    for (let i = 0; i < ignoreProperties.length; i += 1) {\n      if ((ignoreProperties[i] instanceof RegExp && ignoreProperties[i].test(key))\n        || (typeof ignoreProperties[i] === 'string' && ignoreProperties[i] === key)\n        || (typeof ignoreProperties[i] === 'function' && ignoreProperties[i](properties[key], key))) {\n        skipped.push(key);\n        return;\n      }\n    }\n\n    if (additionalProperties === false) {\n      if (requiredProperties.indexOf(key) !== -1) {\n        props[key] = properties[key];\n      }\n    }\n\n    if (properties[key]) {\n      props[key] = properties[key];\n    }\n\n    let found;\n\n    // then try patternProperties\n    patternPropertyKeys.forEach(_key => {\n      if (key.match(new RegExp(_key))) {\n        found = true;\n\n        if (props[key]) {\n          utils.merge(props[key], patternProperties[_key]);\n        } else {\n          props[random.randexp(key)] = patternProperties[_key];\n        }\n      }\n    });\n\n    if (!found) {\n      // try patternProperties again,\n      const subschema = patternProperties[key] || additionalProperties;\n\n      // FIXME: allow anyType as fallback when no subschema is given?\n\n      if (subschema && additionalProperties !== false) {\n        // otherwise we can use additionalProperties?\n        props[patternProperties[key] ? random.randexp(key) : key] = properties[key] || subschema;\n      } else {\n        missing.push(key);\n      }\n    }\n  });\n\n  const fillProps = optionAPI('fillProperties');\n  const reuseProps = optionAPI('reuseProperties');\n\n  // discard already ignored props if they're not required to be filled...\n  let current = Object.keys(props).length + (fillProps ? 0 : skipped.length);\n\n  // generate dynamic suffix for additional props...\n  const hash = suffix => random.randexp(`_?[_a-f\\\\d]{1,3}${suffix ? '\\\\$?' : ''}`);\n\n  function get() {\n    let one;\n\n    do {\n      one = requiredProperties.shift();\n    } while (props[one]);\n\n    return one;\n  }\n\n  while (fillProps) {\n    if (!(patternPropertyKeys.length || allowsAdditional)) {\n      break;\n    }\n\n    if (current >= min) {\n      break;\n    }\n\n    if (allowsAdditional) {\n      if (reuseProps && ((propertyKeys.length - current) > min)) {\n        let count = 0;\n        let key;\n\n        do {\n          count += 1;\n\n          // skip large objects\n          if (count > 1000) {\n            break;\n          }\n\n          key = get() || random.pick(propertyKeys);\n        } while (typeof props[key] !== 'undefined');\n\n        if (typeof props[key] === 'undefined') {\n          props[key] = properties[key];\n          current += 1;\n        }\n      } else if (patternPropertyKeys.length && !additionalProperties) {\n        const prop = random.pick(patternPropertyKeys);\n        const word = random.randexp(prop);\n\n        if (!props[word]) {\n          props[word] = patternProperties[prop];\n          current += 1;\n        }\n      } else {\n        const word = get() || (words(1) + hash());\n\n        if (!props[word]) {\n          props[word] = additionalProperties || anyType;\n          current += 1;\n        }\n      }\n    }\n\n    for (let i = 0; current < min && i < patternPropertyKeys.length; i += 1) {\n      const _key = patternPropertyKeys[i];\n      const word = random.randexp(_key);\n\n\n      if (!props[word]) {\n        props[word] = patternProperties[_key];\n        current += 1;\n      }\n    }\n  }\n\n  // fill up-to this value and no more!\n  const maximum = random.number(min, max);\n\n  for (; current < maximum && additionalProperties;) {\n    const word = words(1) + hash(true);\n\n    if (!props[word]) {\n      props[word] = additionalProperties;\n      current += 1;\n    }\n  }\n\n  return traverseCallback(props, path.concat(['properties']), resolve);\n}\n\nexport default objectType;\n","import words from './words';\nimport random from '../core/random';\n\n/**\n * Helper function used by thunkGenerator to produce some words for the final result.\n *\n * @returns {string}\n */\nfunction produce() {\n  const length = random.number(1, 5);\n\n  return words(length).join(' ');\n}\n\n/**\n * Generates randomized concatenated string based on words generator.\n *\n * @returns {string}\n */\nfunction thunkGenerator(min = 0, max = 140) {\n  const _min = Math.max(0, min);\n  const _max = random.number(_min, max);\n\n  let result = produce();\n\n  // append until length is reached\n  while (result.length < _min) {\n    result += produce();\n  }\n\n  // cut if needed\n  if (result.length > _max) {\n    result = result.substr(0, _max);\n  }\n\n  return result;\n}\n\nexport default thunkGenerator;\n","import random from '../core/random';\n\n/**\n * Generates randomized date time ISO format string.\n *\n * @returns {string}\n */\nfunction dateTimeGenerator() {\n  return random.date().toISOString();\n}\n\nexport default dateTimeGenerator;\n","import random from '../core/random';\n\nconst FRAGMENT = '[a-zA-Z][a-zA-Z0-9+-.]*';\nconst URI_PATTERN = `https?://{hostname}(?:${FRAGMENT})+`;\nconst PARAM_PATTERN = '(?:\\\\?([a-z]{1,7}(=\\\\w{1,5})?&){0,3})?';\n\n/**\n * Predefined core formats\n * @type {[key: string]: string}\n */\nconst regexps = {\n  email: '[a-zA-Z\\\\d][a-zA-Z\\\\d-]{1,13}[a-zA-Z\\\\d]@{hostname}',\n  hostname: '[a-zA-Z]{1,33}\\\\.[a-z]{2,4}',\n  ipv6: '[a-f\\\\d]{4}(:[a-f\\\\d]{4}){7}',\n  uri: URI_PATTERN,\n  slug: '[a-zA-Z\\\\d_-]+',\n\n  // types from draft-0[67] (?)\n  'uri-reference': `${URI_PATTERN}${PARAM_PATTERN}`,\n  'uri-template': URI_PATTERN.replace('(?:', '(?:/\\\\{[a-z][:a-zA-Z0-9-]*\\\\}|'),\n  'json-pointer': `(/(?:${FRAGMENT.replace(']*', '/]*')}|~[01]))+`,\n\n  // some types from https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.1.md#data-types (?)\n  uuid: '[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$',\n};\n\nregexps.iri = regexps['uri-reference'];\nregexps['iri-reference'] = regexps['uri-reference'];\n\nregexps['idn-email'] = regexps.email;\nregexps['idn-hostname'] = regexps.hostname;\n\nconst ALLOWED_FORMATS = new RegExp(`\\\\{(${Object.keys(regexps).join('|')})\\\\}`);\n\n/**\n * Generates randomized string basing on a built-in regex format\n *\n * @param coreFormat\n * @returns {string}\n */\nfunction coreFormatGenerator(coreFormat) {\n  return random.randexp(regexps[coreFormat]).replace(ALLOWED_FORMATS, (match, key) => {\n    return random.randexp(regexps[key]);\n  });\n}\n\nexport default coreFormatGenerator;\n","import thunk from '../generators/thunk';\nimport ipv4 from '../generators/ipv4';\nimport dateTime from '../generators/dateTime';\nimport date from '../generators/date';\nimport time from '../generators/time';\nimport coreFormat from '../generators/coreFormat';\nimport optionAPI from '../api/option';\nimport format from '../api/format';\nimport random from '../core/random';\nimport utils from '../core/utils';\n\nfunction generateFormat(value, invalid) {\n  const callback = format(value.format);\n\n  if (typeof callback === 'function') {\n    return callback(value);\n  }\n\n  switch (value.format) {\n    case 'date-time':\n    case 'datetime':\n      return dateTime();\n    case 'date':\n      return date();\n    case 'time':\n      return time();\n    case 'ipv4':\n      return ipv4();\n    case 'regex':\n      // TODO: discuss\n      return '.+?';\n    case 'email':\n    case 'hostname':\n    case 'ipv6':\n    case 'uri':\n    case 'uri-reference':\n    case 'iri':\n    case 'iri-reference':\n    case 'idn-email':\n    case 'idn-hostname':\n    case 'json-pointer':\n    case 'slug':\n    case 'uri-template':\n    case 'uuid':\n      return coreFormat(value.format);\n    default:\n      if (typeof callback === 'undefined') {\n        if (optionAPI('failOnInvalidFormat')) {\n          throw new Error(`unknown registry key ${utils.short(value.format)}`);\n        } else {\n          return invalid();\n        }\n      }\n\n      throw new Error(`unsupported format '${value.format}'`);\n  }\n}\n\nfunction stringType(value) {\n  // here we need to force type to fix #467\n  const output = utils.typecast('string', value, opts => {\n    if (value.format) {\n      return generateFormat(value, () => thunk(opts.minLength, opts.maxLength));\n    }\n\n    if (value.pattern) {\n      return random.randexp(value.pattern);\n    }\n\n    return thunk(opts.minLength, opts.maxLength);\n  });\n\n  return output;\n}\n\nexport default stringType;\n","import dateTimeGenerator from './dateTime';\n\n/**\n * Generates randomized date format string.\n *\n * @returns {string}\n */\nfunction dateGenerator() {\n  return dateTimeGenerator().slice(0, 10);\n}\n\nexport default dateGenerator;\n","import dateTimeGenerator from './dateTime';\n\n/**\n * Generates randomized time format string.\n *\n * @returns {string}\n */\nfunction timeGenerator() {\n  return dateTimeGenerator().slice(11);\n}\n\nexport default timeGenerator;\n","import random from '../core/random';\n\n/**\n * Generates randomized ipv4 address.\n *\n * @returns {string}\n */\nfunction ipv4Generator() {\n  return [0, 0, 0, 0].map(() => {\n    return random.number(0, 255);\n  }).join('.');\n}\n\nexport default ipv4Generator;\n","import _boolean from './boolean';\nimport _null from './null';\nimport _array from './array';\nimport _integer from './integer';\nimport _number from './number';\nimport _object from './object';\nimport _string from './string';\n\nconst typeMap = {\n  boolean: _boolean,\n  null: _null,\n  array: _array,\n  integer: _integer,\n  number: _number,\n  object: _object,\n  string: _string,\n};\n\nexport default typeMap;\n","import random from '../core/random';\nimport utils from '../core/utils';\nimport ParseError from '../core/error';\nimport optionAPI from '../api/option';\n\n// TODO provide types\nfunction unique(path, items, value, sample, resolve, traverseCallback) {\n  const tmp = [];\n  const seen = [];\n\n  function walk(obj) {\n    const json = JSON.stringify(obj);\n\n    if (seen.indexOf(json) === -1) {\n      seen.push(json);\n      tmp.push(obj);\n\n      return true;\n    }\n\n    return false;\n  }\n\n  items.forEach(walk);\n\n  // TODO: find a better solution?\n  let limit = 100;\n\n  while (tmp.length !== items.length) {\n    if (!walk(traverseCallback(value.items || sample, path, resolve))) {\n      limit -= 1;\n    }\n\n    if (!limit) {\n      break;\n    }\n  }\n\n  return tmp;\n}\n\n// TODO provide types\nfunction arrayType(value, path, resolve, traverseCallback) {\n  const items = [];\n\n  if (!(value.items || value.additionalItems)) {\n    if (utils.hasProperties(value, 'minItems', 'maxItems', 'uniqueItems')) {\n      throw new ParseError(`missing items for ${utils.short(value)}`, path);\n    }\n    return items;\n  }\n\n  if (Array.isArray(value.items)) {\n    return value.items.map((item, key) => {\n      const itemSubpath = path.concat(['items', key]);\n\n      return traverseCallback(item, itemSubpath, resolve);\n    });\n  }\n\n  let minItems = value.minItems;\n  let maxItems = value.maxItems;\n\n  if (optionAPI('minItems')) {\n    // fix boundaries\n    minItems = !maxItems\n      ? optionAPI('minItems')\n      : Math.min(optionAPI('minItems'), maxItems);\n  }\n\n  if (optionAPI('maxItems')) {\n    // Don't allow user to set max items above our maximum\n    if (maxItems && maxItems > optionAPI('maxItems')) {\n      maxItems = optionAPI('maxItems');\n    }\n\n    // Don't allow user to set min items above our maximum\n    if (minItems && minItems > optionAPI('maxItems')) {\n      minItems = maxItems;\n    }\n  }\n\n  const optionalsProbability = optionAPI('alwaysFakeOptionals') === true ? 1.0 : optionAPI('optionalsProbability');\n  const fixedProbabilities = optionAPI('alwaysFakeOptionals') || optionAPI('fixedProbabilities') || false;\n\n  let length = random.number(minItems, maxItems, 1, 5);\n\n  if (optionalsProbability !== false) {\n    length = Math.max(fixedProbabilities\n      ? Math.round((maxItems || length) * optionalsProbability)\n      : Math.abs(random.number(minItems, maxItems) * optionalsProbability), minItems || 0);\n  }\n\n  // TODO below looks bad. Should additionalItems be copied as-is?\n  const sample = typeof value.additionalItems === 'object' ? value.additionalItems : {};\n\n  for (let current = items.length; current < length; current += 1) {\n    const itemSubpath = path.concat(['items', current]);\n    const element = traverseCallback(value.items || sample, itemSubpath, resolve);\n\n    items.push(element);\n  }\n\n  if (value.uniqueItems) {\n    return unique(path.concat(['items']), items, value, sample, resolve, traverseCallback);\n  }\n\n  return items;\n}\n\nexport default arrayType;\n","import number from './number';\n\n// The `integer` type is just a wrapper for the `number` type. The `number` type\n// returns floating point numbers, and `integer` type truncates the fraction\n// part, leaving the result as an integer.\n\nfunction integerType(value) {\n  return number({ multipleOf: 1, ...value });\n}\n\nexport default integerType;\n","import utils from './utils';\nimport random from './random';\nimport ParseError from './error';\nimport inferType from './infer';\nimport types from '../types/index';\nimport optionAPI from '../api/option';\n\n// TODO provide types\nfunction traverse(schema, path, resolve, rootSchema) {\n  schema = resolve(schema, undefined, path);\n\n  if (!schema) {\n    return;\n  }\n\n  // default values has higher precedence\n  if (path[path.length - 1] !== 'properties') {\n    // example values have highest precedence\n    if (optionAPI('useExamplesValue') && Array.isArray(schema.examples)) {\n      // include `default` value as example too\n      const fixedExamples = schema.examples\n        .concat('default' in schema ? [schema.default] : []);\n\n      return utils.typecast(null, schema, () => random.pick(fixedExamples));\n    }\n\n    if (optionAPI('useDefaultValue') && 'default' in schema) {\n      return schema.default;\n    }\n\n    if ('template' in schema) {\n      return utils.template(schema.template, rootSchema);\n    }\n  }\n\n  if (schema.not && typeof schema.not === 'object') {\n    schema = utils.notValue(schema.not, utils.omitProps(schema, ['not']));\n  }\n\n  if ('const' in schema) {\n    return schema.const;\n  }\n\n  if (Array.isArray(schema.enum)) {\n    return utils.typecast(null, schema, () => random.pick(schema.enum));\n  }\n\n  // thunks can return sub-schemas\n  if (typeof schema.thunk === 'function') {\n    return traverse(schema.thunk(), path, resolve);\n  }\n\n  if (typeof schema.generate === 'function') {\n    return utils.typecast(null, schema, () => schema.generate(rootSchema));\n  }\n\n  // short-circuit as we don't plan generate more values!\n  if (schema.jsonPath) {\n    return schema;\n  }\n\n  // TODO remove the ugly overcome\n  let type = schema.type;\n\n  if (Array.isArray(type)) {\n    type = random.pick(type);\n  } else if (typeof type === 'undefined') {\n    // Attempt to infer the type\n    type = inferType(schema, path) || type;\n\n    if (type) {\n      schema.type = type;\n    }\n  }\n\n  if (typeof type === 'string') {\n    if (!types[type]) {\n      if (optionAPI('failOnInvalidTypes')) {\n        throw new ParseError(`unknown primitive ${utils.short(type)}`, path.concat(['type']));\n      } else {\n        return optionAPI('defaultInvalidTypeProduct');\n      }\n    } else {\n      try {\n        return types[type](schema, path, resolve, traverse);\n      } catch (e) {\n        if (typeof e.path === 'undefined') {\n          throw new ParseError(e.stack, path);\n        }\n        throw e;\n      }\n    }\n  }\n\n  let copy = {};\n\n  if (Array.isArray(schema)) {\n    copy = [];\n  }\n\n  Object.keys(schema).forEach(prop => {\n    if (typeof schema[prop] === 'object' && prop !== 'definitions') {\n      copy[prop] = traverse(schema[prop], path.concat([prop]), resolve, copy);\n    } else {\n      copy[prop] = schema[prop];\n    }\n  });\n\n  return copy;\n}\n\nexport default traverse;\n","import { JSONPath } from 'jsonpath-plus';\n\nimport optionAPI from '../api/option';\nimport traverse from './traverse';\nimport random from './random';\nimport utils from './utils';\n\nfunction pick(data) {\n  return Array.isArray(data)\n    ? random.pick(data)\n    : data;\n}\n\nfunction cycle(data, reverse) {\n  if (!Array.isArray(data)) {\n    return data;\n  }\n\n  const value = reverse\n    ? data.pop()\n    : data.shift();\n\n  if (reverse) {\n    data.unshift(value);\n  } else {\n    data.push(value);\n  }\n\n  return value;\n}\n\nfunction resolve(obj, data, values, property) {\n  if (!obj || typeof obj !== 'object') {\n    return obj;\n  }\n\n  if (!values) {\n    values = {};\n  }\n\n  if (!data) {\n    data = obj;\n  }\n\n  if (Array.isArray(obj)) {\n    return obj.map(x => resolve(x, data, values, property));\n  }\n\n  if (obj.jsonPath) {\n    const params = typeof obj.jsonPath !== 'object'\n      ? { path: obj.jsonPath }\n      : obj.jsonPath;\n\n    params.group = obj.group || params.group || property;\n    params.cycle = obj.cycle || params.cycle || false;\n    params.reverse = obj.reverse || params.reverse || false;\n    params.count = obj.count || params.count || 1;\n\n    const key = `${params.group}__${params.path}`;\n\n    if (!values[key]) {\n      if (params.count > 1) {\n        values[key] = JSONPath(params.path, data).slice(0, params.count);\n      } else {\n        values[key] = JSONPath(params.path, data);\n      }\n    }\n\n    if (params.cycle || params.reverse) {\n      return cycle(values[key], params.reverse);\n    }\n\n    return pick(values[key]);\n  }\n\n  Object.keys(obj).forEach(k => {\n    obj[k] = resolve(obj[k], data, values, k);\n  });\n\n  return obj;\n}\n\n// TODO provide types\nfunction run(refs, schema, container) {\n  try {\n    const result = traverse(utils.clone(schema), [], function reduce(sub, maxReduceDepth, parentSchemaPath) {\n      if (typeof maxReduceDepth === 'undefined') {\n        maxReduceDepth = random.number(1, 3);\n      }\n\n      if (!sub) {\n        return null;\n      }\n\n      if (typeof sub.generate === 'function') {\n        return sub;\n      }\n\n      // cleanup\n      const _id = sub.$id || sub.id;\n\n      if (typeof _id === 'string') {\n        delete sub.id;\n        delete sub.$id;\n        delete sub.$schema;\n      }\n\n      if (typeof sub.$ref === 'string') {\n        if (sub.$ref === '#') {\n          delete sub.$ref;\n          return sub;\n        }\n\n        let ref;\n\n        if (sub.$ref.indexOf('#/') === -1) {\n          ref = refs[sub.$ref] || null;\n        }\n\n        if (sub.$ref.indexOf('#/definitions/') === 0) {\n          ref = schema.definitions[sub.$ref.split('#/definitions/')[1]] || null;\n        }\n\n        if (typeof ref !== 'undefined') {\n          if (!ref && optionAPI('ignoreMissingRefs') !== true) {\n            throw new Error(`Reference not found: ${sub.$ref}`);\n          }\n\n          utils.merge(sub, ref || {});\n        }\n\n        // just remove the reference\n        delete sub.$ref;\n        return sub;\n      }\n\n      if (Array.isArray(sub.allOf)) {\n        const schemas = sub.allOf;\n\n        delete sub.allOf;\n\n        // this is the only case where all sub-schemas\n        // must be resolved before any merge\n        schemas.forEach(subSchema => {\n          const _sub = reduce(subSchema, maxReduceDepth + 1, parentSchemaPath);\n\n          // call given thunks if present\n          utils.merge(sub, typeof _sub.thunk === 'function'\n            ? _sub.thunk()\n            : _sub);\n        });\n      }\n\n      if (Array.isArray(sub.oneOf || sub.anyOf)) {\n        const mix = sub.oneOf || sub.anyOf;\n\n        // test every value from the enum against each-oneOf\n        // schema, only values that validate once are kept\n        if (sub.enum && sub.oneOf) {\n          sub.enum = sub.enum.filter(x => utils.validate(x, mix));\n        }\n\n        return {\n          thunk() {\n            const copy = utils.omitProps(sub, ['anyOf', 'oneOf']);\n            const fixed = random.pick(mix);\n            utils.merge(copy, fixed);\n\n            if (sub.oneOf) {\n              mix.forEach(omit => {\n                if (omit !== fixed && omit.required && copy.properties) {\n                  omit.required.filter(required => !(fixed.required || []).includes(required)).forEach(key => {\n                    delete copy.properties[key];\n                  });\n                }\n              });\n            }\n\n            return copy;\n          },\n        };\n      }\n\n      Object.keys(sub).forEach(prop => {\n        if ((Array.isArray(sub[prop]) || typeof sub[prop] === 'object') && !utils.isKey(prop)) {\n          sub[prop] = reduce(sub[prop], maxReduceDepth, parentSchemaPath.concat(prop));\n        }\n      });\n\n      // avoid extra calls on sub-schemas, fixes #458\n      if (parentSchemaPath) {\n        const lastProp = parentSchemaPath[parentSchemaPath.length - 1];\n\n        if (lastProp === 'properties' || lastProp === 'items') {\n          return sub;\n        }\n      }\n\n      return container.wrap(sub);\n    });\n\n    if (optionAPI('resolveJsonPath')) {\n      return resolve(result);\n    }\n\n    return result;\n  } catch (e) {\n    if (e.path) {\n      throw new Error(`${e.message} in /${e.path.join('/')}`);\n    } else {\n      throw e;\n    }\n  }\n}\n\nexport default run;\n","import $RefParser from '@meeshkanml/json-schema-ref-parser';\n\nimport Container from './class/Container';\nimport format from './api/format';\nimport option from './api/option';\nimport env from './core/constants';\nimport random from './core/random';\nimport utils from './core/utils';\nimport run from './core/run';\n\nconst container = new Container();\n\nfunction setupKeywords() {\n  // built-in support\n  container.define('pattern', random.randexp);\n\n  // safe auto-increment values\n  container.define('autoIncrement', function autoIncrement(value, schema) {\n    if (!this.offset) {\n      const min = schema.minimum || 1;\n      const max = min + env.MAX_NUMBER;\n      const offset = value.initialOffset || schema.initialOffset;\n\n      this.offset = offset || random.number(min, max);\n    }\n\n    if (value === true) {\n      return this.offset++; // eslint-disable-line\n    }\n\n    return schema;\n  });\n\n  // safe-and-sequential dates\n  container.define('sequentialDate', function sequentialDate(value, schema) {\n    if (!this.now) {\n      this.now = random.date();\n    }\n\n    if (value) {\n      schema = this.now.toISOString();\n      value = value === true\n        ? 'days'\n        : value;\n\n      if (['seconds', 'minutes', 'hours', 'days', 'weeks', 'months', 'years'].indexOf(value) === -1) {\n        throw new Error(`Unsupported increment by ${utils.short(value)}`);\n      }\n\n      this.now.setTime(this.now.getTime() + random.date(value));\n    }\n\n    return schema;\n  });\n}\n\nfunction getRefs(refs) {\n  let $refs = {};\n\n  if (Array.isArray(refs)) {\n    refs.forEach(schema => {\n      $refs[schema.$id || schema.id] = schema;\n    });\n  } else {\n    $refs = refs || {};\n  }\n\n  return $refs;\n}\n\nconst jsf = (schema, refs, cwd) => {\n  console.log('[json-schema-faker] calling JsonSchemaFaker() is deprecated, call either .generate() or .resolve()');\n\n  if (cwd) {\n    console.log('[json-schema-faker] references are only supported by calling .resolve()');\n  }\n\n  return jsf.generate(schema, refs);\n};\n\njsf.generate = (schema, refs) => {\n  const $refs = getRefs(refs);\n\n  return run($refs, schema, container);\n};\n\njsf.resolve = (schema, refs, cwd) => {\n  if (typeof refs === 'string') {\n    cwd = refs;\n    refs = {};\n  }\n\n  // normalize basedir (browser aware)\n  cwd = cwd || (typeof process !== 'undefined' ? process.cwd() : '');\n  cwd = `${cwd.replace(/\\/+$/, '')}/`;\n\n  const $refs = getRefs(refs);\n\n  // identical setup as json-schema-sequelizer\n  const fixedRefs = {\n    order: 300,\n    canRead: true,\n    read(file, callback) {\n      try {\n        callback(null, $refs[file.url] || $refs[file.url.split('/').pop()]);\n      } catch (e) {\n        callback(e);\n      }\n    },\n  };\n\n  return $RefParser\n    .dereference(cwd, schema, {\n      resolve: {\n        file: { order: 100 },\n        http: { order: 200 },\n        fixedRefs,\n      },\n      dereference: {\n        circular: 'ignore',\n      },\n    }).then(sub => run($refs, sub, container));\n};\n\nsetupKeywords();\n\njsf.format = format;\njsf.option = option;\njsf.random = random;\n\n// returns itself for chaining\njsf.extend = (name, cb) => {\n  container.extend(name, cb);\n  return jsf;\n};\n\njsf.define = (name, cb) => {\n  container.define(name, cb);\n  return jsf;\n};\n\njsf.reset = name => {\n  container.reset(name);\n  setupKeywords();\n  return jsf;\n};\n\njsf.locate = name => {\n  return container.get(name);\n};\n\njsf.version = '0.5.0-rc23';\n\nexport default jsf;\n"],"names":["order","allowEmpty","canParse","parse","file","Promise","resolve","reject","data","Buffer","isBuffer","toString","trim","length","undefined","JSON","isNothing","subject","sequence","Array","isArray","string","count","cycle","result","number","Number","NEGATIVE_INFINITY","target","source","index","key","sourceKeys","Object","keys","YAMLException","reason","mark","Error","call","this","name","message","captureStackTrace","constructor","stack","prototype","create","compact","Mark","buffer","position","line","column","getSnippet","indent","maxLength","head","start","tail","end","snippet","indexOf","charAt","slice","common","repeat","where","TYPE_CONSTRUCTOR_OPTIONS","YAML_NODE_KINDS","tag","options","map","forEach","kind","construct","instanceOf","predicate","represent","defaultStyle","styleAliases","style","alias","String","compileList","schema","exclude","include","includedSchema","currentType","previousType","previousIndex","push","filter","type","Schema","definition","implicit","explicit","loadKind","compiledImplicit","compiledExplicit","compiledTypeMap","scalar","mapping","fallback","collectType","arguments","compileMap","DEFAULT","schemas","types","toArray","every","Type","max","object","canonical","lowercase","uppercase","camelcase","isOctCode","c","isDecCode","ch","hasDigits","charCodeAt","test","base","value","sign","digits","replace","parseInt","split","v","unshift","d","isNegativeZero","binary","obj","octal","decimal","hexadecimal","toUpperCase","YAML_FLOAT_PATTERN","RegExp","SCIENTIFIC_WITHOUT_DOT","require$$0","require$$1","require$$2","require$$3","toLowerCase","POSITIVE_INFINITY","NaN","parseFloat","res","isNaN","YAML_DATE_REGEXP","YAML_TIMESTAMP_REGEXP","exec","match","year","month","day","hour","minute","second","date","fraction","delta","Date","UTC","setTime","getTime","toISOString","NodeBuffer","_require","require","__","BASE64_MAP","code","idx","bitlen","tailbits","input","bits","from","_hasOwnProperty","hasOwnProperty","_toString","pair","pairKey","pairHasKey","objectKeys","require$$4","require$$5","esprima","regexp","modifiers","global","multiline","ignoreCase","_","window","ast","range","body","expression","err","params","param","Function","CONTEXT_FLOW_IN","CONTEXT_FLOW_OUT","CONTEXT_BLOCK_IN","CONTEXT_BLOCK_OUT","CHOMPING_CLIP","CHOMPING_STRIP","CHOMPING_KEEP","PATTERN_NON_PRINTABLE","PATTERN_NON_ASCII_LINE_BREAKS","PATTERN_FLOW_INDICATORS","PATTERN_TAG_HANDLE","PATTERN_TAG_URI","_class","is_EOL","is_WHITE_SPACE","is_WS_OR_EOL","is_FLOW_INDICATOR","fromHexCode","lc","simpleEscapeSequence","charFromCodepoint","fromCharCode","simpleEscapeCheck","simpleEscapeMap","i","State","filename","DEFAULT_FULL_SCHEMA","onWarning","legacy","json","listener","implicitTypes","typeMap","lineStart","lineIndent","documents","generateError","state","throwError","throwWarning","directiveHandlers","YAML","args","major","minor","version","checkLineBreaks","TAG","handle","prefix","tagMap","captureSegment","checkJson","_position","_length","_character","_result","mergeMappings","destination","overridableKeys","quantity","isObject","storeMappingPair","keyTag","keyNode","valueNode","startLine","startPos","readLineBreak","skipSeparationSpace","allowComments","checkIndent","lineBreaks","testDocumentSeparator","writeFoldedLines","readBlockSequence","nodeIndent","_line","_tag","_anchor","anchor","detected","anchorMap","composeNode","readTagProperty","tagHandle","tagName","isVerbatim","isNamed","readAnchorProperty","parentIndent","nodeContext","allowToSeek","allowCompact","allowBlockStyles","allowBlockScalars","allowBlockCollections","typeIndex","typeQuantity","flowIndent","blockIndent","indentStatus","atNewLine","hasContent","following","_pos","atExplicitKey","readBlockMapping","terminator","isPair","isExplicitPair","isMapping","readNext","readFlowCollection","captureStart","folding","tmp","chomping","didReadContent","detectedIndent","textIndent","emptyLines","atMoreIndented","readBlockScalar","captureEnd","readSingleQuotedScalar","hexLength","hexResult","readDoubleQuotedScalar","readAlias","withinFlowCollection","hasPendingContent","_lineStart","_lineIndent","_kind","readPlainScalar","readDocument","directiveName","directiveArgs","documentStart","hasDirectives","loadDocuments","loadAll","iterator","load","output","extend","DEFAULT_SAFE_SCHEMA","CHAR_TAB","CHAR_LINE_FEED","CHAR_SPACE","CHAR_EXCLAMATION","CHAR_DOUBLE_QUOTE","CHAR_SHARP","CHAR_PERCENT","CHAR_AMPERSAND","CHAR_SINGLE_QUOTE","CHAR_ASTERISK","CHAR_COMMA","CHAR_MINUS","CHAR_COLON","CHAR_GREATER_THAN","CHAR_QUESTION","CHAR_COMMERCIAL_AT","CHAR_LEFT_SQUARE_BRACKET","CHAR_RIGHT_SQUARE_BRACKET","CHAR_GRAVE_ACCENT","CHAR_LEFT_CURLY_BRACKET","CHAR_VERTICAL_LINE","CHAR_RIGHT_CURLY_BRACKET","ESCAPE_SEQUENCES","0","7","8","9","10","11","12","13","27","34","92","133","160","8232","8233","DEPRECATED_BOOLEANS_SYNTAX","encodeHex","character","Math","noArrayIndent","skipInvalid","flowLevel","styleMap","compileStyleMap","sortKeys","lineWidth","noRefs","noCompatMode","condenseFlow","explicitTypes","duplicates","usedDuplicates","indentString","spaces","ind","next","generateNextLine","level","isWhitespace","isPrintable","isPlainSafe","needIndentIndicator","STYLE_PLAIN","STYLE_SINGLE","STYLE_LITERAL","STYLE_FOLDED","STYLE_DOUBLE","chooseScalarStyle","singleLineOnly","indentPerLevel","testAmbiguousType","char","hasLineBreak","hasFoldableLine","shouldTrackWidth","previousLineBreak","plain","writeScalar","iskey","dump","min","str","testImplicitResolving","blockHeader","dropEndingNewline","width","moreIndented","lineRe","nextLF","lastIndex","foldLine","prevMoreIndented","foldString","nextChar","escapeSeq","escapeString","indentIndicator","clip","breakRe","curr","detectType","typeList","writeNode","block","duplicateIndex","duplicate","objectOrArray","objectKey","objectValue","explicitPair","pairBuffer","objectKeyList","sort","writeBlockMapping","writeFlowMapping","arrayLevel","writeBlockSequence","writeFlowSequence","getDuplicateReferences","objects","duplicatesIndexes","inspectNode","deprecated","require$$6","loader","safeLoad","safeLoadAll","dumper","safeDump","require$$7","nonJsonTypes","protectedProps","objectPrototype","getPrototypeOf","toJSON","pojo","error","getDeepKeys","includes","omit","concat","getOwnPropertyNames","getOwnPropertySymbols","uniqueKeys","Set","delete","inspectMethod","util","inspect","custom","Symbol","for","formatter","format","addInspectMethod","newError","newline","onoCall","supportsLazyStack","Boolean","getOwnPropertyDescriptor","defineProperty","navigator","userAgent","joinStacks","originalError","newStack","popStack","originalStack","lazyJoinStacks","descriptor","get","apply","enumerable","configurable","lazyPopStack","lines","splice","join","extendError","props","hasLazyStack","extendStack","_newError","_originalError","e","mergeErrors","assign","onoConstructor","Ono","onoSingleton","klass","formatArgs","formattedMessage","eval","EvalError","RangeError","reference","ReferenceError","syntax","SyntaxError","TypeError","uri","URIError","_toJSON","module","exports","default","ono","[object Object]","text","reviver","yaml","replacer","space","TEXT_REGEXP","encoding","url","BINARY_REGEXP","isWindows","process","platform","forwardSlashPattern","protocolPattern","urlEncodePatterns","urlDecodePatterns","browser","location","href","cwd","path","lastDot","lastIndexOf","substr","hashIndex","protocol","getProtocol","encodeURI","keepFileProtocol","decodeURI","isFileUrl","canRead","isFileSystemPath","read","toFileSystemPath","fs","readFile","headers","timeout","redirects","withCredentials","isHttp","u","download","httpOptions","https","http","req","hostname","port","auth","setTimeout","on","abort","once","alloc","then","statusCode","status","redirectTo","catch","$RefParserOptions","merge","defaults","isMergeable","sourceSetting","targetSetting","val","jsonParser","yamlParser","textParser","binaryParser","fileResolver","httpResolver","external","dereference","circular","Pointer","slashes","tildes","escapedSlash","escapedTilde","$ref","friendlyPath","originalPath","indirections","resolveIf$Ref","pointer","$Ref","isAllowed$Ref","$refPath","resolved","$refs","_resolve","isExtended$Ref","setValue","token","tokens","set","getHash","decodeURIComponent","encodeURIComponent","pathType","exists","is$Ref","isExternal$Ref","resolvedValue","merged","$Refs","_$refs","_root$Ref","getPaths","paths","encoded","decoded","values","reduce","absPath","withoutHash","stripHash","_add","_get$Ref","getResult","prop","callback","extension","plugins","method","plugin","MAX_SAFE_INTEGER","a","b","lastError","runNextPlugin","onSuccess","onError","async","getExtension","resolver","resolvers","all","run","parser","allParsers","filteredParsers","parsers","parseFile","pop","Options","promises","crawl","resolve$Ref","keyPath","resolvedPath","inventory","hash","pathFromRoot","extended","depth","aDefinitionsIndex","bDefinitionsIndex","entry","parent","remap","inventory$Ref","keyPathFromRoot","$refParent","$refKey","existingEntry","findInInventory","removeFromInventory","dereferenced","parents","dereference$Ref","foundCircularReference","directCircular","dereferencedValue","nextTick","setImmediate","f","cb","promise","$RefParser","instance","normalizeArgs","maybe","fromFileSystemPath","me","resolveExternal","bundle","Registry","unregister","register","registerMany","formats","list","const","random","registry","_defaults","optionAPI","nameOrOptionMap","optionalValue","getDefaults","ROOT","GROUP","POSITION","SET","RANGE","REPETITION","REFERENCE","CHAR","INTS","to","WORDS","WHITESPACE","NOTANYCHAR","not","SLSH","t","n","r","s","lbs","a16","b16","c8","dctrl","eslsh","regexpStr","rs","sets","msg","l","lastGroup","last","groupStack","repeatErr","strToChars","positions","classTokens","tokenizeClass","group","remember","followedBy","notFollowedBy","Infinity","SubRange","low","high","DRange","ranges","add","previous","subrange","touches","newRanges","_update_length","_subtract","overlaps","subtract","_intersect","RandExp","m","_setDefaults","ret","defaultRange","clone","randInt","_gen","groups","groupNumber","_randSelect","expandedSet","_expand","_randBool","_toOtherCase","arr","drange","j","otherCaseCode","intersect","floor","_range","randexp","_randexp","gen","defMin","defMax","hasPrecision","env","MIN_NUMBER","MAX_NUMBER","getRandom","MIN_INTEGER","MAX_INTEGER","getRandomInteger","collection","step","by","now","days","MOST_NEAR_DATETIME","copy","anyValue","pick","PI","dotSeparatedKey","keyElements","shift","properties","k","minimum","maximum","enum","exclusiveMinimum","multipleOf","exclusiveMaximum","x","minLength","_maxLength","_minLength","pattern","stringify","ALL_TYPES","required","template","$1","Container","support","reset","property","rootSchema","fn","ctx","define","wrap","context","formatAPI","nameOrFormatMap","ParseError","inferredProperties","array","integer","subschemaProperties","matchesType","lastElementInPath","inferredTypeProperties","isSubschema","booleanType","nullType","numberType","ceil","num","fix","boundary","LIPSUM_WORDS","wordsGenerator","shuffle","anyType","produce","words","thunkGenerator","_min","_max","dateTimeGenerator","URI_PATTERN","regexps","email","ipv6","slug","uuid","iri","ALLOWED_FORMATS","generateFormat","invalid","coreFormat","dateTime","utils","short","boolean","_boolean","null","_null","traverseCallback","items","additionalItems","hasProperties","item","itemSubpath","minItems","maxItems","optionalsProbability","fixedProbabilities","round","abs","sample","current","element","uniqueItems","seen","walk","limit","unique","_number","patternProperties","requiredProperties","allowsAdditional","additionalProperties","propertyKeys","patternPropertyKeys","optionalProperties","_response","_key","allProperties","ignoreProperties","minProperties","maxProperties","neededExtras","extraPropertiesRandomOrder","extraProperties","_item","_props","_defns","dependencies","_required","sub","allOf","skipped","let","found","subschema","fillProps","reuseProps","suffix","one","word","typecast","opts","thunk","traverse","examples","fixedExamples","notValue","omitProps","generate","jsonPath","schemaPath","typeName","inferType","reverse","JSONPath","refs","container","maxReduceDepth","parentSchemaPath","$id","id","$schema","ref","definitions","subSchema","_sub","oneOf","anyOf","mix","validate","fixed","isKey","lastProp","setupKeywords","offset","initialOffset","getRefs","jsf","console","log","fixedRefs","option","locate"],"mappings":"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"}